<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年21天主题挑战之灵感篇-Day 1-写下自己期待中的生平</title>
    <url>/2020/01/02/21-Day-Challenge-01/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还记得我19年总结最下面的那张照片么，那个同事送的的本子，对，就是下面这张图，这本子叫做《One In A Million》中文叫做极少数手册，是一个管理时间用的管理手册，英文如果直译的话应该是叫做万里挑一，实话说我并不是很自信，虽然我觉得自己还算可以，但远远达不到万里挑一的程度，所以，我打算好好利用这个本子，让自己尽可能成为百里挑一，千里挑一，最后万里挑一的人。</p>
<p>本子里有一个栏目叫做21天主题挑战，21-Day Challenge，每个月21天都会给你列出一些主题，越往后列出来的主题越少，更多的需要个人去补充，我想去挑战这些内容，让自己的生活变得有目标，让自己变得更好。</p>
<span id="more"></span>

<h1 id="1月份21天主题挑战之灵感Inspiration"><a href="#1月份21天主题挑战之灵感Inspiration" class="headerlink" title="1月份21天主题挑战之灵感Inspiration"></a>1月份21天主题挑战之灵感Inspiration</h1><blockquote>
<p>设定一个挑战主题，让自己更富有创造力，连续21天挑战，让灵感乍现，唤醒天赋。</p>
</blockquote>
<h1 id="第一天-Day-1-写下自己期待中的生平"><a href="#第一天-Day-1-写下自己期待中的生平" class="headerlink" title="第一天 Day 1 写下自己期待中的生平"></a>第一天 Day 1 写下自己期待中的生平</h1><p>看到这个题目之后，我闭上了眼睛，努力的回想我自己曾经的梦想是什么，什么时候丢掉了梦想，儿时的梦想，上学时的梦想，长大以后的梦想，现在的梦想，我努力回想了好久好久，儿时的梦想我想起来了，上学时的梦想我想起来了，长大后的梦想我也想起来了，但是我没能一下子找到我现在的梦想，也许现在说梦想有些奢侈，也许也有点贴不上今天的主题期待中的人生，我不太会写文章，但是想到哪里写哪里吧，我先写下我之前的那些个梦想。</p>
<h2 id="小时候的梦想-成为科学家"><a href="#小时候的梦想-成为科学家" class="headerlink" title="小时候的梦想-成为科学家"></a>小时候的梦想-成为科学家</h2><p>小时候的梦想说出来很简单，但是是那么真诚，真诚就容易打动人，说实话我记性不是太好，已经忘掉了小时候的梦想，所以我问了我妈，我妈笑话我，说我咋不记得小时候那伟大的梦想了，妈妈说我儿时的梦想是当科学家，那会应该是上小学吧，妈妈说学校老师让写作文，标题就是我的梦想，我的作文里写的是成为科学家，这个科学家不像是别人写的，比如造火箭，造大炮又或者是造卫星造原子弹，我的梦想现在说起来与其说是科学家，不如说是药剂师更贴切，妈妈笑着跟我说我当时的梦想是做一个科学家，要研究出来一种长生不老的药，然后让爸爸妈妈吃下以后就可以永远健康年轻，妈妈说那个时候她总逗我，看到路上漂亮的阿姨就会问我，那个阿姨漂亮么，起初我会说漂亮，然后妈妈就会说那让她给你当妈妈好不好，我呢会说不好，妈妈说后来她再问的时候，我就再也不会说我要漂亮阿姨当妈妈的话了，我现在想想也许就是那时，就是因为发现妈妈越来越胖，辛苦操劳后年轻也渐渐不在我才有了这个想法吧，说实话上小学期间我一直认为自己长大能够成为一个科学家，能够造出那长生不老的药让爸妈吃下，这样我就再也不会需要一个漂亮阿姨当妈妈了。我那时希望快快长大，长大了以后我就能做科学家了。</p>
<p>上了初中高中以后，也许是进了大城市，也许是长大了，我知道了原来的梦想可能有些遥远，学业的压力让我有些透不过气，从海岛到城市，落后了3年的时间，我通过补习班慢慢追赶，终于能够追到了班级还算靠前的位置，那个时候我的梦想很小，也很简单，那就是考个好大学找个好工作，让爸爸妈妈早点不用那么操劳，早点享福。</p>
<h2 id="18岁的梦想-—-找个好工作，让爸妈早点享福"><a href="#18岁的梦想-—-找个好工作，让爸妈早点享福" class="headerlink" title="18岁的梦想 — 找个好工作，让爸妈早点享福"></a>18岁的梦想 — 找个好工作，让爸妈早点享福</h2><p>努力的学习，懵懂的感情，初中4年+高中3年的生活，最终我并没能特别出色的考上985/211大学，而是上了离家只有1小时车程的大外，学了计算机加日语英语，学费不便宜，每年16000，说实话没自己工作的时候不知道这16000对于一个下岗自己在家开小卖店的父母是多大的负担，工作后我才终于知道这笔钱有多少。好在原来在爸爸单位的时候接触电脑还算比较早，而我对这个新鲜玩意也算是感兴趣，大学学业上并没给我带来太大的压力，但是我也确实不是个聪明的孩子，日语仅仅过了N2，而英语则一直只是CET-4，现在回想起来，原来应该多努努力，也许现在的生活就会更好了，多想回到过去跟自己说，你要努力啊！一晃4年的大学生活就结束了，这时我终于离开了父母身边，只身去往了大城市北京，开启了我的工作生涯。</p>
<h2 id="20岁的人生-—-多挣钱，快速成长"><a href="#20岁的人生-—-多挣钱，快速成长" class="headerlink" title="20岁的人生 — 多挣钱，快速成长"></a>20岁的人生 — 多挣钱，快速成长</h2><p>工作了以后，我就像海绵一样不断的吸收着周围的水分，学习工作中需要的技能，学习如何才能让领导器重，学习如何才能快速积累人生的财富，因为我想着，想着能快快独立反哺我的爸妈。20岁，我跟媳妇儿谈了场异地的恋爱，后来她到北京找我，再后来我们就一起回了大连。北京是个大城市，大的有时候让人迷茫，虽然工作机会比较多，但是租房的压力，环境的恶劣，家里的呼唤，最终让我选择了回到我熟悉的城市，另外找了份工资不高的工作，我不满足，我想能成为顶天立地的男子汉，后来我就来到了现在的公司华宇，而且一待就是5年。</p>
<h2 id="华宇的职业生涯-—-5年工作，9年经验"><a href="#华宇的职业生涯-—-5年工作，9年经验" class="headerlink" title="华宇的职业生涯 — 5年工作，9年经验"></a>华宇的职业生涯 — 5年工作，9年经验</h2><p>网上有个段子我记得，一个人面试拿出简历，工作时间是2年却写着3年工作经验，面试官问他是不是写错了，他答不是，因为加班加出来的。这算是对前公司的吐槽吧。</p>
<p>来到大连华宇时，公司还不足120人，我所在的团队还是个交互组，只有三个人，前端的话只有我和另外一个刚毕业的大学生，记得刚来公司的第一年，我参与了140个项目的开发工作，现在想想这个数字有些惊人，但是因为只是些前端切图仔的工作，对我来说感觉难度并不大，不过还是要感谢刚开始这2年，让我的基础非常扎实，再后来公司引入了前后端分离，引入了Vue框架，越来越多的业务要写，数据处理要写，加班成了家常便饭，后面这三年，我几乎没有休过除了元旦和春节的任何法定节假日，每年5天的年假也几乎都没休成，说实话每次加班加到要崩溃时候，我都会想我到底为了啥这么拼命。要不我还是换一家比较轻松一点的工作吧，工资还能涨点。说实话这段时间工作就是生活的全部，每天到家都10点以后，到家老人孩子都睡了，有时候我都睡不着，想着我的生活难道就这样了么，我不甘心，不服输。很多人劝我别那么拼命，别把公司当成自己家的，只是个打工的而已，但是有时候想着下面还有那么多新人信任着我依赖着我，我就没法撒手不管。终于时间到了19年年底，5年来培养的前端团队最后还是没守护住，要拆到各项目团队了，一开始真的难以接受，不过公司领导层已经决定了，作为一线员工只能服从，我希望大家能够把心中的担忧都能消除掉，在新的团队里开启新的篇章，也许会有更好的发展，如果有一天离开了华宇，也要江湖相望，常聚聚。</p>
<h2 id="2020年31岁踏上新的旅途"><a href="#2020年31岁踏上新的旅途" class="headerlink" title="2020年31岁踏上新的旅途"></a>2020年31岁踏上新的旅途</h2><p>还是感谢小可爱的这个本子，让我能够有主题想想我未来到底想要什么样的生活，说句实在话，我向往不为钱发愁工作的日子，可以在做好自己工作之外的时间里多陪陪家人，带着孩子常出去走走，见见外面的世界，说实话已经31岁了，除了谈恋爱时去找媳妇儿去过江浙苏杭，工作原因去过北京/青海，好像这些年也就去了趟南京，现在的我已经有些不知道什么叫做生活了，我希望自己的空闲时间是可以让兴趣填满的，可以和朋友同事同学多聚聚，但是怕打扰大家我又从来不会主动去约别人，小时候没有听从爸妈的话培养自己的兴趣，现在有些后悔，真的空闲下来都不知道该用什么填满这时间，都是躺在床上刷手机，看电视，我不喜欢这样的生活，但是我不知道该过怎么样的生活。看到那些会做饭的视频，做顿丰盛的饭菜给家人吃，看到他们的幸福笑脸，我想做那样的事；看到带着家人过着一路向前增长见闻的旅途生活，我想也尝试一下那样的人生，我感觉为了钱我被束缚在了工作上，2020年我想过一种不为工作所累，不为钱所累，能够享受生活，陪伴家人的生活，保重身体，每天快快乐乐的，多发现生活中的美好，感恩，努力，成长。期待自己成为更好的人。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我所期待中的生平，成为一个不被工作强迫，不被金钱所累，爱家顾家，孝敬父母，人缘好朋友多，兴趣广泛，感恩的人。</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>杂记随感</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始：Vue cli3 库模式搭建组件库并发布到npm【转载】</title>
    <url>/2020/04/16/0-vuecli-3-component/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>市面上目前已有各种各样的UI组件库，比如 Element 和 iView，他们的强大毋庸置疑。但是我们面临的情况是需求越来越复杂，当它们不能再满足我们需求的时候，这个时候就有必要开发一套属于自己团队的组件库了。</p>
<p>所以本文的目的就是让读者能通过此文，小能做一个简单的插件供人使用，大能架构和维护一个组件库不在话下。</p>
<p>以下一个简单的颜色选择器插件vColorPicker讲述从开发到上线到npm的流程。</p>
<p><a href="http://vue-color-picker.rxshc.com/">vColorPicker 插件 DEMO</a></p>
<span id="more"></span>
<h2 id="一、技术栈"><a href="#一、技术栈" class="headerlink" title="一、技术栈"></a>一、技术栈</h2><p>如何通过新版脚手架创建项目，这里就不提了，自行看官方文档。</p>
<ul>
<li>Vue-cli3: 新版脚手架的库模式，可以让我们很轻松的创建打包一个库</li>
<li>npm：组件库将存放在npm</li>
<li>webpack：修改配置需要一点 webapck 的知识。</li>
</ul>
<h2 id="二、大纲"><a href="#二、大纲" class="headerlink" title="二、大纲"></a>二、大纲</h2><p>想要搭建一个组件库，我们必须先要有一个大概的思路。</p>
<ol>
<li>规划目录结构</li>
<li>配置项目以支持目录结构</li>
<li>编写组件</li>
<li>编写示例</li>
<li>配置使用库模式打包编译</li>
<li>发布到npm</li>
</ol>
<h2 id="三、规划目录结构"><a href="#三、规划目录结构" class="headerlink" title="三、规划目录结构"></a>三、规划目录结构</h2><h3 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h3><p>在指定目录中使用命令创建一个默认的项目，或者根据自己需要自己选择。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ vue create .</span><br></pre></td></tr></table></figure>
<h3 id="2、调整目录"><a href="#2、调整目录" class="headerlink" title="2、调整目录"></a>2、调整目录</h3><p>我们需要一个目录存放组件，一个目录存放示例，按照以下方式对目录进行改造。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">...</span><br><span class="line">|-- examples      <span class="comment">// 原 src 目录，改成 examples 用作示例展示</span></span><br><span class="line">|-- packages      <span class="comment">// 新增 packages 用于编写存放组件</span></span><br><span class="line">...</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<h2 id="四、配置项目以支持新的目录结构"><a href="#四、配置项目以支持新的目录结构" class="headerlink" title="四、配置项目以支持新的目录结构"></a>四、配置项目以支持新的目录结构</h2><p>我们通过上一步的目录改造后，会遇到两个问题。</p>
<ol>
<li>src目录更名为examples，导致项目无法运行</li>
<li>新增packages目录，该目录未加入webpack编译</li>
</ol>
<p><strong>注：cli3 提供一个可选的 vue.config.js 配置文件。如果这个文件存在则他会被自动加载，所有的对项目和webpack的配置，都在这个文件中。</strong></p>
<h3 id="1、重新配置入口，修改配置中的-pages-选项"><a href="#1、重新配置入口，修改配置中的-pages-选项" class="headerlink" title="1、重新配置入口，修改配置中的 pages 选项"></a>1、重新配置入口，修改配置中的 pages 选项</h3><p>新版 Vue CLI 支持使用 vue.config.js 中的 pages 选项构建一个多页面的应用。</p>
<p>这里使用 pages 修改入口到 examples</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 修改 src 为 examples</span></span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">&#x27;examples/main.js&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、支持对-packages-目录的处理，修改配置中的-chainWebpack-选项"><a href="#2、支持对-packages-目录的处理，修改配置中的-chainWebpack-选项" class="headerlink" title="2、支持对 packages 目录的处理，修改配置中的 chainWebpack 选项"></a>2、支持对 packages 目录的处理，修改配置中的 chainWebpack 选项</h3><p>packages 是我们新增的一个目录，默认是不被 webpack 处理的，所以需要添加配置对该目录的支持。</p>
<p>chainWebpack 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 修改 src 为 examples</span></span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      entry: <span class="string">&#x27;examples/main.js&#x27;</span>,</span><br><span class="line">      template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 扩展 webpack 配置，使 packages 加入编译</span></span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">      .include</span><br><span class="line">        .add(<span class="string">&#x27;packages&#x27;</span>)</span><br><span class="line">        .end()</span><br><span class="line">      .use(<span class="string">&#x27;babel&#x27;</span>)</span><br><span class="line">        .loader(<span class="string">&#x27;babel-loader&#x27;</span>)</span><br><span class="line">        .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 修改它的选项...</span></span><br><span class="line">          <span class="keyword">return</span> options</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7">链式操作</a><br><a href="https://github.com/neutrinojs/webpack-chain">webpack-chain</a></p>
<h2 id="五、编写组件"><a href="#五、编写组件" class="headerlink" title="五、编写组件"></a>五、编写组件</h2><p>以上我们已配置好对新目录架构的支持，接下来我们尝试编写组件。以下我们以一个已发布到 npm 的小插件作为示例。<br><a href="https://github.com/zuley/vue-color-picker">GitHub - 颜色选择器：vcolorpicker</a></p>
<h3 id="1-创建一个新组件"><a href="#1-创建一个新组件" class="headerlink" title="1. 创建一个新组件"></a>1. 创建一个新组件</h3><ol>
<li>在 packages 目录下，所有的单个组件都以文件夹的形式存储，所有这里创建一个目录 color-picker/</li>
<li>在 color-picker/ 目录下创建 src/ 目录存储组件源码</li>
<li>在 /color-picker 目录下创建 index.js 文件对外提供对组件的引用。<br>修改 /packages/color-picker/index.js文件，对外提供引用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./packages/color-picker/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件，组件必须声明 name</span></span><br><span class="line"><span class="keyword">import</span> colorPicker <span class="keyword">from</span> <span class="string">&#x27;./src/color-picker.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为组件提供 install 安装方法，供按需引入</span></span><br><span class="line">colorPicker = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.component(colorPicker.name, colorPicker)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> colorPicker</span><br></pre></td></tr></table></figure>
<h3 id="2-整合所有的组件，对外导出，即一个完整的组件库"><a href="#2-整合所有的组件，对外导出，即一个完整的组件库" class="headerlink" title="2. 整合所有的组件，对外导出，即一个完整的组件库"></a>2. 整合所有的组件，对外导出，即一个完整的组件库</h3><p>修改 /packages/index.js 文件，对整个组件库进行导出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./packages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入颜色选择器组件</span></span><br><span class="line"><span class="keyword">import</span> colorPicker <span class="keyword">from</span> <span class="string">&#x27;./color-picker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储组件列表</span></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  colorPicker</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否安装</span></span><br><span class="line">  <span class="keyword">if</span> (install.installed) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 遍历注册全局组件</span></span><br><span class="line">  components.map(<span class="function"><span class="params">component</span> =&gt;</span> Vue.component(component.name, component))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是直接引入文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  install(<span class="built_in">window</span>.Vue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// 导出的对象必须具有 install，才能被 Vue.use() 方法安装</span></span><br><span class="line">  install,</span><br><span class="line">  <span class="comment">// 以下是具体的组件列表</span></span><br><span class="line">  colorPicker</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、编写示例"><a href="#六、编写示例" class="headerlink" title="六、编写示例"></a>六、编写示例</h2><h3 id="1、在示例中导入组件库"><a href="#1、在示例中导入组件库" class="headerlink" title="1、在示例中导入组件库"></a>1、在示例中导入组件库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件库</span></span><br><span class="line"><span class="keyword">import</span> ColorPicker <span class="keyword">from</span> <span class="string">&#x27;./../packages/index&#x27;</span></span><br><span class="line"><span class="comment">// 注册组件库</span></span><br><span class="line">Vue.use(ColorPicker)</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2、在示例中使用组件库中的组件"><a href="#2、在示例中使用组件库中的组件" class="headerlink" title="2、在示例中使用组件库中的组件"></a>2、在示例中使用组件库中的组件</h3><p>在上一步用使用 Vue.use() 全局注册后，即可在任意页面直接使用了，而不需另外引入。当然也可以按需引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;colorPicker v-model=<span class="string">&quot;color&quot;</span> v-on:change=<span class="string">&quot;headleChangeColor&quot;</span>&gt;&lt;/colorPicker&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	data () &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			color: <span class="string">&#x27;#ff0000&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		headleChangeColor () &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">&#x27;颜色改变&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="七、发布到-npm，方便直接在项目中引用"><a href="#七、发布到-npm，方便直接在项目中引用" class="headerlink" title="七、发布到 npm，方便直接在项目中引用"></a>七、发布到 npm，方便直接在项目中引用</h2><p>到此为止我们一个完整的组件库已经开发完成了，接下来就是发布到 npm 以供后期使用。</p>
<h3 id="1、package-js-中新增一条编译为库的命令"><a href="#1、package-js-中新增一条编译为库的命令" class="headerlink" title="1、package.js 中新增一条编译为库的命令"></a>1、package.js 中新增一条编译为库的命令</h3><p>在库模式中，Vue是外置的，这意味着即使在代码中引入了 Vue，打包后的文件也是不包含Vue的。</p>
<p><a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%93">Vue Cli3 构建目标：库</a></p>
<p>以下我们在 scripts 中新增一条命令</p>
<ul>
<li>–target: 构建目标，默认为应用模式。这里修改为 lib 启用库模式。</li>
<li>–dest : 输出目录，默认 dist。这里我们改成 lib</li>
<li>[entry]: 最后一个参数为入口文件，默认为 src/App.vue。这里我们指定编译 packages/ 组件库目录。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;script&quot;</span>: &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="string">&quot;lib&quot;</span>: <span class="string">&quot;vue-cli-service build --target lib --name vcolorpicker --dest lib packages/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>执行编译库命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run lib</span><br></pre></td></tr></table></figure>
<h3 id="2、配置-package-json-文件中发布到-npm-的字段"><a href="#2、配置-package-json-文件中发布到-npm-的字段" class="headerlink" title="2、配置 package.json 文件中发布到 npm 的字段"></a>2、配置 package.json 文件中发布到 npm 的字段</h3><ul>
<li>name: 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。</li>
<li>version: 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。</li>
<li>description: 描述。</li>
<li>main: 入口文件，该字段需指向我们最终编译后的包文件。</li>
<li>keyword：关键字，以空格分离希望用户最终搜索的词。</li>
<li>author：作者</li>
<li>private：是否私有，需要修改为 false 才能发布到 npm</li>
<li>license： 开源协议</li>
</ul>
<p>以下为参考设置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;vcolorpicker&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;基于 Vue 的颜色选择器&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;lib/vcolorpicker.umd.min.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;keyword&quot;</span>: <span class="string">&quot;vcolorpicker colorpicker color-picker&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">false</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、添加-npmignore-文件，设置忽略发布文件"><a href="#3、添加-npmignore-文件，设置忽略发布文件" class="headerlink" title="3、添加 .npmignore 文件，设置忽略发布文件"></a>3、添加 .npmignore 文件，设置忽略发布文件</h3><p>我们发布到 npm 中，只有编译后的 lib 目录、package.json、README.md才是需要被发布的。所以我们需要设置忽略目录和文件。</p>
<p>和 .gitignore 的语法一样，具体需要提交什么文件，看各自的实际情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略目录</span></span><br><span class="line">examples/</span><br><span class="line">packages/</span><br><span class="line">public/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略指定文件</span></span><br><span class="line">vue.config.js</span><br><span class="line">babel.config.js</span><br><span class="line">*.map</span><br></pre></td></tr></table></figure>
<h3 id="4、登录到-npm"><a href="#4、登录到-npm" class="headerlink" title="4、登录到 npm"></a>4、登录到 npm</h3><p>首先需要到 npm 上注册一个账号，注册过程略。</p>
<p>如果配置了淘宝镜像，先设置回npm镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry http://registry.npmjs.org</span><br></pre></td></tr></table></figure>
<p>然后在终端执行登录命令，输入用户名、密码、邮箱即可登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm login</span><br></pre></td></tr></table></figure>

<h3 id="5、发布到-npm"><a href="#5、发布到-npm" class="headerlink" title="5、发布到 npm"></a>5、发布到 npm</h3><p>执行发布命令，发布组件到 npm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm publish</span><br></pre></td></tr></table></figure>

<h3 id="6、发布成功"><a href="#6、发布成功" class="headerlink" title="6、发布成功"></a>6、发布成功</h3><p>发布成功后稍等几分钟，即可在 npm 官网搜索到。以下是刚提交的 vcolorpicker</p>
<h3 id="7、使用新发布的组件库"><a href="#7、使用新发布的组件库" class="headerlink" title="7、使用新发布的组件库"></a>7、使用新发布的组件库</h3><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install vcolorpicker -S</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 main.js 引入并注册</span></span><br><span class="line"><span class="keyword">import</span> vcolorpicker <span class="keyword">from</span> <span class="string">&#x27;vcolorpicker&#x27;</span></span><br><span class="line">Vue.use(vcolorpicker)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件中使用</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;colorPicker v-model=<span class="string">&quot;color&quot;</span> /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        color: <span class="string">&#x27;#ff0000&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>暂时没有做包含多个组件的时候的按需加载，以后研究了再补充。</p>
<h2 id="八、项目地址"><a href="#八、项目地址" class="headerlink" title="八、项目地址"></a>八、项目地址</h2><p><a href="https://github.com/zuley/vue-color-picker">Github 地址：https://github.com/zuley/vue-color-picker</a><br><a href="https://www.npmjs.com/package/vcolorpicker">npm 地址：https://www.npmjs.com/package/vcolorpicker</a><br><a href="http://vue-color-picker.rxshc.com/">DEMO 演示：http://vue-color-picker.rxshc.com</a></p>
<h2 id="九、参考文章"><a href="#九、参考文章" class="headerlink" title="九、参考文章"></a>九、参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/30948290">从零开始搭建Vue组件库 VV-UI</a><br><a href="https://cn.vuejs.org/v2/guide/plugins.html#%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6">Vue插件开发</a><br><a href="https://cn.vuejs.org/v2/guide/components.html">组件基础</a></p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS border三角、圆角图形生成技术详解</title>
    <url>/2013/06/26/CSS-Triangle-Circle/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用CSS的border属性可以生成一些图形，例如三角或是圆角。纯粹的CSS2的内容，没有兼容性的问题，我之前在纯CSS实现各类气球泡泡对话框效果一文中算是比较详细的讲述了CSS border属性生成三角的原理，以及实例。我觉得此技术相当实用的，故本文再次简单叙述一下，另外，本文还将展示可能并不为众人所知的CSS border圆角生成技术。好了，裹脚布的话就不说了，直接进入正题。</p>
<span id="more"></span>

<h1 id="CSS-border生成三角技术简介"><a href="#CSS-border生成三角技术简介" class="headerlink" title="CSS border生成三角技术简介"></a>CSS border生成三角技术简介</h1><h2 id="效果抢鲜"><a href="#效果抢鲜" class="headerlink" title="效果抢鲜"></a>效果抢鲜</h2><p>下图为使用CSS的border属性实现的三角效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css 代码</span><br><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border-width: 20px 10px; </span><br><span class="line">  border-style: solid; </span><br><span class="line">  border-color: #ff3300 #ff3300 #ffffff #ffffff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何实现的，为何会有这样的效果，不急，take it easy!</p>
<h2 id="梯形图案"><a href="#梯形图案" class="headerlink" title="梯形图案"></a>梯形图案</h2><p>看下面这段样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 10px; </span><br><span class="line">  height: 10px; </span><br><span class="line">  border: 10px solid; </span><br><span class="line">  border-color: #ff3300 #0000ff #339966 #00ff00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某个div应用了上面这个样式后，结果会如何？见下图（截自Firefox3.5，IE浏览器有细节上的差异）：</p>
<h2 id="更进一步-–-部分边框透明"><a href="#更进一步-–-部分边框透明" class="headerlink" title="更进一步 – 部分边框透明"></a>更进一步 – 部分边框透明</h2><p>现在，设想一下，如果我们现在只保留一个一个上边框，其余边框均transparent透明（或与背景色同色），那么是不是就只显示一个上面红色的边框了，我们测试下，与上面类似的代码，只是修改下其余三个边框的颜色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width:10px; </span><br><span class="line">  height:10px; </span><br><span class="line">  border:10px solid; </span><br><span class="line">  border-color:#ff3300 #ffffff #ffffff #ffffff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下图（截自Firefox3.5）：</p>
<h2 id="从梯形到三角"><a href="#从梯形到三角" class="headerlink" title="从梯形到三角"></a>从梯形到三角</h2><p>上面的是梯形，我要想得到一个三角图案该怎么办呢？显然，很简单，把div的高宽都变成0，只留一边，不就是三角了吗？如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border: 10px solid; </span><br><span class="line">  border-color: #ff3300 #ffffff #ffffff #ffffff;&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下（依旧截图自Firefox3.5）：</p>
<h2 id="从等腰直角三角形到普通等腰三角"><a href="#从等腰直角三角形到普通等腰三角" class="headerlink" title="从等腰直角三角形到普通等腰三角"></a>从等腰直角三角形到普通等腰三角</h2><p>上图为等腰直角三角形，之所以为等腰直角，是因为所有的边框宽度是一样的，如果我们将边框宽度设置为不同，那会怎样？则会形成等腰三角形。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border-width: 20px 10px; </span><br><span class="line">  border-style: solid; </span><br><span class="line">  border-color: #ff3300 #ffffff #ffffff #ffffff;&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果如下图：</p>
<h2 id="从等腰到不等腰"><a href="#从等腰到不等腰" class="headerlink" title="从等腰到不等腰"></a>从等腰到不等腰</h2><p>我们可以不局限于保留一条边框，我们可以保留两条，于是我们可以告别等腰，得到更加锐利的三角，正如一开始所展示的那个三角：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border-width: 20px 10px; </span><br><span class="line">  border-style: solid; </span><br><span class="line">  border-color: #ff3300 #ff3300 #ffffff #ffffff;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际的应用"><a href="#实际的应用" class="headerlink" title="实际的应用"></a>实际的应用</h2><p>关于应用，不多说，直接看图：<br>说明：<br>以上的测试代码纯粹为了说明原理，所以使用#ffffff白色边框，通过于背景融合来隐藏边框。在实际的操作中，应该使用transparent透明属性，例如border-color:#ff3300 #ff3300 transparent transparent;，这同样会有问题，IE6浏览器不支持transparent透明属性，不过没有关系，就border生成三角技术而言，直接设置对应的透明边框的border-style属性为dotted或是dashed即可解决这一问题，为什么使用dotted和dashed可以修复此问题呢？您有兴趣可以参见默尘的这篇文章Dotted&amp;Dashed终极分析及IE6透明边框。</p>
<h1 id="CSS-border圆角生成技术简介"><a href="#CSS-border圆角生成技术简介" class="headerlink" title="CSS border圆角生成技术简介"></a>CSS border圆角生成技术简介</h1><h2 id="我看圆角"><a href="#我看圆角" class="headerlink" title="我看圆角"></a>我看圆角</h2><p>一提到圆角，我脑中闪过的词就是“定位”，“嵌套”，“模拟”，“渐进增强”，“滥用”。</p>
<ul>
<li>定位，也就是切四个角上下左右定位，这是淘宝首页的做法，但是面对IE6的奇偶bug只能当作看客；</li>
<li>使用“嵌套”则不会有此问题，“嵌套”分图片背景嵌套和CSS边框嵌套，使用图片嵌套则图片的重用性，大小优化有待加强，边框嵌套则技术实现上有些难度；</li>
<li>或使用“渐进增强”，CSS3 border-radius属性，而不要去鸟IE这类自我感觉良好的浏览器；</li>
<li>或是学习Google使用CSS模拟，而一般的CSS模拟都是使用左右边框+背景色的方式1像素1像素的拼合成的。这类方法各有优缺点，需根据实际情况采用。对于满眼圆角的设计图我是很不喜欢的，该用则用，切勿为了圆角而圆角。</li>
</ul>
<h2 id="border圆角图案生成法"><a href="#border圆角图案生成法" class="headerlink" title="border圆角图案生成法"></a>border圆角图案生成法</h2><p>这里介绍的实现圆角的得到与上面提到的都是不一样的，虽然也属于CSS模拟的范畴，但是其高效的程度确实相当惊人的，可谓最佳实践之一。<br>我们先看看效果，见下图，截自Firefox3.6：<br>上述效果的实现仅仅使用了三个标签，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; html 代码</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;top&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;center&quot;&gt;我是一只小小鸟、小小鸟！&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bot&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; css 代码</span><br><span class="line">.box&#123;</span><br><span class="line">  width:500px;</span><br><span class="line">&#125;</span><br><span class="line">.top&#123;</span><br><span class="line">  border-bottom:3px solid; </span><br><span class="line">  border-top-color:#cc0000; </span><br><span class="line">  border-bottom-color:#cc0000; </span><br><span class="line">  border-left:3px dotted transparent; </span><br><span class="line">  border-right:3px dotted transparent;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">  padding:10px 20px; </span><br><span class="line">  color:white; </span><br><span class="line">  font-size:14px; </span><br><span class="line">  background:#cc0000;</span><br><span class="line">&#125;</span><br><span class="line">.bot&#123;</span><br><span class="line">  border-top:3px solid; </span><br><span class="line">  border-top-color:#cc0000; </span><br><span class="line">  border-bottom-color:#cccccc; </span><br><span class="line">  border-left:3px dotted transparent; </span><br><span class="line">  border-right:3px dotted transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看这段代码在IE6下的效果：</p>
<p>这里的高效在于，仅仅使用了一层标签就模拟了3像素的圆角，按照曾经我对CSS圆角模拟的理解，模拟1像素的圆角需要一层标签(background+borderLeft+borderRight)，两像素的需要两层标签，三像素的需要三层标签。</p>
<p>有点神奇，但是就像看刘谦的魔术一样，说穿了也就那么回事，其实这里的圆角模拟在本文的上面已经展示了，就是这样图片：</p>
<p>您可能会疑问，是不是搞错图片啦，这显然不是一个模样的，非也非也，就本质上而言，圆角的实现与上面的梯形图就是同样的东西。现在，盯着上面这张图，我们想象一下，用力的想象，用想花姑娘的那番劲头想象——上面的梯形宽度越来越宽（不是拉伸），一直宽到500像素，是不是与上面实现的圆角的下边缘一致啊？</p>
<p>也就是说，那个含有“我是一只小小鸟……”文字的圆角图形是有一个上梯形+矩形+下梯形组成的。参见下面的分离效果图：<br>您可以狠狠地点击这里：CSS border圆角生成demo</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>人无完人，金无足赤，此方法虽然简洁高效，兼容性上佳，但是依然有局限性，在实现实色背景的圆角效果时，此方法可谓首选；如果是纯粹的圆角边框，此方法也可以实现，需要用到边框重叠，但是标签数几乎要翻倍，其权衡效用将大打折扣，反不如其他圆角方法来的实在。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果在web制作中，需要用的一些直接可以使用CSS+单标签模拟的图片，我的建议是“毫不犹豫使用CSS模拟”，例如实色的三角，或是实现实色的圆角效果，这可以说是最高效，最利于扩展维护的前端实现方法了。我们需要开阔的思维，而不要仅仅局限于眼前的技术，武侠中所谓的“无招胜有招”还是有着一定的哲学道理的，长远来看，意识与海纳百川的心态比当下的一点技术更来得重要。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>国内配置Electron开发环境的正确方式【转载】</title>
    <url>/2020/04/07/Electron-Offline-Build/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做electron相关开发，疲于网络环境的种种限制，找遍了互联网相关资料，终于找到一篇比较全面的文章，怕丢了转过来。</p>
<span id="more"></span>
<p><a href="https://blog.yasking.org/a/zh-install-electron-development-2020.html">转载</a></p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>客户端技术</category>
      </categories>
      <tags>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>es6中箭头函数没了arguments怎么办？</title>
    <url>/2020/01/22/Es6-arrowFunc-arguments/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>es6中，arguments被取消掉了，但是函数还是会有参数不确定的时候，那么我们该怎么办呢，接下来将介绍一下如何在es6中完成arguments一样的效果。</p>
<a id="more"></a>

<h2 id="剩余运算符"><a href="#剩余运算符" class="headerlink" title="剩余运算符"></a>剩余运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rest)</span><br><span class="line">  <span class="comment">//[1,2,3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>看上面的代码，有的朋友会问，这<code>...</code>的操作不应该是展开运算符么？是的，扩展运算符与剩余操作符都是以三点开头的操作符，二者长的很像，只是在用法上有些差别。它们已经被 ES6 数组支持，能解决很多之前 arguments 解决起来很麻烦的问题。</p>
<p>简单来说剩余运算是在参数上使用的。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见操作 ---- 去重、扁平、取最大最小值</title>
    <url>/2020/01/05/FE-guide-ArrayOprs/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="1-利用-Object-的-Key-唯一特性"><a href="#1-利用-Object-的-Key-唯一特性" class="headerlink" title="1. 利用 Object 的 Key 唯一特性"></a>1. 利用 <code>Object</code> 的 <code>Key</code> 唯一特性</h2><p>开辟一个外部存储空间用于标示元素是否出现过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">    var container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-利用-indexOf-的返回值数值进行去重"><a href="#2-利用-indexOf-的返回值数值进行去重" class="headerlink" title="2. 利用 indexOf 的返回值数值进行去重"></a>2. 利用 <code>indexOf</code> 的返回值数值进行去重</h2><p>原理是 <code>indexOf</code> 获取元素时如果返回值不等于下标说明已经有了，配合 <code>filter</code> 更美味</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; arr.filter((e,i) &#x3D;&gt; </span><br><span class="line">  arr.indexOf(e) &#x3D;&#x3D;&#x3D; i &#x2F;&#x2F; 如果元素找到的当前下标和当前索引相同说明是同一个，不同说明不是唯一</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>还有一种变形方法利用 <code>lastIndexOf</code> 方法</p>
<blockquote>
<p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const filterNonUnique &#x3D; arr &#x3D;&gt; arr.filter(e &#x3D;&gt; </span><br><span class="line">  arr.indexOf(e) &#x3D;&#x3D;&#x3D; arr.lastIndexOf(e) &#x2F;&#x2F; 判断一个元素出现时的第一次下标和最后一次下标是否相同，如果相同那么就唯一</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="3-利用-Set-特性去重"><a href="#3-利用-Set-特性去重" class="headerlink" title="3. 利用 Set 特性去重"></a>3. 利用 <code>Set</code> 特性去重</h2><p><code>Set</code> 是 <code>ES6</code> 中新的数据类型，它的特点就是元素唯一性，且可以和数组进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; Array.from(new Set(arr)); &#x2F;&#x2F; Array.from 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 优化</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; [...new Set(arr)]; &#x2F;&#x2F; 利用 &#96;ES6&#96; 中展开操作</span><br></pre></td></tr></table></figure>
<h2 id="4-排序后判断前后两项是否相等去重"><a href="#4-排序后判断前后两项是否相等去重" class="headerlink" title="4. 排序后判断前后两项是否相等去重"></a>4. 排序后判断前后两项是否相等去重</h2><p>通过比较相邻数字是否重复，将排序后的数组进行去重。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  array.sort((a, b) &#x3D;&gt; a - b);</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  const result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (!i || array[i] !&#x3D; array[pre]) &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pre &#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h1><h2 id="1-普通方法"><a href="#1-普通方法" class="headerlink" title="1. 普通方法"></a>1. 普通方法</h2><p>通过递归的方式判断数组中的项是否是数组，如果不是就加入到新的扁平数组，如果是就递归调用逐层判断，直到全部结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const flatten &#x3D; (array) &#x3D;&gt; &#123; &#x2F;&#x2F; array 原数组</span><br><span class="line">  let result &#x3D; []; &#x2F;&#x2F; 定义新的扁平数组</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(array[i])) &#123; &#x2F;&#x2F; 判断子元素是否是数组</span><br><span class="line">      result &#x3D; result.concat(flatten(array[i])); &#x2F;&#x2F; 递归判断</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(array[i]); &#x2F;&#x2F; 加入新数组</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用reduce简化上述方法"><a href="#2-使用reduce简化上述方法" class="headerlink" title="2. 使用reduce简化上述方法"></a>2. 使用reduce简化上述方法</h2><blockquote>
<p>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。<br>reducer 函数接收4个参数:</p>
</blockquote>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
<li>您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<p>先看一段 reduce 的示例函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [1, 2, 3, 4];</span><br><span class="line">const reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; &#x2F;&#x2F; 定义一个累计器函数，作用是将数组前后累计值与当前值累加</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer)); &#x2F;&#x2F; 没有初始值用第一个元素</span><br><span class="line">&#x2F;&#x2F; expected output: 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer, 5)); &#x2F;&#x2F; 有初始值从初始值开始</span><br><span class="line">&#x2F;&#x2F; expected output: 15</span><br></pre></td></tr></table></figure>
<p>这下大家应该对 reduce 函数认识了，接下来看看怎么简化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function flatten(array) &#123;</span><br><span class="line">  return array.reduce((newArray, current) &#x3D;&gt; &#x2F;&#x2F; 新数组，当前项</span><br><span class="line">    Array.isArray(current) ? &#x2F;&#x2F; 判断当前项是否为数组</span><br><span class="line">      newArray.concat(flatten(current)) : &#x2F;&#x2F; 是的话 递归调用</span><br><span class="line">      newArray.concat(current) &#x2F;&#x2F; 不是的话加进新数组</span><br><span class="line">  , []) &#x2F;&#x2F; 初始化新数组为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们再变一个形，增加一个变量，变成可指定深度操作数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function flattenByDeep(array, deep &#x3D; 1) &#123; &#x2F;&#x2F; 默认一层</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) &amp;&amp; deep &gt; 1 ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - 1)) : &#x2F;&#x2F; 下一次减一层</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h1><h2 id="利用-reduce"><a href="#利用-reduce" class="headerlink" title="利用 reduce"></a>利用 <code>reduce</code></h2><p><code>reduce</code> 函数真的是超级好用，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n))</span><br></pre></td></tr></table></figure>

<h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h2><p><code>Math.max</code> 参数原本是一组数字，只需要让他可以接收数组即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null,array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Generator 生成器</title>
    <url>/2020/01/03/FE-guide-Generator/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a><code>Generator</code> 实现</h1><p><code>Generator</code> 是 <code>ES6</code> 中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 * 表示这是一个 Generator 函数</span><br><span class="line">&#x2F;&#x2F; 内部可以通过 yield 暂停代码</span><br><span class="line">&#x2F;&#x2F; 通过调用 next 恢复执行</span><br><span class="line">function* test() &#123;</span><br><span class="line">  let a &#x3D; 1 + 2;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; test();</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cb 也就是编译过的 test 函数</span><br><span class="line">function generator(cb) &#123;</span><br><span class="line">  return (function() &#123;</span><br><span class="line">    var object &#x3D; &#123;</span><br><span class="line">      next: 0,</span><br><span class="line">      stop: function() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      next: function() &#123;</span><br><span class="line">        var ret &#x3D; cb(object);</span><br><span class="line">        if (ret &#x3D;&#x3D;&#x3D; undefined) return &#123; value: undefined, done: true &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: false</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果你使用 babel 编译后可以发现 test 函数变成了这样</span><br><span class="line">function test() &#123;</span><br><span class="line">  var a;</span><br><span class="line">  return generator(function(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch ((_context.prev &#x3D; _context.next)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可以发现通过 yield 将代码分割成几块</span><br><span class="line">        &#x2F;&#x2F; 每次执行 next 函数就执行一块代码</span><br><span class="line">        &#x2F;&#x2F; 并且表明下次需要执行哪块代码</span><br><span class="line">        case 0:</span><br><span class="line">          a &#x3D; 1 + 2;</span><br><span class="line">          _context.next &#x3D; 4;</span><br><span class="line">          return 2;</span><br><span class="line">        case 4:</span><br><span class="line">          _context.next &#x3D; 6;</span><br><span class="line">          return 3;</span><br><span class="line">		&#x2F;&#x2F; 执行完毕</span><br><span class="line">        case 6:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Map、FlatMap 和 Reduce</title>
    <url>/2020/01/03/FE-guide-Map-FlatMap-Reduce/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">[1, 2, 3].map((v) &#x3D;&gt; v + 1) &#x2F;&#x2F; -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><code>Map</code> 有三个参数，分别是<strong><em>当前索引元素</em></strong>，<strong><em>索引</em></strong>，<strong><em>原数组</em></strong></p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a><code>FlatMap</code></h2><p><code>FlatMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlatMap</code> 看成是 <code>map + flatten</code> ，目前该函数在浏览器中还不支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">[1, [2], 3].flatMap((v) &#x3D;&gt; v + 1) &#x2F;&#x2F; -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>如果想将一个多维数组彻底的降维，可以这样实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flattenDeep &#x3D; (arr) &#x3D;&gt; Array.isArray(arr)</span><br><span class="line">  ? arr.reduce( (a, b) &#x3D;&gt; [...a, ...flattenDeep(b)] , [])</span><br><span class="line">  : [arr]</span><br><span class="line"></span><br><span class="line">flattenDeep([1, [[2], [3, [4]], 5]])</span><br></pre></td></tr></table></figure>

<h2 id="Reduce-升序执行"><a href="#Reduce-升序执行" class="headerlink" title="Reduce 升序执行"></a>Reduce 升序执行</h2><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值<br><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的 <code>reducer</code> 函数(升序执行)，将其结果汇总为单个返回值。</p>
<p><code>reducer</code> 函数接收4个参数:</p>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)<br>您的 <code>reducer</code> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[a, b].reduce((a, b) &#x3D;&gt; a(b()))</span><br><span class="line">&#x2F;&#x2F; -&gt; 2 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 模块化</title>
    <url>/2020/01/03/FE-guide-Module/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code> 的模块化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; file a.js</span><br><span class="line">export function a() &#123;&#125;</span><br><span class="line">export function b() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; file b.js</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">import &#123;a, b&#125; from &#39;.&#x2F;a.js&#39;</span><br><span class="line">import XXX from &#39;.&#x2F;b.js&#39;</span><br></pre></td></tr></table></figure>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><code>CommonJS</code></h2><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code> 解析了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">exports.a &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">var module &#x3D; require(&#39;.&#x2F;a.js&#39;)</span><br><span class="line">module.a &#x2F;&#x2F; -&gt; log 1</span><br></pre></td></tr></table></figure>
<p>在上述代码中， <code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var module &#x3D; require(&#39;.&#x2F;a.js&#39;)</span><br><span class="line">module.a</span><br><span class="line">&#x2F;&#x2F; 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span><br><span class="line">&#x2F;&#x2F; 重要的是 module 这里，module 是 Node 独有的一个变量</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 基本实现</span><br><span class="line">var module &#x3D; &#123;</span><br><span class="line">  exports: &#123;&#125; &#x2F;&#x2F; exports 就是个空对象</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这个是为什么 exports 和 module.exports 用法相似的原因</span><br><span class="line">var exports &#x3D; module.exports</span><br><span class="line">var load &#x3D; function (module) &#123;</span><br><span class="line">    &#x2F;&#x2F; 导出的东西</span><br><span class="line">    var a &#x3D; 1</span><br><span class="line">    module.exports &#x3D; a</span><br><span class="line">    return module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来说说 module.exports 和 exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。</p>
<p>对于 CommonJS 和 ES6 中的模块化的两者区别是：</p>
<ul>
<li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</li>
<li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执行的</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 是由 <code>RequireJS</code> 提出的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AMD</span><br><span class="line">define([&#39;.&#x2F;a&#39;, &#39;.&#x2F;b&#39;], function(a, b) &#123;</span><br><span class="line">    a.do()</span><br><span class="line">    b.do()</span><br><span class="line">&#125;)</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a &#x3D; require(&#39;.&#x2F;a&#39;)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    var b &#x3D; require(&#39;.&#x2F;b&#39;)</span><br><span class="line">    b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Promise</title>
    <url>/2020/01/03/FE-guide-Promise/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a><code>Promise</code> 实现</h1><p><code>Promise</code> 是 <code>ES6</code> 新增的语法，解决了回调地狱的问题。</p>
<p>可以把 <code>Promise</code> 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，<strong><em>状态一旦改变就不能再次变化</em></strong>。</p>
<p><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。</p>
<p>对于 <code>then</code> 来说，本质上可以把它看成是 <code>flatMap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三种状态</span><br><span class="line">const PENDING &#x3D; &quot;pending&quot;;</span><br><span class="line">const RESOLVED &#x3D; &quot;resolved&quot;;</span><br><span class="line">const REJECTED &#x3D; &quot;rejected&quot;;</span><br><span class="line">&#x2F;&#x2F; promise 接收一个函数参数，该函数会立即执行</span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  let _this &#x3D; this;</span><br><span class="line">  _this.currentState &#x3D; PENDING;</span><br><span class="line">  _this.value &#x3D; undefined;</span><br><span class="line">  &#x2F;&#x2F; 用于保存 then 中的回调，只有当 promise</span><br><span class="line">  &#x2F;&#x2F; 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span><br><span class="line">  _this.resolvedCallbacks &#x3D; [];</span><br><span class="line">  _this.rejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">  _this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 value 是个 Promise，递归执行</span><br><span class="line">      return value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 异步执行，保证执行顺序</span><br><span class="line">      if (_this.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        _this.currentState &#x3D; RESOLVED;</span><br><span class="line">        _this.value &#x3D; value;</span><br><span class="line">        _this.resolvedCallbacks.forEach(cb &#x3D;&gt; cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  _this.reject &#x3D; function (reason) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 异步执行，保证执行顺序</span><br><span class="line">      if (_this.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        _this.currentState &#x3D; REJECTED;</span><br><span class="line">        _this.value &#x3D; reason;</span><br><span class="line">        _this.rejectedCallbacks.forEach(cb &#x3D;&gt; cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 用于解决以下问题</span><br><span class="line">  &#x2F;&#x2F; new Promise(() &#x3D;&gt; throw Error(&#39;error))</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(_this.resolve, _this.reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    _this.reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then &#x3D; function (onResolved, onRejected) &#123;</span><br><span class="line">  var self &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.2.7，then 必须返回一个新的 promise</span><br><span class="line">  var promise2;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.2.onResolved 和 onRejected 都为可选参数</span><br><span class="line">  &#x2F;&#x2F; 如果类型不是函数需要忽略，同时也实现了透传</span><br><span class="line">  &#x2F;&#x2F; Promise.resolve(4).then().then((value) &#x3D;&gt; console.log(value))</span><br><span class="line">  onResolved &#x3D; typeof onResolved &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onResolved : v &#x3D;&gt; v;</span><br><span class="line">  onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : r &#x3D;&gt; throw r;</span><br><span class="line"></span><br><span class="line">  if (self.currentState &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">    return (promise2 &#x3D; new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">      &#x2F;&#x2F; 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span><br><span class="line">      &#x2F;&#x2F; 所以用了 setTimeout 包裹下</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.currentState &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">    return (promise2 &#x3D; new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 异步执行onRejected</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">    return (promise2 &#x3D; new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">      self.resolvedCallbacks.push(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑到可能会有报错，所以使用 try&#x2F;catch 包裹</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      self.rejectedCallbacks.push(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 规范 2.3</span><br><span class="line">function resolutionProcedure(promise2, x, resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span><br><span class="line">  if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;</span><br><span class="line">    return reject(new TypeError(&quot;Error&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.2</span><br><span class="line">  &#x2F;&#x2F; 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span><br><span class="line">  if (x instanceof MyPromise) &#123;</span><br><span class="line">    if (x.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      x.then(function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 再次调用该函数是为了确认 x resolve 的</span><br><span class="line">        &#x2F;&#x2F; 参数是什么类型，如果是基本类型就再次 resolve</span><br><span class="line">        &#x2F;&#x2F; 把值传给下个 then</span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.3.3.3</span><br><span class="line">  &#x2F;&#x2F; reject 或者 resolve 其中一个执行过得话，忽略其他的</span><br><span class="line">  let called &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.3，判断 x 是否为对象或者函数</span><br><span class="line">  if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof x &#x3D;&#x3D;&#x3D; &quot;function&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 规范 2.3.3.2，如果不能取出 then，就 reject</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 规范 2.3.3.1</span><br><span class="line">      let then &#x3D; x.then;</span><br><span class="line">      &#x2F;&#x2F; 如果 then 是函数，调用 x.then</span><br><span class="line">      if (typeof then &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 规范 2.3.3.3</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          y &#x3D;&gt; &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 规范 2.3.3.3.1</span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          e &#x3D;&gt; &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 规范 2.3.3.4</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (called) return;</span><br><span class="line">      called &#x3D; true;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 规范 2.3.4，x 为基本类型</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是根据 <code>Promise / A+</code> 规范来实现的代码，可以通过 <code>promises-aplus-tests</code> 的完整测试</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 网络</title>
    <url>/2020/01/09/FE-guide-Net/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络相关的知识虽然平时在编码阶段很少遇到，但是并不是说它不重要，尤其是前端优化层面，能从网络传输过程优化的点有很多，所以，我们需要好好掌握网络相关的知识，接下来，我将会将我了解到的网络相关的知识点进行一一整理</p>
<h1 id="UDP-User-Datagram-Protocol-用户数据报协议"><a href="#UDP-User-Datagram-Protocol-用户数据报协议" class="headerlink" title="UDP - User Datagram Protocol - 用户数据报协议"></a>UDP - User Datagram Protocol - 用户数据报协议</h1><h2 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h2><p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p>
<p>具体来说</p>
<ul>
<li>在<strong>发送端</strong>，应用层将数据传递给传输层的 <code>UDP</code> 协议， <code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了</li>
<li>在<strong>接收端</strong>，网络层将数据传递给传输层， <code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<h2 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h2><ol>
<li><code>UDP</code> 是无连接的，也就是说通信不需要建立和断开连接。</li>
<li><code>UDP</code> 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li>
<li><code>UDP</code> 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 <code>UDP</code> 而不是 <code>TCP</code> 。</li>
</ol>
<h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>因为 <code>UDP</code> 没有 <code>TCP</code> 那么复杂，需要保证数据不丢失且有序到达。所以 <code>UDP</code> 的头部开销小，只有八字节，相比 <code>TCP</code> 的至少二十字节要少得多，在传输数据报文时是很高效的。</p>
<p>头部包含了以下几个数据</p>
<ul>
<li>两个十六位的端口号，分别为<strong>源端口</strong>（可选字段）和<strong>目标端口</strong></li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（ <code>IPv4</code> 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <code>UDP</code> 提供了单播，多播，广播的功能。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>TCP 头部比 UDP 头部复杂的多</p>
<p>对于 TCP 头部来说，以下几个字段是很重要的</p>
<ul>
<li><code>Sequence number</code>（序号），它保证了 <code>TCP</code> 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li>
<li><code>Acknowledgement Number</code>（确认编号），它表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li>
<li><code>Window Size</code>（窗口大小），它表示还能接收多少字节的数据，用于流量控制</li>
<li>标识符<ul>
<li><code>URG=1</code>：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li>
<li><code>ACK=1</code>：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li>
<li><code>PSH=1</code>：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li>
<li><code>RST=1</code>：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li>
<li><code>SYN=1</code>：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li>
<li><code>FIN=1</code>：该字段为一表示此报文段是一个释放连接的请求报文。</li>
</ul>
</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p><code>HTTP</code> 是无连接的，所以作为下层的 <code>TCP</code> 协议也是无连接的，虽然看似 <code>TCP</code> 将两端连接了起来，但是其实只是两端共同维护了一个状态</p>
<p><code>TCP</code> 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。<br>在这之前需要了解一个重要的性能指标 <code>RTT</code> 。该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p>
<h3 id="建立连接三次握手"><a href="#建立连接三次握手" class="headerlink" title="建立连接三次握手"></a>建立连接三次握手</h3><p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。</p>
<p>起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。</p>
<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p>
<h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。</p>
<p><strong><em>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</em></strong></p>
<p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p>
<p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p>
<p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p>
<h3 id="断开链接四次握手"><a href="#断开链接四次握手" class="headerlink" title="断开链接四次握手"></a>断开链接四次握手</h3><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p>
<h4 id="第一次握手-1"><a href="#第一次握手-1" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p>
<h4 id="第二次握手-1"><a href="#第二次握手-1" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p>
<h4 id="第三次握手-1"><a href="#第三次握手-1" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p>
<p>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p>
<h4 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h4><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
<p><strong><em>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</em></strong></p>
<p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ</p>
<h4 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h4><h4 id="正常传输过程"><a href="#正常传输过程" class="headerlink" title="正常传输过程"></a>正常传输过程</h4><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p>
<h4 id="报文丢失或出错"><a href="#报文丢失或出错" class="headerlink" title="报文丢失或出错"></a>报文丢失或出错</h4><p>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p>
<p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。</p>
<p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p>
<h4 id="ACK-超时或丢失"><a href="#ACK-超时或丢失" class="headerlink" title="ACK 超时或丢失"></a>ACK 超时或丢失</h4><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p>
<p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p>
<p><strong><em>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</em></strong></p>
<h4 id="连续-ARQ"><a href="#连续-ARQ" class="headerlink" title="连续 ARQ"></a>连续 ARQ</h4><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p>
<h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</p>
<p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>在上面小节中讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p>
<p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p>
<p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p>
<p>当发送端接收到应答报文后，会随之将窗口进行滑动</p>
<p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p>
<h4 id="Zero-窗口"><a href="#Zero-窗口" class="headerlink" title="Zero 窗口"></a>Zero 窗口</h4><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p>
<h3 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p>
<p>拥塞处理包括了四个算法，分别为：<strong>慢开始</strong>，<strong>拥塞避免</strong>，<strong>快速重传</strong>，<strong>快速恢复</strong>。</p>
<h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p>
<p>慢开始算法步骤具体如下</p>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li>
<li>每过一个 RTT 就将窗口大小乘二</li>
<li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li>
</ol>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p>
<p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>启动拥塞避免算法</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p>
<h4 id="TCP-Taho-实现如下"><a href="#TCP-Taho-实现如下" class="headerlink" title="TCP Taho 实现如下"></a>TCP Taho 实现如下</h4><ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>重新开始慢开始算法</li>
</ul>
<h4 id="TCP-Reno-实现如下"><a href="#TCP-Reno-实现如下" class="headerlink" title="TCP Reno 实现如下"></a>TCP Reno 实现如下</h4><ul>
<li>拥塞窗口减半</li>
<li>将阈值设为当前拥塞窗口</li>
<li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li>
<li>使用拥塞避免算法</li>
</ul>
<h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p>
<p>在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p>
<p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 协议是个无状态协议，不会保存状态。</p>
<h2 id="Post-和-Get-的区别"><a href="#Post-和-Get-的区别" class="headerlink" title="Post 和 Get 的区别"></a><code>Post</code> 和 <code>Get</code> 的区别</h2><p>先引入<code>副作用</code>和<code>幂等</code>的概念。</p>
<blockquote>
<p><strong><em>副作用</em></strong>指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p>
</blockquote>
<blockquote>
<p><strong>幂等</strong>指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。</p>
</blockquote>
<p>在规范的应用场景上说， <code>Get</code> 多用于无副作用，幂等的场景，例如搜索关键字。 <code>Post</code> 多用于副作用，不幂等的场景，例如注册。</p>
<p>在技术上说：</p>
<ul>
<li>Get 请求能缓存，Post 不能</li>
<li>Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li>
<li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li>
<li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li>
<li>Post 支持更多的编码类型且不对数据类型限制</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>204 No content，表示请求成功，但响应报文不含实体的主体部分<br>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容<br>206 Partial Content，进行范围请求</p>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</p>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>500 internal sever error，表示服务器端在执行请求时发生了错误<br>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能<br>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>
<h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><table>
<thead>
<tr>
<th>通用字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>浏览器想要优先使用的连接类型，比如 keep-alive</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器相关信息</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求客户端升级协议</td>
</tr>
<tr>
<td>Warning</td>
<td>在内容中可能存在错误</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>请求字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>能正确接收的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>能正确接收的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>能正确接收的编码格式列表</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>能正确接收的语言列表</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务端的指定行为</td>
</tr>
<tr>
<td>From</td>
<td>请求方邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>服务器的域名</td>
</tr>
<tr>
<td>If-Match</td>
<td>两端资源标记比较</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>本地资源未修改返回 304（比较时间）</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>本地资源未修改返回 304（比较标记）</td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端信息</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制可被代理及网关转发的次数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>向代理服务器发送验证信息</td>
</tr>
<tr>
<td>Range</td>
<td>请求某个内容的一部分</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码方式</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>响应字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否支持某些种类的范围</td>
</tr>
<tr>
<td>Age</td>
<td>资源在代理缓存中存在的时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源标识</td>
</tr>
<tr>
<td>Location</td>
<td>客户端重定向到某个 URL</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>向代理服务器发送验证信息</td>
</tr>
<tr>
<td>Server</td>
<td>服务器名字</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>获取资源需要的验证信息</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>实体字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源的正确请求方式</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>内容的编码格式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>内容使用的语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>request body 长度</td>
</tr>
<tr>
<td>Content-Location</td>
<td>返回数据的备用地址</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>Base64加密格式的内容 MD5检验值</td>
</tr>
<tr>
<td>Content-Range</td>
<td>内容的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>内容的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>内容的过期时间</td>
</tr>
<tr>
<td>Last_modified</td>
<td>内容的最后修改时间</td>
</tr>
</tbody></table>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><code>HTTPS</code> 还是通过了 <code>HTTP</code> 来传输信息，但是信息通过 <code>TLS</code> 协议进行了加密。</p>
<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p><code>TLS</code> 协议位于传输层之上，应用层之下。首次进行 <code>TLS</code> 协议传输需要两个 <code>RTT</code> ，接下来可以通过 <code>Session Resumption</code> 减少到一个 <code>RTT</code> 。</p>
<p>在 <code>TLS</code> 中使用了两种加密技术，分别为：<strong><em>对称加密</em></strong>和<strong><em>非对称加密</em></strong>。</p>
<p><strong>对称加密：</strong><br>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p>
<p><strong>非对称加密：</strong><br>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p>
<p><strong>TLS 握手过程如下图：</strong></p>
<ol>
<li>客户端发送一个随机值，需要的协议和加密方式</li>
<li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li>
<li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li>
<li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li>
</ol>
<p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p>
<p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p>
<h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p>
<p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p>
<p>你可以通过 该链接 感受下 HTTP 2.0 比 HTTP 1.X 到底快了多少。</p>
<p>在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的<br><img src="https://s2.ax1x.com/2020/01/09/lWJGkt.png" alt="lWJGkt.png"><br>在 HTTP 2.0 中，因为引入了多路复用，你会发现请求是这样的<br><img src="https://s2.ax1x.com/2020/01/09/lWJa6g.png" alt="lWJa6g.png"></p>
<h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是<strong>帧（frame）</strong>和<strong>流（stream）</strong>。<br>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<h2 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h2><p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p>
<p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p>
<h2 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h2><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。</p>
<ul>
<li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制</li>
<li>实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了</li>
<li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul>
<li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li>
<li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了</li>
</ul>
</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS 的作用就是通过域名查询到具体的 IP。</p>
<p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p>
<p>在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 时，会进行一下操作：</p>
<ol>
<li>操作系统会首先在本地缓存中查询</li>
<li>没有的话会去系统配置的 DNS 服务器中查询</li>
<li>如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li>
<li>然后去该服务器查询 google 这个二级域名</li>
<li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li>
</ol>
<p>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p>
<p>PS：DNS 是基于 UDP 做的查询。</p>
<h2 id="从输入-URL-到页面加载完成的过程"><a href="#从输入-URL-到页面加载完成的过程" class="headerlink" title="从输入 URL 到页面加载完成的过程"></a>从输入 URL 到页面加载完成的过程</h2><p>这是一个很经典的面试题，在这题中可以将本文讲得内容都串联起来。</p>
<ol>
<li>首先做 <code>DNS</code> 查询，如果这一步做了智能 <code>DNS</code> 解析的话，会提供访问速度最快的 <code>IP</code> 地址回来</li>
<li>接下来是 <code>TCP</code> 握手，应用层会下发数据给传输层，这里 <code>TCP</code> 协议会指明两端的端口号，然后下发给网络层。网络层中的 <code>IP</code> 协议会确定 <code>IP</code> 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li>
<li><code>TCP</code> 握手结束后会进行 <code>TLS</code> 握手，然后就开始正式的传输数据</li>
<li>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 <code>HTML</code> 文件</li>
<li>首先浏览器会判断状态码是什么，如果是 <code>200</code> 那就继续解析，如果 <code>400</code> 或 <code>500</code> 的话就会报错，如果 <code>300</code> 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li>
<li>浏览器开始解析文件，如果是 <code>gzip</code> 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</li>
<li>文件解码成功后会正式开始渲染流程，先会根据 <code>HTML</code> 构建 <code>DOM</code> 树，有 <code>CSS</code> 的话会去构建 <code>CSSOM</code> 树。如果遇到 <code>script</code> 标签的话，会判断是否存在 <code>async</code> 或者 <code>defer</code> ，前者会并行进行下载并执行 <code>JS</code> ，后者会先下载文件，然后等待 <code>HTML</code> 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 <code>JS</code> 执行完毕。遇到文件下载的会去下载文件，这里如果使用 <code>HTTP 2.0</code> 协议的话会极大的提高多图的下载效率。</li>
<li>初始的 <code>HTML</code> 被完全加载和解析后会触发 <code>DOMContentLoaded</code> 事件</li>
<li><code>CSSOM</code> 树和 <code>DOM</code> 树构建完成后会开始生成 <code>Render</code> 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li>
<li>在生成 <code>Render</code> 树的过程中，浏览器就开始调用 <code>GPU</code> 绘制，合成图层，将内容显示在屏幕上了</li>
</ol>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Proxy</title>
    <url>/2020/01/03/FE-guide-async-Proxy/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code> 是 <code>ES6</code> 中新增的功能，可以用来自定义对象中的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let p &#x3D; new Proxy(target, handler);</span><br><span class="line">&#x2F;&#x2F; &#96;target&#96; 代表需要添加代理的对象</span><br><span class="line">&#x2F;&#x2F; &#96;handler&#96; 用来自定义对象中的操作</span><br></pre></td></tr></table></figure>
<p>可以很方便的使用 <code>Proxy</code> 来实现一个数据绑定和监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let onWatch &#x3D; (obj, setBind, getLogger) &#x3D;&gt; &#123;</span><br><span class="line">  let handler &#x3D; &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value);</span><br><span class="line">      return Reflect.set(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  return new Proxy(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123; a: 1 &#125;</span><br><span class="line">let value</span><br><span class="line">let p &#x3D; onWatch(obj, (v) &#x3D;&gt; &#123;</span><br><span class="line">  value &#x3D; v</span><br><span class="line">&#125;, (target, property) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;Get &#39;$&#123;property&#125;&#39; &#x3D; $&#123;target[property]&#125;&#96;);</span><br><span class="line">&#125;)</span><br><span class="line">p.a &#x3D; 2 &#x2F;&#x2F; bind &#96;value&#96; to &#96;2&#96;</span><br><span class="line">p.a &#x2F;&#x2F; -&gt; Get &#39;a&#39; &#x3D; 2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce函数的妙用 ---- 实现map和filter</title>
    <url>/2020/01/05/FE-guide-about-reduce/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看了好多技术文章，好多的代码片段，突然发现好多的代码里都有 <code>reduce</code> ，感觉以前都没怎么关注过这个函数，为了弥补这个过失，打算专门写一篇文章说说它。</p>
<p><code>reduce</code> 函数在 MDN 中是这样介绍的</p>
<blockquote>
<p>reduce() 方法对数组中的<strong><em>每个元素</em></strong>执行一个由 <strong><em>您</em></strong> 提供的 <code>reducer</code> 函数(<strong><em>升序执行</em></strong>)，将其结果汇总为单个返回值。</p>
</blockquote>
<p>说实话看了一脸懵逼，这上面说的叫人话？后来耐着性子看了一些代码后感觉有所理解，如果理解不对，还请斧正。<br>首先看一下这里面几个关键词</p>
<p><strong>* 每个元素： *</strong> 这就是遍历咯，没啥好说的<br><strong><em>您</em></strong>提供的 <code>reducer</code> 函数：我哪有什么 <code>reducer</code> 函数呢，后来理解了，就是回调，有的地方呢叫 <code>handler</code> ，这里跟 <code>reduce</code> 配合就叫了 <code>reducer</code>。<br><strong><em>升序执行</em></strong>：就是说是0，1，2下标这样的顺序执行啦。<br>将其结果汇总为单个返回值：最后返回的是一个值，当然没说必须是什么类型。</p>
<p>这样解释完了以后，上面这句话就比较好懂了，简单说就是 <code>reduce</code> 里传一个回调函数，执行回调函数方法后返回一个值，就是这样。</p>
<blockquote>
<p>reducer 函数接收4个参数:</p>
</blockquote>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)<br>您的 <code>reducer</code> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<p>看上面的描述一定要注意，这些参数是 <code>reducer</code> 的参数，不是 <code>reduce</code> 的参数，一共有4个，通常用前两个情况比较多。</p>
<p>那么 <code>reduce</code> 函数呢实际上有两个参数，第二个还可以省略 <code>reducer</code> 和 <code>initialValue</code>，<code>initialValue</code>作为第一次调用 <code>reducer</code> 函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 <strong><em>在没有初始值的空数组上调用 <code>reduce</code> 将报错</em></strong>，这点切记。</p>
<p>终于把前置知识讲清楚了，接下来，我们就用 <code>reduce</code> 搞点事情。</p>
<h2 id="1-使用-reduce-实现-map"><a href="#1-使用-reduce-实现-map" class="headerlink" title="1. 使用 reduce 实现 map"></a>1. 使用 <code>reduce</code> 实现 <code>map</code></h2><p><code>map</code> 的话我不想再讲一遍，一句话带过，就是对回调函数中的元素进行加工后返回一个长度一样的新数组。<br>那么该如何实现呢，我们来想想原理吧，刚才上面说过了，reduce执行过后的返回值会作为下一次执行的第一个参数放进去，那么就可以先用一个空数组作为初始值来接受每次需要处理的元素的集合，并返回回去，作为下一次传入的第一个参数，这样每次操作完之后就可以push到这个数组中，那么剩下要做的就是处理数组中每一项的函数了，我们叫他 <code>handler</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Array.prototype.reduceToMap &#x3D; function (handler) &#123; &#x2F;&#x2F; 自定义 &#96;map&#96; 函数 &#96;reduceToMap&#96;</span><br><span class="line">  return this.reduce((target, current, index) &#x3D;&gt; &#123; &#x2F;&#x2F; this指向调用他的数组</span><br><span class="line">    target.push(handler.call(this, current, index)) &#x2F;&#x2F; 这里用了call方法，handler将接受两个参数 current和index</span><br><span class="line">    return target; &#x2F;&#x2F; 处理完成后返回新数组</span><br><span class="line">  &#125;, []) &#x2F;&#x2F; 初始化空的新数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就这样我们就用 <code>reduce</code>，实现了 <code>map</code> 的功能，是不是很好用？</p>
<h2 id="2-使用-reduce-实现-filter"><a href="#2-使用-reduce-实现-filter" class="headerlink" title="2. 使用 reduce 实现 filter"></a>2. 使用 <code>reduce</code> 实现 <code>filter</code></h2><p><code>filter</code> 也是数组常用的方法，同样传入一个回调函数，处理结果返回true或false，最终 <code>filter</code> 会返回一个过滤后的函数。<br>学会了上面的 <code>map</code> 的实现，实际上 <code>filter</code> 就会很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Array.prototype.reduceToFilter &#x3D; function (handler) &#123; &#x2F;&#x2F; 还是自定义方法名</span><br><span class="line">  return this.reduce((target, current, index) &#x3D;&gt; &#123;</span><br><span class="line">    if (handler.call(this, current, index)) &#123; &#x2F;&#x2F; 这里注意 handler 要返回的是布尔类型的值</span><br><span class="line">      target.push(current); &#x2F;&#x2F; 符合条件就插入新数组</span><br><span class="line">    &#125; &#x2F;&#x2F; 不符合就什么都不做</span><br><span class="line">    return target; &#x2F;&#x2F; 最后返回新数组</span><br><span class="line">  &#125;, []) &#x2F;&#x2F; 初始化一个空数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>日后在看到 <code>reduce</code> 的妙用之后还会来补充这篇文章，如果实在懒得写，我也会链接一下新文章，希望大家长期关注。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- async 和 await</title>
    <url>/2020/01/03/FE-guide-async-await/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以把 <code>async</code> 看成将函数返回值使用 <code>Promise.resolve()</code> 包裹了下。<br><code>await</code> 只能在 <code>async</code> 函数中使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'finish'</span>)</span><br><span class="line">      resolve(<span class="string">"sleep"</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"object"</span>);</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p>
<p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<p>下面来看一个使用 <code>await</code> 的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, a) <span class="comment">// -&gt; '3' 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，这里说明下原理</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ， <code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li>
<li>因为 <code>await</code> 是异步操作，遇到 <code>await</code> 就会立即返回一个 <code>pending</code> 状态的 <code>Promise</code> 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li>
<li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li>
<li>然后后面就是常规执行代码了</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- call, apply, bind 区别</title>
    <url>/2020/01/03/FE-guide-call-apply-bind/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call, apply, bind 区别"></a>call, apply, bind 区别</h1><p>首先说下前两者的异同。<br>相同： <code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。<br>不同：传参的方式不同，除了第一个参数外， <code>call</code> 可以接收一个参数<strong><em>列表</em></strong>， <code>apply</code> 只接受一个参数<strong><em>数组</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">let anObj &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;</span><br><span class="line">function getValue(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;)</span><br><span class="line">getValue.apply(anObj, [&#39;lixuguang&#39;, &#39;31&#39;])</span><br></pre></td></tr></table></figure>
<h2 id="模拟实现-call-和-apply"><a href="#模拟实现-call-和-apply" class="headerlink" title="模拟实现 call 和 apply"></a>模拟实现 <code>call</code> 和 <code>apply</code></h2><p>可以从以下几点来考虑如何实现</p>
<ul>
<li>不传入第一个参数，那么默认为 <code>window</code></li>
<li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Function.prototype.myCall &#x3D; function (context) &#123;</span><br><span class="line">  var context &#x3D; context || window &#x2F;&#x2F; 有入参用入参，没有给 window</span><br><span class="line">  context.fn &#x3D; this  &#x2F;&#x2F; 给 context 添加一个属性，getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;) &#x3D;&gt; anObj.fn &#x3D; getValue</span><br><span class="line">  var args &#x3D; [...arguments].slice(1) &#x2F;&#x2F; 将 context 后面的参数取出来</span><br><span class="line">  var result &#x3D; context.fn(...args) &#x2F;&#x2F; getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;) &#x3D;&gt; anObj.fn(&#39;yck&#39;, &#39;24&#39;)</span><br><span class="line">  delete context.fn &#x2F;&#x2F; 删除 fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上就是 call 的思路，apply 的实现也类似<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Function.prototype.Apply &#x3D; function (context) &#123;</span><br><span class="line">  var context &#x3D; context || window &#x2F;&#x2F; 有入参用入参，没有给 window</span><br><span class="line">  context.fn &#x3D; this  &#x2F;&#x2F; 给 context 添加一个属性，getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;) &#x3D;&gt; anObj.fn &#x3D; getValue</span><br><span class="line">  var args &#x3D; arguments[1] &#x2F;&#x2F; 将 context 后面的参数取出来</span><br><span class="line">  var result &#x3D; args?context.fn(...args):context.fn() &#x2F;&#x2F; getValue.call(anObj, [&#39;lixuguang&#39;, &#39;31&#39;]) &#x3D;&gt; anObj.fn(&#39;yck&#39;, &#39;24&#39;)</span><br><span class="line">  delete context.fn &#x2F;&#x2F; 删除 fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化。</li>
</ul>
<p>同样的，也来模拟实现下 <code>bind</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Function.prototype.myBind &#x3D; function (context) &#123;</span><br><span class="line">  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    throw new TypeError(&#39;Error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  var _this &#x3D; this</span><br><span class="line">  var args &#x3D; [...arguments].slice(1)</span><br><span class="line">  </span><br><span class="line">  return function F() &#123; &#x2F;&#x2F; 返回一个函数，这是 &#96;bind&#96; 和 &#96;call&#96; ， &#96;apply&#96; 的区别</span><br><span class="line">    if (this instanceof F) &#123; &#x2F;&#x2F; 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br><span class="line">      return new _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 深浅拷贝</title>
    <url>/2020/01/03/FE-guide-copy/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。<br>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>首先可以通过 <code>Object.assign</code> 来解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>当然我们也可以通过展开运算符（…）来解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>我们还可以用很多简单的方法都能实现浅拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure>

<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">'FE'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决，这也是最好用最简单的方法，俗称乞丐版。<br><strong><em>乞丐版</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure>
<p>但是该方法也是有局限性的：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj) <span class="comment">// =&gt; Uncaught TypeError: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>
<p>如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝<br>在遇到函数、 <code>undefined</code> 或者 <code>symbol</code> 的时候，该对象也不能正常的序列化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  sex: <span class="built_in">Symbol</span>(<span class="string">'fmale'</span>),</span><br><span class="line">  jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  name: <span class="string">'lixuguang'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// =&gt; &#123;name: "lixuang"&#125;</span></span><br></pre></td></tr></table></figure>

<p>你会发现在上述情况中，该方法会忽略掉函数和 <code>undefined</code> 。<br>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝<strong><em>性能最快</em></strong>的。</p>
<p>那么是否可以解决函数和循环引用的问题呢？答案是肯定可以解决，接下来是基础版本的改造<br><strong><em>基础版</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myClone</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">'object'</span>)&#123; <span class="comment">// 判断传入目标是否是object类型</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;; <span class="comment">// 创建克隆对象</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> target)&#123; <span class="comment">// 遍历目标对象</span></span><br><span class="line">      cloneTarget[key] = myClone(target[key]) <span class="comment">// 递归调用 clone 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target <span class="comment">// 如果不是 object 返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写到这里已经可以帮助你应付一些面试官考察你的递归解决问题的能力。但是显然，这个深拷贝函数还是有一些问题。<br>这里只考虑了对象，没有考虑数组。<br>下面我们来做一个强化版的深拷贝，同时考虑对象、数组还有循环引用的问题。<br><strong><em>强化版</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myClone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123; <span class="comment">// WeakMap =&gt; 键对象弱引用， 可被垃圾回收</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> target === <span class="string">'object'</span>)&#123; <span class="comment">// 判断是否是对象</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;; <span class="comment">// 判断是是数组还是对象</span></span><br><span class="line">    <span class="keyword">if</span>(map.get(target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = myClone(target[key], map)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然如果你的数据中含有以上三种情况下，可以使用 <code>lodash</code> 的深拷贝函数。<br>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>, </span><br><span class="line">  b: &#123;</span><br><span class="line">    c: b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意该方法是异步的</span></span><br><span class="line"><span class="comment">// 可以处理 undefined 和循环引用对象</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>深拷贝实现方式2，可以深拷贝 <code>function</code> 、<code>symbol</code>，等等，堪称终极版<br><strong><em>终极版</em></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapTag = <span class="string">'[object Map]'</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">'[object Set]'</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">'[object Array]'</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">'[object Object]'</span>;</span><br><span class="line"><span class="keyword">const</span> argsTag = <span class="string">'[object Arguments]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">'[object Boolean]'</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">'[object Date]'</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">'[object Number]'</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">'[object Symbol]'</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">'[object Error]'</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="keyword">const</span> funcTag = <span class="string">'[object Function]'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">array, iteratee</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">const</span> length = array.length;</span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    iteratee(array[index], index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> target;</span><br><span class="line">  <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInit</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = target.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(<span class="built_in">Symbol</span>.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneReg</span>(<span class="params">targe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">  result.lastIndex = targe.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneFunction</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bodyReg = <span class="regexp">/(?&lt;=&#123;)(.|\n)+(?=&#125;)/m</span>;</span><br><span class="line">  <span class="keyword">const</span> paramReg = <span class="regexp">/(?&lt;=\().+(?=\)\s+&#123;)/</span>;</span><br><span class="line">  <span class="keyword">const</span> funcString = func.toString();</span><br><span class="line">  <span class="keyword">if</span> (func.prototype) &#123;</span><br><span class="line">    <span class="keyword">const</span> param = paramReg.exec(funcString);</span><br><span class="line">    <span class="keyword">const</span> body = bodyReg.exec(funcString);</span><br><span class="line">    <span class="keyword">if</span> (body) &#123;</span><br><span class="line">      <span class="keyword">if</span> (param) &#123;</span><br><span class="line">        <span class="keyword">const</span> paramArr = param[<span class="number">0</span>].split(<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(...paramArr, body[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(body[<span class="number">0</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(funcString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneOtherType</span>(<span class="params">targe, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Ctor = targe.constructor;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> boolTag:</span><br><span class="line">    <span class="keyword">case</span> numberTag:</span><br><span class="line">    <span class="keyword">case</span> stringTag:</span><br><span class="line">    <span class="keyword">case</span> errorTag:</span><br><span class="line">    <span class="keyword">case</span> dateTag:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Ctor(targe);</span><br><span class="line">    <span class="keyword">case</span> regexpTag:</span><br><span class="line">      <span class="keyword">return</span> cloneReg(targe);</span><br><span class="line">    <span class="keyword">case</span> symbolTag:</span><br><span class="line">      <span class="keyword">return</span> cloneSymbol(targe);</span><br><span class="line">    <span class="keyword">case</span> funcTag:</span><br><span class="line">      <span class="keyword">return</span> cloneFunction(targe);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 克隆原始类型</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">const</span> type = getType(target);</span><br><span class="line">  <span class="keyword">let</span> cloneTarget;</span><br><span class="line">  <span class="keyword">if</span> (deepTag.includes(type)) &#123;</span><br><span class="line">    cloneTarget = getInit(target, type);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cloneOtherType(target, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆set</span></span><br><span class="line">  <span class="keyword">if</span> (type === setTag) &#123;</span><br><span class="line">    target.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.add(clone(value));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆map</span></span><br><span class="line">  <span class="keyword">if</span> (type === mapTag) &#123;</span><br><span class="line">    target.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.set(key, clone(value));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆对象和数组</span></span><br><span class="line">  <span class="keyword">const</span> keys = type === arrayTag ? <span class="literal">undefined</span> : <span class="built_in">Object</span>.keys(target);</span><br><span class="line">  forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">      key = value;</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget[key] = clone(target[key], map);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">clone(target);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 柯里化 currying</title>
    <url>/2020/01/05/FE-guide-currying/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<p>柯里化，可以理解为<strong><em>提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数</em></strong>。因为这样的特性，也被称为部分计算函数。</p>
<p>通俗易懂的解释：用<strong><em>闭包</em></strong>把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。柯里化，是一个逐步接收参数的过程。在接下来的剖析中，你会深刻体会到这一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function currying(fn)&#123;</span><br><span class="line">    var allArgs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    return function next()&#123;</span><br><span class="line">        var args &#x3D; [].slice.call(arguments); &#x2F;&#x2F; 拆成数组元素</span><br><span class="line"></span><br><span class="line">        if(args.length &gt; 0)&#123;</span><br><span class="line">            allArgs &#x3D; allArgs.concat(args);</span><br><span class="line">            return next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return fn.apply(null, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来一个简单的实例验证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var add &#x3D; currying(function()&#123;</span><br><span class="line">    var sum &#x3D; 0;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        sum +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(1)(2, 3)(4)() &#x2F;&#x2F; &#x3D;&gt; 10</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function getUrl(domain, protocol, path) &#123;</span><br><span class="line">	return protocol + &quot;:&#x2F;&#x2F;&quot; + domain + &quot;&#x2F;&quot; + path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var page1 &#x3D; getUrl(&#39;http&#39;, &#39;lixuguang.github.io&#39;, &#39;page1.html&#39;);</span><br><span class="line">var page2 &#x3D; getUrl(&#39;http&#39;, &#39;lixuguang.github.io&#39;, &#39;page2.html&#39;);</span><br></pre></td></tr></table></figure>
<p>我们使用currying来简化它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var conardliSite &#x3D; currying(getUrl)</span><br><span class="line">var page1 &#x3D; conardliSite(&#39;page1.html&#39;)(&#39;http&#39;, &#39;lixuguang.github.io&#39;)();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 闭包</title>
    <url>/2020/01/02/FE-guide-Closure/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="闭包Closure"><a href="#闭包Closure" class="headerlink" title="闭包Closure"></a>闭包<code>Closure</code></h1><p>闭包的定义很简单：函数 <code>A</code> 返回了一个函数 <code>B</code> ，并且函数 <code>B</code> 中使用了函数 <code>A</code> 的变量，函数 <code>B</code> 就被称为闭包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function A() &#123;</span><br><span class="line">  let a &#x3D; 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你是否会疑惑，为什么函数 <code>A</code> 已经弹出调用栈了，为什么函数 <code>B</code> 还能引用到函数 <code>A</code> 中的变量。因为函数 <code>A</code> 中的变量这时候是存储在堆上的。现在的 <code>JS</code> 引擎可以通过<strong><em>逃逸分析</em></strong>辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
<p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for ( var i&#x3D;1; i&lt;&#x3D;5; i++) &#123;</span><br><span class="line">	setTimeout( function timer() &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。</p>
<p>解决办法两种，第一种使用闭包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;, j * 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种就是使用 <code>setTimeout</code> 的第三个参数(附加参数，传给 <code>setTimeout</code> 中的函数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for ( var i&#x3D;1; i&lt;&#x3D;5; i++) &#123;</span><br><span class="line">	setTimeout( function timer(j) &#123;</span><br><span class="line">		console.log( j );</span><br><span class="line">	&#125;, i*1000, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for ( let i&#x3D;1; i&lt;&#x3D;5; i++) &#123;</span><br><span class="line">	setTimeout( function timer() &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#123; &#x2F;&#x2F; 形成块级作用域</span><br><span class="line">  let i &#x3D; 0</span><br><span class="line">  &#123;</span><br><span class="line">    let ii &#x3D; i</span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">        console.log( ii );</span><br><span class="line">    &#125;, i*1000 );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    let ii &#x3D; i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    let ii &#x3D; i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 函数防抖和节流</title>
    <url>/2020/01/03/FE-guide-debounce-throttle/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h1><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>
<p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p>
<p>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
<p>我们先来看一个袖珍版的防抖理解一下防抖的实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">  <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">  <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数</span></span><br></pre></td></tr></table></figure>
<p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说：</p>
<ul>
<li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。</li>
<li>例如用户给某系统表单点提交的时候，我们希望用户点第一下的时候就去调用接口，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是用来获取当前时间戳的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span> </span>func        回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;number&#125;</span>   </span>wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;boolean&#125;</span>  </span>immediate   设置为ture时，是否立即调用函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span>             </span>返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait = <span class="number">50</span>, immediate = true</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer, context, args</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 延迟函数执行完毕，清空缓存的定时器序号</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 延迟执行的情况下，函数会在延迟函数中执行</span></span><br><span class="line">    <span class="comment">// 使用到之前缓存的参数和上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有创建延迟执行函数（later），就创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      <span class="comment">// 如果是立即执行，调用函数</span></span><br><span class="line">      <span class="comment">// 否则缓存参数和调用上下文</span></span><br><span class="line">      <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">        func.apply(<span class="keyword">this</span>, params)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="keyword">this</span></span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span></span><br><span class="line">    <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体函数实现的不难，总结一下。</p>
<ul>
<li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。</li>
<li>对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数</li>
</ul>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;function&#125;</span>   </span>func      回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;number&#125;</span>     </span>wait      表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;object&#125;</span>     </span>options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span></span><br><span class="line"><span class="comment"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span></span><br><span class="line"><span class="comment"> *                                两者不能共存，否则函数不能执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span>             </span>返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context, args, result;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 之前的时间戳</span></span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 options 没传则设为空对象</span></span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时器回调函数</span></span><br><span class="line">    <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果设置了 leading，就将 previous 设为 0</span></span><br><span class="line">      <span class="comment">// 用于下面函数的第一个 if 判断</span></span><br><span class="line">      previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">      <span class="comment">// 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span></span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 获得当前时间戳</span></span><br><span class="line">      <span class="keyword">var</span> now = _.now();</span><br><span class="line">      <span class="comment">// 首次进入前者肯定为 true</span></span><br><span class="line">	  <span class="comment">// 如果需要第一次不执行函数</span></span><br><span class="line">	  <span class="comment">// 就将上次时间戳设为当前的</span></span><br><span class="line">      <span class="comment">// 这样在接下来计算 remaining 的值时会大于0</span></span><br><span class="line">      <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">      <span class="comment">// 计算剩余时间</span></span><br><span class="line">      <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">      context = <span class="keyword">this</span>;</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="comment">// 如果当前调用已经大于上次调用时间 + wait</span></span><br><span class="line">      <span class="comment">// 或者用户手动调了时间</span></span><br><span class="line"> 	  <span class="comment">// 如果设置了 trailing，只会进入这个条件</span></span><br><span class="line">	  <span class="comment">// 如果没有设置 leading，那么第一次会进入这个条件</span></span><br><span class="line">	  <span class="comment">// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span></span><br><span class="line">	  <span class="comment">// 其实还是会进入的，因为定时器的延时</span></span><br><span class="line">	  <span class="comment">// 并不是准确的时间，很可能你设置了2秒</span></span><br><span class="line">	  <span class="comment">// 但是他需要2.2秒才触发，这时候就会进入这个条件</span></span><br><span class="line">      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">        <span class="comment">// 如果存在定时器就清理掉否则会调用二次回调</span></span><br><span class="line">        <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否设置了定时器和 trailing</span></span><br><span class="line">	    <span class="comment">// 没有的话就开启一个定时器</span></span><br><span class="line">        <span class="comment">// 并且不能不能同时设置 leading 和 trailing</span></span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机通识 ---- 数据结构</title>
    <url>/2020/01/09/FE-guide-data-structure/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络相关的知识虽然平时在编码阶段很少遇到，但是并不是说它不重要，尤其是前端优化层面，能从网络传输过程优化的点有很多，所以，我们需要好好掌握网络相关的知识，接下来，我将会将我了解到的网络相关的知识点进行一一整理</p>
<h1 id="栈-Heap"><a href="#栈-Heap" class="headerlink" title="栈 Heap"></a>栈 Heap</h1><blockquote>
<p>栈是一个线性结构，在计算机中是一个相当常见的数据结构。<br>栈的特点是只能在某一端添加或删除数据，遵循<strong>先进后出(FILO)</strong>的原则</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">class Stack &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.stack &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  push(item) &#123;</span><br><span class="line">    this.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    this.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  peek() &#123; &#x2F;&#x2F; 取最后一项</span><br><span class="line">    return this.stack[this.getCount() - 1]</span><br><span class="line">  &#125;</span><br><span class="line">  getCount() &#123;</span><br><span class="line">    return this.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.getCount() &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>选取了 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCode 上序号为 20 的题目</a></p>
<p>题意是匹配括号，可以通过栈的特性来完成这道题目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isValid &#x3D; function(str) &#123;</span><br><span class="line">  let map &#x3D; &#123;</span><br><span class="line">    &#39;(&#39;: -1,</span><br><span class="line">    &#39;)&#39;: 1,</span><br><span class="line">    &#39;[&#39;: -2,</span><br><span class="line">    &#39;]&#39;: 2,</span><br><span class="line">    &#39;&#123;&#39;: -3,</span><br><span class="line">    &#39;&#125;&#39;: 3</span><br><span class="line">  &#125;</span><br><span class="line">  let stack &#x3D; [] &#x2F;&#x2F; 空数组</span><br><span class="line">  for (let i &#x3D; 0; i &lt; str.length; i++) &#123; &#x2F;&#x2F; 遍历字符串每个字符</span><br><span class="line">    if (map[str[i]] &lt; 0) &#123; &#x2F;&#x2F; 如果是左边括号，入栈</span><br><span class="line">      stack.push(str[i])</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 否则出栈，判断左右括号加到一起是不是0</span><br><span class="line">      let last &#x3D; stack.pop()</span><br><span class="line">      if (map[last] + map[str[i]] !&#x3D; 0) return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (stack.length &gt; 0) return false &#x2F;&#x2F; 循环完成后，判断数组中时候还有剩下的，有剩下的说明括号没闭合</span><br><span class="line">  return true &#x2F;&#x2F; 否则没剩下的，都闭合了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循<strong>先进先出(FIFO)</strong>的原则。</p>
</blockquote>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>这里会讲解两种实现队列的方式，分别是<strong>单链队列</strong>和<strong>循环队列</strong>。</p>
<ul>
<li>链队列即队列的链式存储结构，结构上就是一个单链表，但数据只能是头进尾出。链式结构更加的灵活，特别是在存储空间上，基本不会出现溢出的情况，所以不用像循环队列一样判断队列是否已满，且空间的利用率相对较高。<ul>
<li>链队列front指向头结点，头结点不存储数据，rear指向队尾结点。</li>
</ul>
</li>
</ul>
<ul>
<li><p>循环队列即为头尾相接的队列，它的最大存储空间和顺序队列一样由数组界定，但队列的长度并不一定等同于数组的长度；循环队列的队首和队尾分别由两个指针front、rear标识，于是这样就能做到首尾相接。</p>
</li>
<li><p>链队列：为操作方便，给链队列添加一个头结点</p>
</li>
<li><p>循环队列：附设两个指针front和rear分别指示队列头元素及尾元素的位置，每当插入新的队尾元素是，尾指针加1；每当删除队列头元素是，头指针加1</p>
<ul>
<li>如果用循环队列，则必须设定一个最大队列长度；若无法确定最大长度，则宜采用链队列。</li>
</ul>
</li>
</ul>
<h3 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Queue &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.queue &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    this.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    return this.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    return this.queue[0]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    return this.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.getLength() &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。<br>循环队列的出队操作平均是 O(1) 的时间复杂度。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class SqQueue &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    this.queue &#x3D; new Array(length + 1)</span><br><span class="line">    &#x2F;&#x2F; 队头</span><br><span class="line">    this.first &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 队尾</span><br><span class="line">    this.last &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 当前队列大小</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断队尾 + 1 是否为队头</span><br><span class="line">    &#x2F;&#x2F; 如果是就代表需要扩容数组</span><br><span class="line">    &#x2F;&#x2F; % this.queue.length 是为了防止数组越界</span><br><span class="line">    if (this.first &#x3D;&#x3D;&#x3D; (this.last + 1) % this.queue.length) &#123;</span><br><span class="line">      this.resize(this.getLength() * 2 + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    this.queue[this.last] &#x3D; item</span><br><span class="line">    this.size++</span><br><span class="line">    this.last &#x3D; (this.last + 1) % this.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    if (this.isEmpty()) &#123;</span><br><span class="line">      throw Error(&#39;Queue is empty&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    let r &#x3D; this.queue[this.first]</span><br><span class="line">    this.queue[this.first] &#x3D; null</span><br><span class="line">    this.first &#x3D; (this.first + 1) % this.queue.length</span><br><span class="line">    this.size--</span><br><span class="line">    &#x2F;&#x2F; 判断当前队列大小是否过小</span><br><span class="line">    &#x2F;&#x2F; 为了保证不浪费空间，在队列空间等于总长度四分之一时</span><br><span class="line">    &#x2F;&#x2F; 且不为 2 时缩小总长度为当前的一半</span><br><span class="line">    if (this.size &#x3D;&#x3D;&#x3D; this.getLength() &#x2F; 4 &amp;&amp; this.getLength() &#x2F; 2 !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      this.resize(this.getLength() &#x2F; 2)</span><br><span class="line">    &#125;</span><br><span class="line">    return r</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    if (this.isEmpty()) &#123;</span><br><span class="line">      throw Error(&#39;Queue is empty&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    return this.queue[this.first]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    return this.queue.length - 1</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.first &#x3D;&#x3D;&#x3D; this.last</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    let q &#x3D; new Array(length)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] &#x3D; this.queue[(i + this.first) % this.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    this.queue &#x3D; q</span><br><span class="line">    this.first &#x3D; 0</span><br><span class="line">    this.last &#x3D; this.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote>
<p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
</blockquote>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>单向链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(v, next) &#123;</span><br><span class="line">    this.value &#x3D; v</span><br><span class="line">    this.next &#x3D; next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LinkList &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 链表长度</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 虚拟头部</span><br><span class="line">    this.dummyNode &#x3D; new Node(null, null)</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    if (index &#x3D;&#x3D;&#x3D; currentIndex) return header</span><br><span class="line">    return this.find(header.next, index, currentIndex + 1)</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    this.checkIndex(index)</span><br><span class="line">    &#x2F;&#x2F; 当往链表末尾插入时，prev.next 为空</span><br><span class="line">    &#x2F;&#x2F; 其他情况时，因为要插入节点，所以插入的节点</span><br><span class="line">    &#x2F;&#x2F; 的 next 应该是 prev.next</span><br><span class="line">    &#x2F;&#x2F; 然后设置 prev.next 为插入的节点</span><br><span class="line">    let prev &#x3D; this.find(this.dummyNode, index, 0)</span><br><span class="line">    prev.next &#x3D; new Node(v, prev.next)</span><br><span class="line">    this.size++</span><br><span class="line">    return prev.next</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    return this.addNode(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    return this.addNode(v, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    return this.addNode(v, this.size)</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    this.checkIndex(index)</span><br><span class="line">    index &#x3D; isLast ? index - 1 : index</span><br><span class="line">    let prev &#x3D; this.find(this.dummyNode, index, 0)</span><br><span class="line">    let node &#x3D; prev.next</span><br><span class="line">    prev.next &#x3D; node.next</span><br><span class="line">    node.next &#x3D; null</span><br><span class="line">    this.size--</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    return this.removeNode(0)</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    return this.removeNode(this.size, true)</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; this.size) throw Error(&#39;Index error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    this.checkIndex(index)</span><br><span class="line">    if (this.isEmpty()) return</span><br><span class="line">    return this.find(this.dummyNode, index, 0).next</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.size &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    return this.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p>
<p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。</p>
<h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p>
<p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BST &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    return this.size</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.size &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    this.root &#x3D; this._addChild(this.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 添加节点时，需要比较添加的节点值和当前</span><br><span class="line">  &#x2F;&#x2F; 节点值的大小</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      this.size++</span><br><span class="line">      return new Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.value &gt; v) &#123;</span><br><span class="line">      node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">    &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">      node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p>
<p>对于树的遍历来说，有三种遍历方法，分别是<strong>先序遍历</strong>、<strong>中序遍历</strong>、<strong>后序遍历</strong>。</p>
<p>三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p>
<p>以下都是递归实现.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先序遍历可用于打印树的结构</span><br><span class="line">&#x2F;&#x2F; 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  this._pre(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    console.log(node.value)</span><br><span class="line">    this._pre(node.left)</span><br><span class="line">    this._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 中序遍历可用于排序</span><br><span class="line">&#x2F;&#x2F; 对于 BST 来说，中序遍历可以实现一次遍历就</span><br><span class="line">&#x2F;&#x2F; 得到有序的值</span><br><span class="line">&#x2F;&#x2F; 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  this._mid(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    this._mid(node.left)</span><br><span class="line">    console.log(node.value)</span><br><span class="line">    this._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 后序遍历可用于先操作子节点</span><br><span class="line">&#x2F;&#x2F; 再操作父节点的场景</span><br><span class="line">&#x2F;&#x2F; 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  this._back(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    this._back(node.left)</span><br><span class="line">    this._back(node.right)</span><br><span class="line">    console.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">breadthTraversal() &#123;</span><br><span class="line">  if (!this.root) return null</span><br><span class="line">  let q &#x3D; new Queue()</span><br><span class="line">  &#x2F;&#x2F; 将根节点入队</span><br><span class="line">  q.enQueue(this.root)</span><br><span class="line">  &#x2F;&#x2F; 循环判断队列是否为空，为空</span><br><span class="line">  &#x2F;&#x2F; 代表树遍历完毕</span><br><span class="line">  while (!q.isEmpty()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将队首出队，判断是否有左右子树</span><br><span class="line">    &#x2F;&#x2F; 有的话，就先左后右入队</span><br><span class="line">    let n &#x3D; q.deQueue()</span><br><span class="line">    console.log(n.value)</span><br><span class="line">    if (n.left) q.enQueue(n.left)</span><br><span class="line">    if (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">getMin() &#123;</span><br><span class="line">  return this._getMin(this.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  if (!node.left) return node</span><br><span class="line">  return this._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  return this._getMax(this.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  if (!node.right) return node</span><br><span class="line">  return this._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">floor(v) &#123;</span><br><span class="line">  let node &#x3D; this._floor(this.root, v)</span><br><span class="line">  return node ? node.value : null</span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  if (!node) return null</span><br><span class="line">  if (node.value &#x3D;&#x3D;&#x3D; v) return v</span><br><span class="line">  &#x2F;&#x2F; 如果当前节点值还比需要的值大，就继续递归</span><br><span class="line">  if (node.value &gt; v) &#123;</span><br><span class="line">    return this._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断当前节点是否拥有右子树</span><br><span class="line">  let right &#x3D; this._floor(node.right, v)</span><br><span class="line">  if (right) return right</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 修改代码</span><br><span class="line">    this.size &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 新增代码</span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  return node ? node.size : 0</span><br><span class="line">&#125;</span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  if (!node) &#123;</span><br><span class="line">    return new Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  if (node.value &gt; v) &#123;</span><br><span class="line">    &#x2F;&#x2F; 修改代码</span><br><span class="line">    node.size++</span><br><span class="line">    node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">  &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">    &#x2F;&#x2F; 修改代码</span><br><span class="line">    node.size++</span><br><span class="line">    node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br><span class="line">select(k) &#123;</span><br><span class="line">  let node &#x3D; this._select(this.root, k)</span><br><span class="line">  return node ? node.value : null</span><br><span class="line">&#125;</span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  if (!node) return null</span><br><span class="line">  &#x2F;&#x2F; 先获取左子树下有几个节点</span><br><span class="line">  let size &#x3D; node.left ? node.left.size : 0</span><br><span class="line">  &#x2F;&#x2F; 判断 size 是否大于 k</span><br><span class="line">  &#x2F;&#x2F; 如果大于 k，代表所需要的节点在左节点</span><br><span class="line">  if (size &gt; k) return this._select(node.left, k)</span><br><span class="line">  &#x2F;&#x2F; 如果小于 k，代表所需要的节点在右节点</span><br><span class="line">  &#x2F;&#x2F; 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span><br><span class="line">  if (size &lt; k) return this._select(node.right, k - size - 1)</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p>
<ul>
<li>需要删除的节点没有子树</li>
<li>需要删除的节点只有一条子树</li>
<li>需要删除的节点有左右两条树</li>
</ul>
<p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">delectMin() &#123;</span><br><span class="line">  this.root &#x3D; this._delectMin(this.root)</span><br><span class="line">  console.log(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  &#x2F;&#x2F; 一直递归左子树</span><br><span class="line">  &#x2F;&#x2F; 如果左子树为空，就判断节点是否拥有右子树</span><br><span class="line">  &#x2F;&#x2F; 有右子树的话就把需要删除的节点替换为右子树</span><br><span class="line">  if ((node !&#x3D; null) &amp; !node.left) return node.right</span><br><span class="line">  node.left &#x3D; this._delectMin(node.left)</span><br><span class="line">  &#x2F;&#x2F; 最后需要重新维护下节点的 &#96;size&#96;</span><br><span class="line">  node.size &#x3D; this._getSize(node.left) + this._getSize(node.right) + 1</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</p>
<p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p>
<p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">delect(v) &#123;</span><br><span class="line">  this.root &#x3D; this._delect(this.root, v)</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  if (!node) return null</span><br><span class="line">  &#x2F;&#x2F; 寻找的节点比当前节点小，去左子树找</span><br><span class="line">  if (node.value &lt; v) &#123;</span><br><span class="line">    node.right &#x3D; this._delect(node.right, v)</span><br><span class="line">  &#125; else if (node.value &gt; v) &#123;</span><br><span class="line">    &#x2F;&#x2F; 寻找的节点比当前节点大，去右子树找</span><br><span class="line">    node.left &#x3D; this._delect(node.left, v)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 进入这个条件说明已经找到节点</span><br><span class="line">    &#x2F;&#x2F; 先判断节点是否拥有拥有左右子树中的一个</span><br><span class="line">    &#x2F;&#x2F; 是的话，将子树返回出去，这里和 &#96;_delectMin&#96; 的操作一样</span><br><span class="line">    if (!node.left) return node.right</span><br><span class="line">    if (!node.right) return node.left</span><br><span class="line">    &#x2F;&#x2F; 进入这里，代表节点拥有左右子树</span><br><span class="line">    &#x2F;&#x2F; 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span><br><span class="line">    let min &#x3D; this._getMin(node.right)</span><br><span class="line">    &#x2F;&#x2F; 取出最小值后，删除最小值</span><br><span class="line">    &#x2F;&#x2F; 然后把删除节点后的子树赋值给最小值节点</span><br><span class="line">    min.right &#x3D; this._delectMin(node.right)</span><br><span class="line">    &#x2F;&#x2F; 左子树不动</span><br><span class="line">    min.left &#x3D; node.left</span><br><span class="line">    node &#x3D; min</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 维护 size</span><br><span class="line">  node.size &#x3D; this._getSize(node.left) + this._getSize(node.right) + 1</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><blockquote>
<p>二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p>
</blockquote>
<blockquote>
<p>AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</p>
</blockquote>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。</p>
<p>对于 AVL 树来说，添加节点会有四种情况<br><img src="https://s2.ax1x.com/2020/01/09/lWB0nf.png" alt="lWB0nf.png"></p>
<p>对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</p>
<p>旋转之前：new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。</p>
<p>对于右右情况来说，相反于左左情况，所以不再赘述。</p>
<p>对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。</p>
<p>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">    this.height &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AVL &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    this.root &#x3D; this._addChild(this.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      return new Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.value &gt; v) &#123;</span><br><span class="line">      node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">    &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">      node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      node.value &#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    node.height &#x3D;</span><br><span class="line">      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))</span><br><span class="line">    let factor &#x3D; this._getBalanceFactor(node)</span><br><span class="line">    &#x2F;&#x2F; 当需要右旋时，根节点的左树一定比右树高度高</span><br><span class="line">    if (factor &gt; 1 &amp;&amp; this._getBalanceFactor(node.left) &gt;&#x3D; 0) &#123;</span><br><span class="line">      return this._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当需要左旋时，根节点的左树一定比右树高度矮</span><br><span class="line">    if (factor &lt; -1 &amp;&amp; this._getBalanceFactor(node.right) &lt;&#x3D; 0) &#123;</span><br><span class="line">      return this._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 左右情况</span><br><span class="line">    &#x2F;&#x2F; 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高</span><br><span class="line">    if (factor &gt; 1 &amp;&amp; this._getBalanceFactor(node.left) &lt; 0) &#123;</span><br><span class="line">      node.left &#x3D; this._leftRotate(node.left)</span><br><span class="line">      return this._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 右左情况</span><br><span class="line">    &#x2F;&#x2F; 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮</span><br><span class="line">    if (factor &lt; -1 &amp;&amp; this._getBalanceFactor(node.right) &gt; 0) &#123;</span><br><span class="line">      node.right &#x3D; this._rightRotate(node.right)</span><br><span class="line">      return this._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">  _getHeight(node) &#123;</span><br><span class="line">    if (!node) return 0</span><br><span class="line">    return node.height</span><br><span class="line">  &#125;</span><br><span class="line">  _getBalanceFactor(node) &#123;</span><br><span class="line">    return this._getHeight(node.left) - this._getHeight(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 节点右旋</span><br><span class="line">  &#x2F;&#x2F;           5                    2</span><br><span class="line">  &#x2F;&#x2F;         &#x2F;   \                &#x2F;   \</span><br><span class="line">  &#x2F;&#x2F;        2     6   &#x3D;&#x3D;&gt;       1      5</span><br><span class="line">  &#x2F;&#x2F;       &#x2F;  \               &#x2F;       &#x2F;  \</span><br><span class="line">  &#x2F;&#x2F;      1    3             new     3    6</span><br><span class="line">  &#x2F;&#x2F;     &#x2F;</span><br><span class="line">  &#x2F;&#x2F;    new</span><br><span class="line">  _rightRotate(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 旋转后新根节点</span><br><span class="line">    let newRoot &#x3D; node.left</span><br><span class="line">    &#x2F;&#x2F; 需要移动的节点</span><br><span class="line">    let moveNode &#x3D; newRoot.right</span><br><span class="line">    &#x2F;&#x2F; 节点 2 的右节点改为节点 5</span><br><span class="line">    newRoot.right &#x3D; node</span><br><span class="line">    &#x2F;&#x2F; 节点 5 左节点改为节点 3</span><br><span class="line">    node.left &#x3D; moveNode</span><br><span class="line">    &#x2F;&#x2F; 更新树的高度</span><br><span class="line">    node.height &#x3D;</span><br><span class="line">      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))</span><br><span class="line">    newRoot.height &#x3D;</span><br><span class="line">      1 +</span><br><span class="line">      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    return newRoot</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 节点左旋</span><br><span class="line">  &#x2F;&#x2F;           4                    6</span><br><span class="line">  &#x2F;&#x2F;         &#x2F;   \                &#x2F;   \</span><br><span class="line">  &#x2F;&#x2F;        2     6   &#x3D;&#x3D;&gt;       4      7</span><br><span class="line">  &#x2F;&#x2F;             &#x2F;  \         &#x2F;   \      \</span><br><span class="line">  &#x2F;&#x2F;            5     7      2     5      new</span><br><span class="line">  &#x2F;&#x2F;                   \</span><br><span class="line">  &#x2F;&#x2F;                    new</span><br><span class="line">  _leftRotate(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 旋转后新根节点</span><br><span class="line">    let newRoot &#x3D; node.right</span><br><span class="line">    &#x2F;&#x2F; 需要移动的节点</span><br><span class="line">    let moveNode &#x3D; newRoot.left</span><br><span class="line">    &#x2F;&#x2F; 节点 6 的左节点改为节点 4</span><br><span class="line">    newRoot.left &#x3D; node</span><br><span class="line">    &#x2F;&#x2F; 节点 4 右节点改为节点 5</span><br><span class="line">    node.right &#x3D; moveNode</span><br><span class="line">    &#x2F;&#x2F; 更新树的高度</span><br><span class="line">    node.height &#x3D;</span><br><span class="line">      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))</span><br><span class="line">    newRoot.height &#x3D;</span><br><span class="line">      1 +</span><br><span class="line">      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    return newRoot</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><blockquote>
<p>在计算机科学，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。<br>简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点</p>
</blockquote>
<ul>
<li>根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符</li>
<li>节点不存储字符，只有路径才存储，这点和其他的树结构不同</li>
<li>从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串</li>
</ul>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class TrieNode &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 代表每个字符经过节点的次数</span><br><span class="line">    this.path &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 代表到该节点的字符串有几个</span><br><span class="line">    this.end &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 链接</span><br><span class="line">    this.next &#x3D; new Array(26).fill(null)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Trie &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 根节点，代表空字符</span><br><span class="line">    this.root &#x3D; new TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 插入字符串</span><br><span class="line">  insert(str) &#123;</span><br><span class="line">    if (!str) return</span><br><span class="line">    let node &#x3D; this.root</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获得字符先对应的索引</span><br><span class="line">      let index &#x3D; str[i].charCodeAt() - &#39;a&#39;.charCodeAt()</span><br><span class="line">      &#x2F;&#x2F; 如果索引对应没有值，就创建</span><br><span class="line">      if (!node.next[index]) &#123;</span><br><span class="line">        node.next[index] &#x3D; new TrieNode()</span><br><span class="line">      &#125;</span><br><span class="line">      node.path +&#x3D; 1</span><br><span class="line">      node &#x3D; node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end +&#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 搜索字符串出现的次数</span><br><span class="line">  search(str) &#123;</span><br><span class="line">    if (!str) return</span><br><span class="line">    let node &#x3D; this.root</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      let index &#x3D; str[i].charCodeAt() - &#39;a&#39;.charCodeAt()</span><br><span class="line">      &#x2F;&#x2F; 如果索引对应没有值，代表没有需要搜素的字符串</span><br><span class="line">      if (!node.next[index]) &#123;</span><br><span class="line">        return 0</span><br><span class="line">      &#125;</span><br><span class="line">      node &#x3D; node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    return node.end</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 删除字符串</span><br><span class="line">  delete(str) &#123;</span><br><span class="line">    if (!this.search(str)) return</span><br><span class="line">    let node &#x3D; this.root</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      let index &#x3D; str[i].charCodeAt() - &#39;a&#39;.charCodeAt()</span><br><span class="line">      &#x2F;&#x2F; 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串</span><br><span class="line">      &#x2F;&#x2F; 已经一个，直接删除即可</span><br><span class="line">      if (--node.next[index].path &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        node.next[index] &#x3D; null</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      node &#x3D; node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end -&#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><blockquote>
<p>并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。<br>这个结构中有两个重要的操作，分别是：</p>
</blockquote>
<ul>
<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
<li>Union：将两个子集合并成同一个集合。</li>
</ul>
<h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class DisjointSet &#123;</span><br><span class="line">  &#x2F;&#x2F; 初始化样本</span><br><span class="line">  constructor(count) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化时，每个节点的父节点都是自己</span><br><span class="line">    this.parent &#x3D; new Array(count)</span><br><span class="line">    &#x2F;&#x2F; 用于记录树的深度，优化搜索复杂度</span><br><span class="line">    this.rank &#x3D; new Array(count)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">      this.parent[i] &#x3D; i</span><br><span class="line">      this.rank[i] &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  find(p) &#123;</span><br><span class="line">    &#x2F;&#x2F; 寻找当前节点的父节点是否为自己，不是的话表示还没找到</span><br><span class="line">    &#x2F;&#x2F; 开始进行路径压缩优化</span><br><span class="line">    &#x2F;&#x2F; 假设当前节点父节点为 A</span><br><span class="line">    &#x2F;&#x2F; 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的</span><br><span class="line">    while (p !&#x3D; this.parent[p]) &#123;</span><br><span class="line">      this.parent[p] &#x3D; this.parent[this.parent[p]]</span><br><span class="line">      p &#x3D; this.parent[p]</span><br><span class="line">    &#125;</span><br><span class="line">    return p</span><br><span class="line">  &#125;</span><br><span class="line">  isConnected(p, q) &#123;</span><br><span class="line">    return this.find(p) &#x3D;&#x3D;&#x3D; this.find(q)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 合并</span><br><span class="line">  union(p, q) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到两个数字的父节点</span><br><span class="line">    let i &#x3D; this.find(p)</span><br><span class="line">    let j &#x3D; this.find(q)</span><br><span class="line">    if (i &#x3D;&#x3D;&#x3D; j) return</span><br><span class="line">    &#x2F;&#x2F; 判断两棵树的深度，深度小的加到深度大的树下面</span><br><span class="line">    &#x2F;&#x2F; 如果两棵树深度相等，那就无所谓怎么加</span><br><span class="line">    if (this.rank[i] &lt; this.rank[j]) &#123;</span><br><span class="line">      this.parent[i] &#x3D; j</span><br><span class="line">    &#125; else if (this.rank[i] &gt; this.rank[j]) &#123;</span><br><span class="line">      this.parent[j] &#x3D; i</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.parent[i] &#x3D; j</span><br><span class="line">      this.rank[j] +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆通常是一个可以被看做一棵树的数组对象。<br>堆的实现通过构造<strong>二叉堆</strong>，实为二叉树的一种。这种数据结构具有以下性质。</p>
<ul>
<li>任意节点小于（或大于）它的所有子节点</li>
<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。<br>将根节点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。<br>优先队列也完全可以用堆来实现，操作是一模一样的。</li>
</ul>
<h2 id="实现大根堆"><a href="#实现大根堆" class="headerlink" title="实现大根堆"></a>实现大根堆</h2><p>堆的每个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。<br>堆有两个核心的操作，分别是 shiftUp 和 shiftDown 。前者用于添加元素，后者用于删除根节点。<br>shiftUp 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。<br>shiftDown 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class MaxHeap &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.heap &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    return this.heap.length</span><br><span class="line">  &#125;</span><br><span class="line">  empty() &#123;</span><br><span class="line">    return this.size() &#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  add(item) &#123;</span><br><span class="line">    this.heap.push(item)</span><br><span class="line">    this._shiftUp(this.size() - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  removeMax() &#123;</span><br><span class="line">    this._shiftDown(0)</span><br><span class="line">  &#125;</span><br><span class="line">  getParentIndex(k) &#123;</span><br><span class="line">    return parseInt((k - 1) &#x2F; 2)</span><br><span class="line">  &#125;</span><br><span class="line">  getLeftIndex(k) &#123;</span><br><span class="line">    return k * 2 + 1</span><br><span class="line">  &#125;</span><br><span class="line">  _shiftUp(k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果当前节点比父节点大，就交换</span><br><span class="line">    while (this.heap[k] &gt; this.heap[this.getParentIndex(k)]) &#123;</span><br><span class="line">      this._swap(k, this.getParentIndex(k))</span><br><span class="line">      &#x2F;&#x2F; 将索引变成父节点</span><br><span class="line">      k &#x3D; this.getParentIndex(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _shiftDown(k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 交换首位并删除末尾</span><br><span class="line">    this._swap(k, this.size() - 1)</span><br><span class="line">    this.heap.splice(this.size() - 1, 1)</span><br><span class="line">    &#x2F;&#x2F; 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span><br><span class="line">    while (this.getLeftIndex(k) &lt; this.size()) &#123;</span><br><span class="line">      let j &#x3D; this.getLeftIndex(k)</span><br><span class="line">      &#x2F;&#x2F; 判断是否有右孩子，并且右孩子是否大于左孩子</span><br><span class="line">      if (j + 1 &lt; this.size() &amp;&amp; this.heap[j + 1] &gt; this.heap[j]) j++</span><br><span class="line">      &#x2F;&#x2F; 判断父节点是否已经比子节点都大</span><br><span class="line">      if (this.heap[k] &gt;&#x3D; this.heap[j]) break</span><br><span class="line">      this._swap(k, j)</span><br><span class="line">      k &#x3D; j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _swap(left, right) &#123;</span><br><span class="line">    let rightValue &#x3D; this.heap[right]</span><br><span class="line">    this.heap[right] &#x3D; this.heap[left]</span><br><span class="line">    this.heap[left] &#x3D; rightValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 继承</title>
    <url>/2020/01/03/FE-guide-inherit/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在 ES5 中，我们可以使用如下方式解决继承的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">function Super() &#123;&#125;</span><br><span class="line">Super.prototype.getNumber &#x3D; function() &#123;</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub() &#123;&#125;</span><br><span class="line">let s &#x3D; new Sub()</span><br><span class="line">Sub.prototype &#x3D; Object.create(Super.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Sub,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上继承实现思路就是将子类的原型设置为父类的原型<br>在 <code>ES6</code> 中，我们可以通过 <code>class</code> 语法轻松解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class MyDate extends Date &#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">    return this.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myDate &#x3D; new MyDate()</span><br><span class="line">myDate.test()</span><br></pre></td></tr></table></figure>
<p>但是 <code>ES6</code> 不是所有浏览器都兼容，所以我们需要使用 <code>Babel</code> 来编译这段代码。</p>
<p>如果你使用编译过得代码调用 <code>myDate.test()</code> 你会惊奇地发现出现了报错</p>
<p>因为在 <code>JS</code> 底层有限制，如果不是由 <code>Date</code> 构造出来的实例的话，是不能调用 <code>Date</code> 里的函数的。所以这也侧面的说明了：<strong><em>ES6 中的 class 继承与 ES5 中的一般继承写法是不同的</em></strong>。</p>
<p>既然底层限制了实例必须由 <code>Date</code> 构造出来，那么我们可以改变下思路实现继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function MyData() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MyData.prototype.test &#x3D; function () &#123;</span><br><span class="line">  return this.getTime()</span><br><span class="line">&#125;</span><br><span class="line">let d &#x3D; new Date() &#x2F;&#x2F; 父类实例</span><br><span class="line">Object.setPrototypeOf(d, MyData.prototype)</span><br><span class="line">Object.setPrototypeOf(MyData.prototype, Date.prototype)</span><br></pre></td></tr></table></figure>
<p>以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 <code>__proto__</code> 转而连接到子类的 <code>prototype</code> =&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</p>
<p>通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 数据类型、类型判断、类型转换、类型比较</title>
    <url>/2020/01/02/FE-guide-dataType/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>温故而知新，可以为师矣。<br>           ———————— 论语</p>
</blockquote>
<p>这篇文章主要是把我看过的书中的知识点，还有其他人整理的面试题进行整理，巩固自己的前端开发理论知识，希望其他看到这篇文章的人也能有所帮助。</p>
<a id="more"></a>

<h1 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h1><blockquote>
<p>当前市场中，如何区分一个好一点的前端开发和一般的前端开发，主要看的就是js能力的差距，好的前端开发，JS玩的转，不仅仅是框架玩的好，还要JS的基础扎实，只有基础与新技术都玩的6的前端开发才是好前端。</p>
</blockquote>
<p>上面这句话不是什么名人或者某位知名前端大拿说的，这是我在公司这几年面试招聘的过程中真真切切总结感受的。<br>所以可以说得JS者得高级前端，所以下面也主要是写JS的相关知识点。</p>
<h2 id="JavaScript内置数据类型-—-数据类型"><a href="#JavaScript内置数据类型-—-数据类型" class="headerlink" title="JavaScript内置数据类型 — 数据类型"></a>JavaScript内置数据类型 — 数据类型</h2><p>无论学什么语言最重要最基础的就是数据类型，《JavaScript权威指南》这本书中详细的介绍了JS中的数据类型，下面总结一下。</p>
<p>JavaScript中数据类型分为两大类共七种内置数据类型，其一是6种<strong><em><code>基本类型</code></em></strong>，其二是1种<strong><em><code>引用类型</code></em></strong>，我发现在面试过程中好多面试者都不会先说有两大类，而是会直接蹦出数字类型、字符串类型。。。对象、数组也会被并排放在一起，这其实不是个掌握知识点的好方法，应该先把数据类型分成上面说的<strong><em><code>基本类型</code></em></strong>、<strong><em><code>引用类型</code></em></strong>这样两个大类之后，再看看这两大类中有什么其他的子类型，在记忆其他子类型之前我觉得应该先了解一下什么是<strong><em><code>基本类型</code></em></strong>和<strong><em><code>引用类型</code></em></strong>，实际上基本类型和引用类型的主要区别是存储的区别，基本类型在栈中，而引用类型的话，引用数据的地址存储在栈中，而对象本身是存储在堆中，引用的数据地址是个16进制的数据值，它就像一把钥匙让你能够找到宝藏在什么地方。这就是基本数据类型和引用类型的区别了。</p>
<p>那么如何记住有哪些基本数据类型和引用数据类型呢，实际上只要记住了6个基本数据类型，其他的都是引用数据类型，而所有的引用数据类型的祖宗都是Object，所以引用数据类型实际上只有Object一个，那么像是Array等其他子类型，都是Object的孩子，不跟Object在一个级别上。</p>
<p>基本数据类型有哪些呢？其实挺好记的，数字，字符串，这两个一个像温柔的文学少女（string），一个像有点精于算计的男生（number），还有一个布尔类型（boolen）他像是班级里正义感爆棚的人，只论对错；另外还有个差生，没头脑似的未定义（Undefined）还有一个失了忆记不起来自己是谁的空（Null），最后还有一个新加入的插班生，总是带着口罩的标志符号（Symbol），这些人构成了这个班级的所有学生，也就是全部的基本类型，那么引用类型的对象Object呢就像及了漂亮爱化妆的班主任老师，有好多副面孔。不知道大家有没有看过一个动漫叫做《黑塔利亚》，他就是把国家都拟人化了，有了各自的性格，我很喜欢看，我觉得这些数据类型也各有各的特点，像这些国家一样，好了脑洞有点挖深了，有人会说我不就是这么几个简单的数据类型嘛，硬记下来不就好了，但是知识总有你硬记不下来的时候，最好的方法也是速记领域最为常用的方法，就是把你不熟悉的知识与你感兴趣的画面或者既往的知识串联起来，这样就能达到很好的记忆，如果你不喜欢动漫（怎么会有不喜欢动漫的人！！！），可以试试用其他的方法记，当然你如果硬要死记硬背那我也没办法，我继续开我的脑洞。<br>如果你是学过Java开发的同学（如果是计算机专业出来的，应该都或多或少学过，非计算机专业的我也不知道说啥了。。），数字在Java中是分成 byte/short/int/long 的，但是在Js中没有那么多，就一个Number，它是浮点类型，基于 IEEE 754标准实现，刚才我不是说了Number是个精于算计的男生，精于算计就是说他分毫不差，这样浮点型就很好的记了下来，这个754的标准可以不记，如果非要记的话，你可以记成他是自称IEEE 754团体的成员。最后Number身后还跟着一个小弟，叫做NaN，他虽然是Number的小弟，但他总是说话不算数，自己说过什么都不承认。所以NaN!=NaN。<br>老师是个爱化妆的老师，而这些学生也不是普通的学生，在学校他们是老老实实的基本类型，放了学之后一打扮，他们就各有了其他的能力，这个过程叫做装箱，具体的后面再说。（好了快回到现实吧你！）</p>
<p>如果基础数据是字面量类型，那么他们就像是在上课的学生，只是学生而已，而当他们调用方法时，他们就成了下课后各种技能都有的新新人类，这个过程有时候是显示的，就像是有些学生喜欢大声嚷嚷，而更多的是你不自觉中就用到了装箱操作，是Js引擎提供的能力，就像是有些闷骚的学生一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">let aNumber &#x3D; 111 &#x2F;&#x2F; 这只是字面量，不是 number 类型</span><br><span class="line">aNumber.toString() &#x2F;&#x2F; 装箱操作自动转化成数字对象，使用时候才会转换为对象类型</span><br></pre></td></tr></table></figure>
<p>对象有个深浅拷贝的知识点必须要会，对象因为是引用数据类型，在栈中存储的是地址，当用另一个变量接收了之前的变量，那么就好像把钥匙复制了一把，两把钥匙开的还是同一个门，而深拷贝呢就像是照着原来的样板间又造了一个一模一样的房间，这两个房间长得一样，但就是两个房间，钥匙自然也是不一样的，所以呢，当往房间里搬家具的时候，浅拷贝搬进去的是一个房间，所以两把钥匙打开之后看到的都是多了家具，而深拷贝的话，我只是往样板间搬了家具，所以照着装修的房间里是不可能有的，这就是浅拷贝原数据会受影响，而深拷贝不会。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123; name: &#39;FE&#39; &#125;</span><br><span class="line">let b &#x3D; a</span><br><span class="line">b.name &#x3D; &#39;EF&#39;</span><br><span class="line">console.log(a.name) &#x2F;&#x2F; EF 浅拷贝原数据会受影响</span><br></pre></td></tr></table></figure>
<h2 id="内置数据类型检测-Typeof-—-类型判断"><a href="#内置数据类型检测-Typeof-—-类型判断" class="headerlink" title="内置数据类型检测 Typeof — 类型判断"></a>内置数据类型检测 Typeof — 类型判断</h2><blockquote>
<p>typeof 对于基本类型，除了 null 都可以显示正确的类型</p>
</blockquote>
<p>typeof 就像是学校的教导主任一样，他有着一双火眼金睛，不管是哪个同学，穿了什么样的衣服，他一问就能问出来这个学生是谁，大家都怕他，但是Null因为失忆了，他也不知道教导主任是谁，所以typeof就拿他也没办法，因为他不怕教导主任，教导主任甚至会以为他是老师呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">typeof 1 &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">typeof undefined &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">typeof true &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">typeof Symbol() &#x2F;&#x2F; &#39;symbol&#39;</span><br><span class="line">typeof b &#x2F;&#x2F; b 没有声明，但是还会显示 undefined</span><br><span class="line"></span><br><span class="line">typeof null &#x2F;&#x2F; &#39;object&#39; 这是JS中的bug</span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof 对于对象，除了函数都会显示 object</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">typeof [] &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof console.log &#x2F;&#x2F; &#39;function&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识扩展：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p>
</blockquote>
<p><strong><em>如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。</em></strong></p>
<blockquote>
<p>小知识扩展</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a</span><br><span class="line">&#x2F;&#x2F; 我们也可以这样判断 undefined</span><br><span class="line">a &#x3D;&#x3D;&#x3D; undefined</span><br><span class="line">&#x2F;&#x2F; 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span><br><span class="line">let undefined &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; 这样判断就会出错</span><br><span class="line">&#x2F;&#x2F; 所以可以用下面的方式来判断，并且代码量更少</span><br><span class="line">&#x2F;&#x2F; 因为 void 后面随便跟上一个组成表达式</span><br><span class="line">&#x2F;&#x2F; 返回就是 undefined</span><br><span class="line">a &#x3D;&#x3D;&#x3D; void 0</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h3><p>一句话可以概括</p>
<blockquote>
<p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 true，包括所有对象。</p>
</blockquote>
<p>从上面这段话可以看出来，<code>undefined</code>、<code>null</code> 是基本类型之二，而<code>false</code>是布尔类型的假值，<code>NaN</code>是数字类型的无效值，<code>&#39;&#39;</code>是字符串类型的空值，而<code>0</code>， <code>-0</code>都是数字类型的零值，可以看到，除了<code>0</code>、<code>-0</code>有些特殊，除了插班生<code>Symbol</code>，剩下的都是基本类型的假值，由此实际上就很好记了，有时候数字这个容易忘，但是记住“非0既真”这句话就好了。</p>
<h3 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h3><p>对象在转换基本类型时，首先是先会调用ToPrimitive（原始类型），如果有hint参数调用对应的的类型方法，如果没有那默认先会调用 valueOf 然后调用 toString。如果返回了基本类型，结束。如果都没返回，那么Error<strong><em>但是注意这两个方法你是可以重写的。</em></strong></p>
<blockquote>
<p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。（来自MDN的解释）<br>需要解释的关键机制是ToPrimitive函数。该函数是将任意值转换为相应的基本类型值。如果输入的就是一个基本类型值，那么将不做修改，被直接返回。如果值是非基本类型值，它将调用内部方法 [[DefaultValue]] 为对象找到一个默认值。<br>[[DefaultValue]]是每一个对象的内部属性。该方法需要一个可选的参数hint，值是Number或String。如果没有提供hint，则默认为Number(除非该对象是Date，在这种情况下默认为String)。然后将调用toString和valueOf去寻找基本类型值。在这里hint就起到作用了。如果hint参数值为Number，valueOf将先被调用，如果hint是String的话，则toString被先调用。<br>[[DefaultValue]] 返回的值一定是基本类型值。如果不是，一个TypeError 将会被抛出。这就意味着为了在这种情况下有意义，toString和valueOf应该返回基本类型值。</p>
</blockquote>
<h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><blockquote>
<p>只有当<strong><em>加法</em></strong>运算时，其中一方是<strong><em>字符串类型</em></strong>，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。<strong><em>并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">1 + &#39;1&#39; &#x2F;&#x2F; &#39;11&#39; 这里会是面试陷阱</span><br><span class="line">2 * &#39;2&#39; &#x2F;&#x2F; 4 </span><br><span class="line">[1, 2] + [2, 1] &#x2F;&#x2F; &#39;1,22,1&#39;</span><br><span class="line">&#x2F;&#x2F; [1, 2].toString() -&gt; &#39;1,2&#39;</span><br><span class="line">&#x2F;&#x2F; [2, 1].toString() -&gt; &#39;2,1&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;1,2&#39; + &#39;2,1&#39; &#x3D; &#39;1,22,1&#39;</span><br></pre></td></tr></table></figure>
<p><strong>*面试陷阱题之 ++ *</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 问表达式 &#39;a&#39; + + &#39;b&#39; 返回结果是什么？</span><br><span class="line">&#x2F;&#x2F; 答案是 &#39;aNaN&#39;</span><br><span class="line">&#39;a&#39; + + &#39;b&#39; -&gt; &#x2F;&#x2F; 一元运算符优先级高</span><br><span class="line">&#39;a&#39; + (+ &#39;b&#39;) -&gt; &#x2F;&#x2F; +&#39;b&#39;转数字类型，非有效结果是NaN</span><br><span class="line">&#39;a&#39; + NaN.toString() -&gt; &#x2F;&#x2F; NaN调用toString（）成字符串&#39;NaN&#39;</span><br><span class="line">&#39;aNaN&#39; &#x2F;&#x2F; 字符串接到一起后&#39;aNaN&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类似题 &#39;1&#39; + + &#39;4&#39; 返回结果是什么 </span><br><span class="line">&#x2F;&#x2F; 其实就是&#39;4&#39; -&gt; 4 -&gt; &#39;4&#39; 最后还是&#39;14&#39;</span><br></pre></td></tr></table></figure>

<h2 id="操作符-—-类型比较"><a href="#操作符-—-类型比较" class="headerlink" title="== 操作符 — 类型比较"></a>== 操作符 — 类型比较</h2><blockquote>
<p>相等运算符的运算规则如下：<br>1、如果两个值类型相同，进行 === 比较。(这个非常好理解，就不多说了)<br>（1）数字比大小<br>（2）字符串就通过 unicode 字符索引来比较<br>2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：<br>（1）如果一个是null、一个是undefined，那么[相等]。 // 这个有点特殊需要单独记<br>（2）如果任一值是字符串，另一个值是数值，在比较相等性之前先将字符串转换为数值；即是调用Number()函数。<br>（3）如果任一值时布尔值，则在比较相等性之前先将其转换为数值，即是调用Number()函数。<br>（4）如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 （js核心内置类ToPrimitive，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。）</p>
</blockquote>
<p>1不说，2（1）的话单独记，其他基本类型转数字比较，引用性数据类型调用ToPrimitive转换成基本数据类型</p>
<p>首先还是一道面试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; [] &#x3D;&#x3D; ![] 结果是什么</span><br><span class="line">[] &#x3D;&#x3D; ![] &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>为什么呢？我们来解析一下，</p>
<ol>
<li>首先我们看一下右侧，<code>![]</code>肯定是要先转换成boolen类型了吧，那么<code>[]</code>的布尔类型是什么呢，上面转换布尔的时候我们说过，除了那五个基本类型的假值以及正负0之外，都是真值，所以<code>[]</code> -&gt; <code>true</code> <code>![]</code> -&gt; <code>false</code></li>
<li><code>ToPrimitive(false)</code>-&gt;<code>0</code>右边的值得出了数值类型的原始值</li>
<li>看左边<code>ToPrimitive([])</code>-&gt;<code>[]</code>.toString()-&gt;<code>&#39;&#39;</code></li>
<li><code>Number(&#39;&#39;)</code>-&gt;<code>0</code></li>
<li>比较左右 <code>0 == 0</code> -&gt; <code>true</code></li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>到这里JS的内置数据类型及类型的转换和比较就讲完了，相信大家看过以后一定会记得住的<br>PS：突然好像学画漫画，《JS数据结构们》，一定大火，哈哈哈😂</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 继承类型</title>
    <url>/2020/01/13/FE-guide-inherit2/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<p>继承的操作需要有一个父类，这里使用构造函数外加原型来创建一个：<br>有下面两个类，下面实现 Child 继承 Father：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'prople'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'吃东西啦'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.color = <span class="string">'black'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原型继承（认贼作父）"><a href="#原型继承（认贼作父）" class="headerlink" title="原型继承（认贼作父）"></a>原型继承（认贼作父）</h2><blockquote>
<p><strong><em>关键点</em></strong>：子类原型等于父类的实例 <code>Child.prototype = new Person()</code>（将父类指向子类的原型）。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Father();</span><br></pre></td></tr></table></figure>

<p>特点：<br>实例可继承的属性有：</p>
<ul>
<li>实例的构造函数的属性</li>
<li>父类构造函数的属性</li>
<li>父类原型上的属性<br><strong><em>新实例不会继承父类实例的属性</em></strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>新实例无法向父类构造函数传参</li>
<li>继承单一</li>
<li>所有新实例都会共享父类实例的属性。— 原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改</li>
</ul>
<h2 id="构造继承（借腹生子）"><a href="#构造继承（借腹生子）" class="headerlink" title="构造继承（借腹生子）"></a>构造继承（借腹生子）</h2><blockquote>
<p>在子类构造函数中调用父类构造函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>关键点</em></strong>：用 call 或 apply 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））Person.call(this, ‘reng’)<br>特点：</p>
<ul>
<li>只继承了父类构造函数的属性，没有继承父类原型的属性</li>
<li>解决了原型链继承的注意事项（缺点）1，2，3</li>
<li>可以继承多个构造函数的属性（call 可以多个）</li>
<li>在子实例中可以向父实例传参<br>缺点：</li>
<li>只能继承父类构造函数的属性</li>
<li>无法实现构造函数的复用。（每次用每次都要重新调用）</li>
<li>每个新实例都有构造函数的副本，臃肿<br>（不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。）</li>
</ul>
<h2 id="组合继承（原型继承-构造继承）"><a href="#组合继承（原型继承-构造继承）" class="headerlink" title="组合继承（原型继承+构造继承）"></a>组合继承（原型继承+构造继承）</h2><blockquote>
<p>使用构造继承继承父类参数，使用原型继承继承父类函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造继承</span></span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = Father.prototype; <span class="comment">// Child.prototype = new Person(); // 原型继承</span></span><br></pre></td></tr></table></figure>

<p><strong><em>关键点</em></strong>：结合了两种模式的优点–向父类传参（call）和复用（prototype）<br>特点：</p>
<ul>
<li>可以继承父类原型上的属性，可以传参，可复用</li>
<li>每个新实例引入的构造函数属性是私有的</li>
</ul>
<p>缺点：</p>
<ul>
<li>父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</li>
<li>调用了两次父类的构造函数（耗内存）</li>
<li>子类的构造函数会代替原型上的那个父类构造函数（call 相当于拿到了父类构造函数的副本）</li>
</ul>
<h2 id="原型式继承-复制降级"><a href="#原型式继承-复制降级" class="headerlink" title="原型式继承(复制降级)"></a>原型式继承(复制降级)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先封装一个函数容器，用来承载继承的原型和输出对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 寄生</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="keyword">var</span> child = create(father);</span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(child.job); <span class="comment">// frontend</span></span><br></pre></td></tr></table></figure>

<p><strong><em>关键点</em></strong>：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了可以随意增添属性的实例或对象。Object.create()就是这个原理。</p>
<p>特点：</p>
<ul>
<li>类似于复制一个对象，用函数来包装</li>
</ul>
<p>注意事项：</p>
<ul>
<li>所有的实例都会继承原型上的属性</li>
<li>无法实现复用。（新实例属性都是后面添加的）<br><code>Object.create()</code>方法规范了原型式继承。这个方法接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传一个参数的时候</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Father());</span><br><span class="line"><span class="built_in">console</span>.log(child.job); <span class="comment">// frontend</span></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 传两个参数的时候</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Father(), &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">'come on'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">child.sayHello(); <span class="comment">// Hello come on</span></span><br></pre></td></tr></table></figure>

<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>它跟<code>组合继承</code>一样，都比较常用。<br><strong><em>寄生</em></strong>：在函数内返回对象然后调用<br><strong><em>组合</em></strong>：</p>
<ul>
<li>函数的原型等于另一个实例</li>
<li>在函数中用 apply 或 call 引入另一个构造函数，可传参</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寄生</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// object是F实例的另一种表示方法</span></span><br><span class="line"><span class="keyword">var</span> obj = create(Father.prototype);</span><br><span class="line"><span class="comment">// obj实例（F实例）的原型继承了父类函数的原型</span></span><br><span class="line"><span class="comment">// 上述更像是原型链继承，只不过只继承了原型属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">100</span>;</span><br><span class="line">  Father.call(<span class="keyword">this</span>); <span class="comment">// 这个继承了父类构造函数的属性</span></span><br><span class="line">&#125; <span class="comment">// 解决了组合式两次调用构造函数属性的特点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点</span></span><br><span class="line">Child.prototype = obj; <span class="comment">// 原型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.constructor); <span class="comment">// Father</span></span><br><span class="line">obj.constructor = Child; <span class="comment">// 一定要修复实例</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.constructor); <span class="comment">// Child</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="comment">// Child实例就继承了构造函数属性，父类实例，object的函数属性</span></span><br><span class="line"><span class="built_in">console</span>.log(child.job); <span class="comment">// frontend</span></span><br><span class="line"><span class="built_in">console</span>.log(child <span class="keyword">instanceof</span> Father); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong><em>重点</em></strong>：修复了组合继承的问题</p>
<p>在上面的问题中，你可能发现了这么一个注释<code>obj.constructor = Sub; // 一定要修复实例。</code>为什么要修正子类的构造函数的指向呢？</p>
<p>因为在不修正这个指向的时候，在获取构造函数返回的时候，在调用同名属性或方法取值上可能造成混乱。比如下面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Car.prototype.orderOneLikeThis = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Clone producing function</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor();</span><br><span class="line">&#125;;</span><br><span class="line">Car.prototype.advertise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am a generic car.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BMW</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">BMW.prototype = <span class="built_in">Object</span>.create(Car.prototype);</span><br><span class="line">BMW.prototype.constructor = BMW; <span class="comment">// Resetting the constructor property</span></span><br><span class="line">BMW.prototype.advertise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am BMW with lots of uber features.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x5 = <span class="keyword">new</span> BMW();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myNewToy = x5.orderOneLikeThis();</span><br><span class="line"></span><br><span class="line">myNewToy.advertise(); <span class="comment">// =&gt; "I am BMW ..." if `BMW.prototype.constructor = BMW;` is not</span></span><br><span class="line"><span class="comment">// commented; "I am a generic car." otherwise.</span></span><br></pre></td></tr></table></figure>

<p><code>object.create</code> 在组合继承的基础上，子类继承一个由父类原型生成的空对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Father.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="inherits-函数-—-Nodejs-util-inherits-函数"><a href="#inherits-函数-—-Nodejs-util-inherits-函数" class="headerlink" title="inherits 函数 — Nodejs util.inherits 函数"></a>inherits 函数 — Nodejs util.inherits 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span> = <span class="title">function</span>(<span class="params">ctor, superCtor</span>) </span>&#123;</span><br><span class="line">  ctor.super_ = superCtor; <span class="comment">// super_属性是子类继承父类时构造函数要写入的一个属性值.</span></span><br><span class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">      value: ctor,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在上面的代码中 ctor 想要继承 superCtor ,我们姑且把 ctor 称作子类, superCtor 称作父类.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">inherits(Child, Father);</span><br><span class="line"></span><br><span class="line">Child.prototype.fun = ...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- instanceof</title>
    <url>/2020/01/02/FE-guide-instanceof/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h1><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。<br>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<p>判断 <code>Object</code> 的 <code>prototype</code> 是否在 <code>a</code> 的原型链上。</p>
<p>我们也可以试着实现一下 <code>instanceof</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123; <span class="comment">// left 表示左表达式，right 表示右表达式</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype <span class="comment">// 获得类型的原型</span></span><br><span class="line">    left = left.__proto__ <span class="comment">// 获得对象的原型</span></span><br><span class="line">		</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    	<span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    	<span class="keyword">if</span> (prototype === left)</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    	left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- new</title>
    <url>/2020/01/02/FE-guide-new/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="new-一个对象的过程"><a href="#new-一个对象的过程" class="headerlink" title="new 一个对象的过程"></a><code>new</code> 一个对象的过程</h1><ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ol>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function create() &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个空的对象</span><br><span class="line">    let obj &#x3D; new Object()</span><br><span class="line">    &#x2F;&#x2F; 获得构造函数</span><br><span class="line">    let Con &#x3D; [].shift.call(arguments)</span><br><span class="line">    &#x2F;&#x2F; 链接到原型</span><br><span class="line">    obj.__proto__ &#x3D; Con.prototype</span><br><span class="line">    &#x2F;&#x2F; 绑定 this，执行构造函数</span><br><span class="line">    let result &#x3D; Con.apply(obj, arguments)</span><br><span class="line">    &#x2F;&#x2F; 确保 new 出来的是个对象</span><br><span class="line">    return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125; &#x2F;&#x2F; function 就是个语法糖，内部等同于 new Function()</span><br><span class="line">let a &#x3D; &#123; b: 1 &#125; &#x2F;&#x2F; 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure>
<p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;1&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;2&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Foo.getName();   &#x2F;&#x2F; -&gt; 1</span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; -&gt; 2</span><br></pre></td></tr></table></figure>

<p>从上图可以看出，<code>new Foo()</code> 的优先级大于 <code>new Foo</code> ，所以对于上述代码来说可以这样划分执行顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">new (Foo.getName());</span><br><span class="line">(new Foo()).getName();</span><br></pre></td></tr></table></figure>

<ul>
<li>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ，所以结果为 1；</li>
<li>对于后者来说，先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 原型</title>
    <url>/2020/01/02/FE-guide-prototype/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p><img src="https://i.loli.net/2020/01/02/7ov8I4YDiBkjJyr.png" alt="yuanxing.png"><br>每个<strong><em>函数</em></strong>都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向<code>原型对象</code>，简称<code>原型</code>，<code>prototype</code>原型对象里的<code>constructor</code>指向构造函数本身。<br>每个<strong><em>对象</em></strong>都有 <code>__proto__</code> 属性，指向了创建该对象的<strong><em>构造函数的原型</em></strong>。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。<br>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了<code>原型链</code>。</p>
<a id="more"></a>
<p><img src="https://pic2.zhimg.com/v2-e722d5325f7d4215169f1d04296e0f89_r.jpg" alt="总结"></p>
<h1 id="prototype-原型对象"><a href="#prototype-原型对象" class="headerlink" title="prototype 原型对象"></a><code>prototype</code> 原型对象</h1><h2 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h2><p>每个函数都具有 <code>prototype</code> 属性，它被默认成一个对象，即原型对象<br>首先来介绍下 <code>prototype</code> 属性。这是一个<code>显式</code>原型属性，只有<code>函数</code>才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">let fun &#x3D; Function.prototype.bind()</span><br></pre></td></tr></table></figure>
<p>如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的。</p>
<h2 id="prototype-如何产生的"><a href="#prototype-如何产生的" class="headerlink" title="prototype 如何产生的"></a><code>prototype</code> 如何产生的</h2><p>当我们声明一个函数时，这个属性就被自动创建了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>并且这个属性的值是一个对象（也就是<code>原型</code>），只有一个属性 <code>constructor</code><br><code>constructor</code> 对应着构造函数，也就是 <code>Foo</code>。</p>
<h2 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h2><p>当对象使用属性时，先在自身找，有就直接用，没有就沿着<strong>proto</strong>这条链往上找，直到 Object 原型的位置，有就返回相应的值，没有就返回 underfined。</p>
<h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a><code>constructor</code> 构造函数</h2><h3 id="什么是构造函数？"><a href="#什么是构造函数？" class="headerlink" title="什么是构造函数？"></a>什么是构造函数？</h3><p>任何一个函数，只要被 new 操作符使用，就可以是一个构造函数（构造函数建议以大写开头）<br>另外，在 JavaScript 的内置对象中，所有的函数对象都是 Function 构造函数的实例，比如：Object、Array等</p>
<p><code>constructor</code> 是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）。</p>
<p>那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：</p>
<ol>
<li>让实例对象知道是什么函数构造了它</li>
<li>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 <code>xx.constructor.method</code> 来扩展</li>
</ol>
<h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h2><p>这是每个对象都有的<code>隐式原型属性</code>，指向了创建该对象的<code>构造函数</code>的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</p>
<p>因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 <code>_proto_</code> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。</p>
<h3 id="实例对象的-proto-如何产生的"><a href="#实例对象的-proto-如何产生的" class="headerlink" title="实例对象的 _proto_ 如何产生的"></a>实例对象的 <code>_proto_</code> 如何产生的</h3><p>从上图可知，当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>_proto_</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 这个函数是 Function 的实例对象</span></span><br><span class="line"><span class="comment">// function 就是一个语法糖</span></span><br><span class="line"><span class="comment">// 内部调用了 new Function(...)</span></span><br></pre></td></tr></table></figure>
<p>所以可以说，在 <code>new</code> 的过程中，新对象被添加了 <code>_proto_</code> 并且链接到构造函数的原型上。</p>
<h3 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a><code>new</code> 的过程</h3><ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ol>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"> name </span>)</span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.name = name; </span><br><span class="line">&#125;; </span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// 从 Object.prototype 上克隆一个空的对象</span></span><br><span class="line">	<span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>) <span class="comment">// 获取外部传入的构造器，此例是 Person </span></span><br><span class="line">	obj.__proto__ = Con.prototype	<span class="comment">// 指向正确的原型,链接到原型</span></span><br><span class="line">	<span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>) <span class="comment">// 绑定 this，执行构造函数，借用外部传入的构造器给 obj 设置属性</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create(Person,<span class="string">'lixg'</span>)</span><br></pre></td></tr></table></figure>
<p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code> ，但是你使用字面量的方式就没这个问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function 就是个语法糖,内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; <span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure>

<h2 id="Function-proto-Function-prototype"><a href="#Function-proto-Function-prototype" class="headerlink" title="Function.proto === Function.prototype"></a>Function.<strong>proto</strong> === Function.prototype</h2><p>对于对象来说，<code>xx.__proto__.contrcutor</code> 是该对象的构造函数，但是在图中我们可以发现 <code>Function.__proto__</code> === <code>Function.prototype</code>，难道这代表着 <code>Function</code> 自己产生了自己?</p>
<p>答案肯定是否认的，要说明这个问题我们先从 <code>Object</code> 说起。</p>
<p>从图中我们可以发现，所有对象都可以通过原型链最终找到 <code>Object.prototype</code> ，虽然 <code>Object.prototype</code> 也是一个对象，但是这个对象却不是 <code>Object</code> 创造的，而是引擎自己创建了 <code>Object.prototype</code> 。所以可以这样说，所有实例都是对象，但是对象不一定都是实例。</p>
<p>接下来我们来看 <code>Function.prototype</code> 这个特殊的对象，如果你在浏览器将这个对象打印出来，会发现这个对象其实是一个函数。</p>
<p>我们知道函数都是通过 <code>new Function()</code> 生成的，难道 <code>Function.prototype</code> 也是通过 <code>new Function()</code> 产生的吗？答案也是否定的，这个函数也是引擎自己创建的。首先引擎创建了 <code>Object.prototype</code> ，然后创建了 <code>Function.prototype</code> ，并且通过 <code>__proto__</code> 将两者联系了起来。这里也很好的解释了上面的一个问题，为什么 <code>let fun = Function.prototype.bind()</code> 没有 prototype 属性。因为 <code>Function.prototype</code> 是引擎创建出来的对象，引擎认为不需要给这个对象添加 <code>prototype</code> 属性。</p>
<p><strong><em>所以我们又可以得出一个结论，不是所有函数都是 <code>new Function()</code> 产生的。</em></strong><br>有了 <code>Function.prototype</code> 以后才有了 <code>function Function()</code> ，然后其他的构造函数都是 <code>function Function()</code> 生成的。</p>
<p>现在可以来解释 <code>Function.__proto__ === Function.prototype</code> 这个问题了。因为先有的 <code>Function.prototype</code> 以后才有的 <code>function Function()</code> ，所以也就不存在鸡生蛋蛋生鸡的悖论问题了。对于为什么 <code>Function.__proto__</code> 会等于 <code>Function.prototype</code> ，个人的理解是：其他所有的构造函数都可以通过原型链找到 <code>Function.prototype</code> ，并且 <code>function Function()</code> 本质也是一个函数，为了不产生混乱就将 <code>function Function()</code> 的 <code>__proto__</code> 联系到了 <code>Function.prototype</code> 上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li>
<li>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链<br><img src="https://img2018.cnblogs.com/blog/1731684/201907/1731684-20190704181143591-516719297.png" alt="总结"></li>
</ul>
<h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2><p><code>ES</code> 把对象定义为：“无序属性的集合，其属性可以包含基本值，对象和函数”。<br>严格来讲，这就相当于说对象是一组没有特定顺序的值。ES 中的构造函数可以用来创建特定类型的对象，用来在创建对象时初始化对象。它的特点是，一般为大写字母开头，使用 <code>new</code> 操作符来实例化对象，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">"Kevin"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Kevin</span></span><br></pre></td></tr></table></figure>

<p><code>Person</code> 就是构造函数， <code>person</code> 就是对象。对于对象而言，每个 <code>JS</code> 对象一定对应一个原型对象，并从原型对象继承属性和方法。对象 <code>__proto__</code> 属性的值就是它所对应的原型对象。对象的 <code>__proto__</code> 指向自己构造函数的 <code>prototype</code> 。所以对象的原型链就是 <code>obj.__proto__.proto__....</code> 。对于函数而言，只有函数才有 <code>prototype</code> 属性， <code>Person.prototype</code>  是一个对象，并且有两个属性， 一个是 <code>constructor</code> 指向其构造函数 <code>Person</code> ， 一个是 <code>__proto__</code>  属性：是一个对象，指向上一层的原型。原型链的尽头是 <code>Object.prototype</code> 。所有对象均从 <code>Object.prototype</code> 继承属性。<code>Function.prototype</code> 和 <code>Function.__proto__</code> 为同一对象。<code>Object/Array/String</code> 等等构造函数本质上和 <code>Function</code> 一样，均继承于 <code>Function.prototype</code> 。<code>Function.prototype</code> 直接继承 <code>Object.prototype</code> 。这里的 <code>Object</code> 和 <code>Function</code> 有点鸡和蛋的问题，总结：先有 <code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。属性查找时，先在对象自己上找，找不到才会一步步根据原型链往上找。<br><img src="https://pic2.zhimg.com/v2-2e8ec703287854d174483ba5f9f937cf_1200x500.jpg" alt="继承"></p>
<h2 id="关联阅读"><a href="#关联阅读" class="headerlink" title="关联阅读"></a>关联阅读</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a><br><a href="https://zhuanlan.zhihu.com/p/35790971" target="_blank" rel="noopener">说说原型（prototype）、原型链和原型继承</a></p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://lixuguang.github.io/2020/01/13/FE-guide-inherit2/">继承</a></p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 浏览器存储</title>
    <url>/2020/01/03/FE-guide-store/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="cookie，localStorage，sessionStorage，indexDB"><a href="#cookie，localStorage，sessionStorage，indexDB" class="headerlink" title="cookie，localStorage，sessionStorage，indexDB"></a>cookie，localStorage，sessionStorage，indexDB</h1><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td>无限制</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<p>从上表可以看到， <code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p>
<p>对于 <code>cookie</code> ，我们还需要注意安全性。<br>| 属性      | 作用                                                           |<br>| ——— | ————————————————————– |<br>| value     | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |<br>| http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击                         |<br>| secure    | 只能在协议为 HTTPS 的请求中携带                                |<br>| same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击          |</p>
<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><blockquote>
<p>Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。</p>
</blockquote>
<p>目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(&#39;sw.js&#39;)</span><br><span class="line">    .then(function(registration) &#123;</span><br><span class="line">      console.log(&#39;service worker 注册成功&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(&#39;servcie worker 注册失败&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; sw.js</span><br><span class="line">&#x2F;&#x2F; 监听 &#96;install&#96; 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(&#39;install&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(&#39;my-cache&#39;).then(function(cache) &#123;</span><br><span class="line">      return cache.addAll([&#39;.&#x2F;index.html&#39;, &#39;.&#x2F;index.js&#39;])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拦截所有请求事件</span><br><span class="line">&#x2F;&#x2F; 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(&#39;fetch&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#39;fetch source&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了<br>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p>
<p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 网络安全</title>
    <url>/2020/01/22/FE-guide-safe/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络安全是前端不可忽略的一个部分，可惜的是之前我都忽略了，最近发现网络安全已经变得日益重要，所以特别整理一篇文章说说网络安全相关的内容。</p>
<span id="more"></span>
<h2 id="XSS（Cross-site-scripting）跨站脚本攻击"><a href="#XSS（Cross-site-scripting）跨站脚本攻击" class="headerlink" title="XSS（Cross-site scripting）跨站脚本攻击"></a>XSS（Cross-site scripting）跨站脚本攻击</h2><p>跨站脚本攻击是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。</p>
<p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<p>XSS攻击分成两类：</p>
<ul>
<li>来自内部的攻击<ul>
<li>主要指的是利用程序自身的漏洞，构造跨站语句</li>
</ul>
</li>
<li>来自外部的攻击<ul>
<li>主要指自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其他技术，如社会工程学等，欺骗目标服务器的管理员打开。</li>
</ul>
</li>
</ul>
<p>XSS分为：<strong>存储型</strong>和<strong>反射型</strong></p>
<ul>
<li>存储型XSS：存储型XSS，持久化，代码是存储在服务其中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。</li>
<li>反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</li>
</ul>
<h3 id="攻击手段和目的"><a href="#攻击手段和目的" class="headerlink" title="攻击手段和目的"></a>攻击手段和目的</h3><p>攻击者使被攻击者在浏览器中执行脚本后，如果需要收集来自被攻击者的数据（如cookie或其他敏感信息），可以自行架设一个网站，让被攻击者通过JavaScript等方式把收集好的数据作为参数提交，随后以数据库等形式记录在攻击者自己的服务器上。</p>
<p>常用的XSS攻击手段和目的有：</p>
<ul>
<li>盗用cookie，获取敏感信息。</li>
<li>利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</li>
<li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>
<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>
<li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</li>
</ul>
<h3 id="漏洞的防御和利用"><a href="#漏洞的防御和利用" class="headerlink" title="漏洞的防御和利用"></a>漏洞的防御和利用</h3><h4 id="过滤特殊字符"><a href="#过滤特殊字符" class="headerlink" title="过滤特殊字符"></a>过滤特殊字符</h4><p>避免XSS的方法之一主要是将用户所提供的内容进行过滤，许多语言都有提供对HTML的过滤：</p>
<ul>
<li>PHP的htmlentities()或是htmlspecialchars()。</li>
<li>Python的cgi.escape()。</li>
<li>ASP的Server.HTMLEncode()。</li>
<li>ASP.NET的Server.HtmlEncode()或功能更强的Microsoft Anti-Cross Site Scripting Library</li>
<li>Java的xssprotect (Open Source Library)。</li>
<li>NodeJS的node-validator。</li>
</ul>
<h4 id="使用HTTP头指定类型"><a href="#使用HTTP头指定类型" class="headerlink" title="使用HTTP头指定类型"></a>使用HTTP头指定类型</h4><p>很多时候可以使用HTTP头指定内容的类型，使得输出的内容避免被作为HTML解析。如在PHP语言中使用以下代码：<br><code>&lt;?php header(&#39;Content-Type: text/javascript; charset=utf-8&#39;); ?&gt;</code><br>即可强行指定输出内容为文本/JavaScript脚本（顺便指定了内容编码），而非可以引发攻击的HTML。</p>
<h4 id="用户方面"><a href="#用户方面" class="headerlink" title="用户方面"></a>用户方面</h4><p>包括Internet Explorer、Mozilla Firefox在内的大多数浏览器皆有关闭JavaScript的选项，但关闭功能并非是最好的方法，因为许多网站都需要使用JavaScript语言才能正常运作。通常来说，一个经常有安全更新推出的浏览器，在使用上会比很久都没有更新的浏览器更为安全。</p>
<h2 id="CRSF（Cross-site-request-forgery）跨站请求伪造"><a href="#CRSF（Cross-site-request-forgery）跨站请求伪造" class="headerlink" title="CRSF（Cross-site request forgery）跨站请求伪造"></a>CRSF（Cross-site request forgery）跨站请求伪造</h2><p>跨站请求伪造是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p>
<ul>
<li>XSS 利用的是用户对指定网站的信任</li>
<li>CSRF 利用的是网站对用户网页浏览器的信任</li>
</ul>
<p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：<em><strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</strong></em></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例子<br>假如一家银行用以运行转账操作的URL地址如下：<br><code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码：<br><code>&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</code><br>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。<br>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着<em><strong>如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险</strong></em>。<br>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是<em><strong>欺骗用户浏览器，让其以用户的名义运行操作。</strong></em></p>
<h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><h4 id="检查Referer（参照）字段"><a href="#检查Referer（参照）字段" class="headerlink" title="检查Referer（参照）字段"></a>检查Referer（参照）字段</h4><p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于<a href="http://www.examplebank.com之下.而如果是csrf攻击传来的请求,referer字段会是包含恶意网址的地址,不会位于www.examplebank.com之下,这时候服务器就能识别出恶意的访问./">www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</a><br>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p>
<h4 id="添加校验token"><a href="#添加校验token" class="headerlink" title="添加校验token"></a>添加校验token</h4><p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- this</title>
    <url>/2020/01/02/FE-guide-this/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h1><p>this 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; 1</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以上两者情况 &#96;this&#96; 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下情况是优先级最高的，&#96;this&#96; 只会绑定在 &#96;c&#96; 上，不会被任何方式修改 &#96;this&#96; 指向</span><br><span class="line">var c &#x3D; new foo()</span><br><span class="line">c.a &#x3D; 3</span><br><span class="line">console.log(c.a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还有种就是利用 &#96;call&#96; ， &#96;apply&#96; ， &#96;bind&#96; 改变 &#96;this&#96; ，这个优先级仅次于 &#96;new&#96;</span><br></pre></td></tr></table></figure>
<p>以上几种情况明白了，很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">        	console.log(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a()()())</span><br></pre></td></tr></table></figure>
<p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code> 。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是 <code>window。并且</code> this 一旦绑定了上下文，就不会被任何代码改变。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>介绍一个好用的doc展示库 ---- vuepress</title>
    <url>/2020/01/05/FE-guide-vuepress/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做公司技术规范，需要能通过 <code>B/S</code> 方式进行分发，起初想法是做一个网站，用 <code>html</code> 的方式进行书写，但是后面感觉太麻烦了，所以就放弃了，偶然间看到有工具可以直接通过 <code>md</code> 文件编译生成网站，就像是 <code>hexo</code> 博客这样，我觉得这挺好，极大的节省了开发网站所需要的时间，只需要专注于内容就好了，所以我就研究了下来，整个了解过程中有这么两个工具映入了我的眼帘，一个是 <code>doctify</code>，另外一个就是今天的主角 <code>vuepress</code> 。</p>
<span id="more"></span>

<h1 id="vuepress-何许"><a href="#vuepress-何许" class="headerlink" title="vuepress 何许"></a><code>vuepress</code> 何许</h1>]]></content>
      <categories>
        <category>效率工具</category>
        <category>Labrary</category>
      </categories>
      <tags>
        <tag>vuepress</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的常用命令</title>
    <url>/2017/12/12/Git-Shell/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="指令表"><a href="#指令表" class="headerlink" title="指令表"></a>指令表</h2><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>git add .</td>
<td>提示增加文件</td>
<td>.代表所有</td>
</tr>
<tr>
<td>git commit -m</td>
<td>“说明内容” 提交到本地服务器</td>
<td></td>
</tr>
<tr>
<td>git status</td>
<td>显示修改信息</td>
<td></td>
</tr>
<tr>
<td>git pull</td>
<td>从网络服务器拉 更新最新版本</td>
<td></td>
</tr>
<tr>
<td>git push</td>
<td>上传最新版本</td>
<td></td>
</tr>
<tr>
<td>git branch</td>
<td>查看当前分支</td>
<td></td>
</tr>
<tr>
<td>git checkout develop</td>
<td>切换到develop模式</td>
<td></td>
</tr>
<tr>
<td>git merge master</td>
<td>从master合并过来</td>
<td></td>
</tr>
<tr>
<td>git push origin develop</td>
<td>提交</td>
<td></td>
</tr>
<tr>
<td>git clone <a href="mailto:git@192.168.2.10">git@192.168.2.10</a>:bat-web.git</td>
<td>从服务器克隆</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 执行上下文</title>
    <url>/2020/01/02/FE-guide-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>当执行 <code>JS</code> 代码时，会产生三种执行上下文</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code> 执行上下文</li>
</ul>
<p>每个执行上下文中都有三个重要的属性</p>
<ul>
<li>变量对象（ <code>VO</code> ），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li>
<li>作用域链（ <code>JS</code> 采用<strong><em>词法作用域</em></strong>，也就是说变量的作用域是在定义时就决定了）</li>
<li>this<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var a &#x3D; 10</span><br><span class="line">function foo(i) &#123;</span><br><span class="line">  var b &#x3D; 20</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
对于上述代码，执行栈中有两个上下文：全局上下文和函数 <code>foo</code> 上下文。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">stack &#x3D; [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
对于全局上下文来说， <code>VO</code> 大概是这样的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">globalContext.VO &#x3D;&#x3D;&#x3D; globe</span><br><span class="line">globalContext.VO &#x3D; &#123;</span><br><span class="line">    a: undefined,</span><br><span class="line">	foo: &lt;Function&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于函数 <code>foo</code> 来说， <code>VO</code> 不能访问，只能访问到活动对象（ <code>AO</code> ）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">fooContext.VO &#x3D;&#x3D;&#x3D; foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    i: undefined,</span><br><span class="line">	b: undefined,</span><br><span class="line">    arguments: &lt;&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; arguments 是函数独有的对象(箭头函数没有)</span><br><span class="line">&#x2F;&#x2F; 该对象是一个伪数组，有 &#96;length&#96; 属性且可以通过下标访问元素</span><br><span class="line">&#x2F;&#x2F; 该对象中的 &#96;callee&#96; 属性代表函数本身</span><br><span class="line">&#x2F;&#x2F; &#96;caller&#96; 属性代表函数的调用者</span><br></pre></td></tr></table></figure>
对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 <code>[[Scope]]</code> 属性查找上级变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">fooContext.[[Scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">]</span><br><span class="line">fooContext.Scope &#x3D; fooContext.[[Scope]] + fooContext.VO</span><br><span class="line">fooContext.Scope &#x3D; [</span><br><span class="line">    fooContext.VO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
接下来让我们看一个老生常谈的例子， <code>var</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">b() &#x2F;&#x2F; call b</span><br><span class="line">console.log(a) &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#39;Hello world&#39;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&#39;call b&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 <code>VO</code> ）， <code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code> ，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</li>
</ul>
<p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">b() &#x2F;&#x2F; call b second</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&#39;call b fist&#39;)</span><br><span class="line">&#125;</span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&#39;call b second&#39;)</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; &#39;Hello world&#39;</span><br></pre></td></tr></table></figure>
<p><code>var</code> 会产生很多错误，所以在 <code>ES6</code> 中引入了 <code>let</code> 。 <code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升， <code>let</code> 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。</p>
<p>对于非匿名的立即执行函数需要注意以下一点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var foo &#x3D; 1</span><br><span class="line">(function foo() &#123;</span><br><span class="line">    foo &#x3D; 10</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;()) &#x2F;&#x2F; -&gt; ƒ foo() &#123; foo &#x3D; 10 ; console.log(foo) &#125;</span><br></pre></td></tr></table></figure>
<p>因为当 <code>JS</code> 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code> ，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">specialObject &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Scope &#x3D; specialObject + Scope;</span><br><span class="line"></span><br><span class="line">foo &#x3D; new FunctionExpression;</span><br><span class="line">foo.[[Scope]] &#x3D; Scope;</span><br><span class="line">specialObject.foo &#x3D; foo; &#x2F;&#x2F; &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span><br><span class="line"></span><br><span class="line">delete Scope[0]; &#x2F;&#x2F; remove specialObject from the front of scope chain</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端常见知识点整理</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2019</title>
    <url>/2019/12/31/GoodBye-2019/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知不觉又是一年，今天是2019年的最后一天，也是我30岁的最后一天，回顾这一年有收获有遗憾。翻出了18年的总结，看到了18年底对于自己19年的规划，现在回过头来看看哪些完成了。</p>
<h1 id="18年底定的计划"><a href="#18年底定的计划" class="headerlink" title="18年底定的计划"></a>18年底定的计划</h1><h2 id="学习技术"><a href="#学习技术" class="headerlink" title="学习技术"></a>学习技术</h2><h3 id="1-深入学习客户端开发（全年）"><a href="#1-深入学习客户端开发（全年）" class="headerlink" title="1. 深入学习客户端开发（全年）"></a>1. 深入学习客户端开发（全年）</h3><p>18年客户端的项目也做了几个，Electron的开发能力经验更多了，之前只是用html+css+js做前端页面的开发，今年又增加了跟vue框架的结合，成功在多个项目中实践，只是一直没有形成规范感觉还是少了一环，原来一直在犹豫Electron到底算不算前端的技术栈之一，后来也算是想明白了，大前端范畴，只要是面向用户的都算是前端该做的范畴，所以Electron当然也算是前端应该掌握的技术栈，20年会继续学习客户端技术，把公司相关规范制定和落地。</p>
<h3 id="2-学习前端自动化测试相关知识（2019年3月前）"><a href="#2-学习前端自动化测试相关知识（2019年3月前）" class="headerlink" title="2. 学习前端自动化测试相关知识（2019年3月前）"></a>2. 学习前端自动化测试相关知识（2019年3月前）</h3><p>18年关注了前端自动化测试相关的知识，本打算19年好好学习一下，在公司项目中实践，但是今年前后端工作量大增，前端人员的精力有限，加之成本的考虑，并没有开展起来，不过这方面的技能储备已经具备了，年底两次关于前端自动化的测试也将前端自动化的思想普及到了公司前端的团队里，20年是公司强调质量的一年，相信20年前端自动化测试将有机会在公司一些项目中落地</p>
<h3 id="3-学习并掌握TS-（2019年5月前）"><a href="#3-学习并掌握TS-（2019年5月前）" class="headerlink" title="3. 学习并掌握TS  （2019年5月前）"></a>3. 学习并掌握TS  （2019年5月前）</h3><p>18年就看到了TS将会成为一门比较活的开发语言，目前来说已经具备了做TS开发的技能，只是TS更适合大型的长期的项目，将更好的保障项目的代码质量，快速迭代和小型项目并不是很适合。前端团队里没有开花，没想到居然在开发团队里见到了曙光，感谢开发的小伙伴愿意接受这门前端新技术，相信有一个点采用后看到了优势，后续普及工作将会更好开展。</p>
<h3 id="4-学习并掌握React（2019年7月前）"><a href="#4-学习并掌握React（2019年7月前）" class="headerlink" title="4. 学习并掌握React（2019年7月前）"></a>4. 学习并掌握React（2019年7月前）</h3><p>18年Vue已经在公司前端全面普及开来，但是市场上React仍然是占据更多的份额，而且RN还能做App开发，所以还是一门必须要掌握的技术，今年看了一本React相关的书，也看了一些相关的视频教程，还参加了公司同事开展的React分享，虽然没有在项目中实际使用过，但是理论知识已经掌握了，可以进行小的Demo开发，20年要用React写一个开源的项目，做到学有所用，学以致用。</p>
<h3 id="5-学习前端持续集成的相关知识（2019年9月前）"><a href="#5-学习前端持续集成的相关知识（2019年9月前）" class="headerlink" title="5. 学习前端持续集成的相关知识（2019年9月前）"></a>5. 学习前端持续集成的相关知识（2019年9月前）</h3><p>19年公司强调了代码必须走线上构建的要求，前端工程化和自动构建持续集成的工作可以说是工作所迫，这方面的技能已经Get到了，另外令我感到高兴的是，通过对Github-Actions的配置，我的博客可以像提交代码一样提交文章了，而且也实践了自动构建的相关技术，很开心。</p>
<h3 id="6-学习Docker虚拟化技术（-2019年10月前）"><a href="#6-学习Docker虚拟化技术（-2019年10月前）" class="headerlink" title="6. 学习Docker虚拟化技术（ 2019年10月前）"></a>6. 学习Docker虚拟化技术（ 2019年10月前）</h3><p>这个任务没有达成，原本是希望能够通过Docker统一前端开发环境，不过Docker的适用场景还是以部署环境为主，Docker今年貌似热度也降下来了，今年K8s越来越火，不管怎样，持续关注新技术。</p>
<h2 id="整理计划"><a href="#整理计划" class="headerlink" title="整理计划"></a>整理计划</h2><h3 id="1-养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。"><a href="#1-养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。" class="headerlink" title="1. 养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。"></a>1. 养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。</h3><p>今年实在是太忙了，别说两天一篇文章，就连一个月一篇的量都没能达成，不过在年底我终于把博客又重新激活了，希望自己20年能够把博客坚持写下来，很简单，积累自己，打造个人品牌。</p>
<h3 id="2-将常用的方法和功能做成插件，开源给公司使用"><a href="#2-将常用的方法和功能做成插件，开源给公司使用" class="headerlink" title="2. 将常用的方法和功能做成插件，开源给公司使用"></a>2. 将常用的方法和功能做成插件，开源给公司使用</h3><p>今年4月开始，更多的精力都投在了部门的前端管理工作，说实话也迷茫也难过，这份迷茫终于在19年年底解开了，没能在技能层面有更高的提升，以及在代码层面给公司带来价值我觉得还是有些遗憾，20年希望自己能够在技术上有更大的进步，技术深度上/广度上/架构层面/后端技能都能有长足的进步。</p>
<h2 id="读书计划"><a href="#读书计划" class="headerlink" title="读书计划"></a>读书计划</h2><h3 id="1-每周读完一本书，并写一篇读后感"><a href="#1-每周读完一本书，并写一篇读后感" class="headerlink" title="1. 每周读完一本书，并写一篇读后感"></a>1. 每周读完一本书，并写一篇读后感</h3><p>2019年读了25本书，每读完一本都会写一篇读后感，虽然没能保证每周读一本书，但是基本保证了每两周读完一本书，算是完成了50%的目标吧。20年继续努力，读书使人聪明，因为不聪明所以更要多读书。</p>
<h2 id="部门前端计划"><a href="#部门前端计划" class="headerlink" title="部门前端计划"></a>部门前端计划</h2><h3 id="加强各设计组前端之间的交流"><a href="#加强各设计组前端之间的交流" class="headerlink" title="加强各设计组前端之间的交流"></a>加强各设计组前端之间的交流</h3><blockquote>
<p>设计组的出现导致前端交流不畅，2019年加强与各设计组前端的交流，掌握各位前端的技术能力。</p>
</blockquote>
<p>没想到一语成第，设计组居然在4月份将前端整个拿出来构成了一个前端组，由我来带，更没想到的是居然在19年年底又解散到项目团队了，这9个月的时间可以说有苦有泪也有甜，前端小伙伴们为了同一个目标，共同努力，尽最大的努力完成公司的业务，可以说为了这个目标，这一年我付出了很多很多，在这方面愧对了家人孩子，虽然最后前端还是拆分了，可以说我能力有限，但是我心里可以说是无愧，希望尽到项目团队里的小伙伴们也能开心工作，迅速成长，虽然不再在一个团队里，但是，我仍是你们的光妈。</p>
<h3 id="前端俱乐部推动"><a href="#前端俱乐部推动" class="headerlink" title="前端俱乐部推动"></a>前端俱乐部推动</h3><blockquote>
<p>继续每周2小时的兴趣交流，交流形式不限于ppt，要求各自建立技术博客做笔记。</p>
</blockquote>
<p>俱乐部的活动最后还是没能坚持下来，大家工作比较忙也好，我自己的原因也好，确实没能坚持下来，20年还是希望能够将俱乐部活动组织起来，算是大家交流的机会也好，帮助大家开阔眼界也好，20年一定要再做起来！</p>
<h3 id="进行梯队划分建设"><a href="#进行梯队划分建设" class="headerlink" title="进行梯队划分建设"></a>进行梯队划分建设</h3><blockquote>
<p>前端今年人数明显增多，但各层级职责并没有区分，19年抽时间进行梯队建设。</p>
</blockquote>
<p>19年前端从14人增加到了34人，可以说人数上翻翻了，随着负责人制的执行，梯队建设的工作算是完成了50%，但是能力提升的工作可以说还是做的不到位，应该有机会成长为高工的小伙伴没能升上去，这我有一定的责任，20年虽然团队不再，但是希望你们都坚持努力学习，迈向更高的台阶。</p>
<h3 id="引入前端工程化工具和思想"><a href="#引入前端工程化工具和思想" class="headerlink" title="引入前端工程化工具和思想"></a>引入前端工程化工具和思想</h3><blockquote>
<p>目前前端工程化已经非常成熟，希望能将成熟的技术和工具引入。</p>
</blockquote>
<p>19年，随着Vue的普及和熟练，模块化开发组件化开发的思想已经深入到每一个前端的心中，现在大家都知道该如何使用这些技术和工具，希望大家能不仅仅局限在用也能了解了解其中原理，至少对常用的配置有所了解。</p>
<h3 id="提升整体前端开发的能力"><a href="#提升整体前端开发的能力" class="headerlink" title="提升整体前端开发的能力"></a>提升整体前端开发的能力</h3><blockquote>
<p>目前整体前端开发能力还相对较弱，19年通过培训等方式提升整体前端开发的能力</p>
</blockquote>
<p>19年能力提升的工作做的太少了，没什么好说的，希望20年这方面工作能够投入更多的精力，让更多的小伙伴成长起来，让我们一起加油吧。</p>
<h2 id="生活目标"><a href="#生活目标" class="headerlink" title="生活目标"></a>生活目标</h2><h3 id="每天陪孩子读书一小时"><a href="#每天陪孩子读书一小时" class="headerlink" title="每天陪孩子读书一小时"></a>每天陪孩子读书一小时</h3><p>跟上面的工作和个人目标比起来，这个任务可以说完成度0%，这也是我觉得愧对家人的地方，为了工作，对家人的关注少了很多很多，以至于桐桐晚上都不愿意跟我一起睡觉，20年我要好好对她，做个好的爸爸，孩子明年就三岁了，去到幼儿园会认识更多的朋友，希望她会跟她的小伙伴说，我有个爱我的爸爸。</p>
<h3 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h3><p>减肥这件事可以说是真的对我来说太难了，看着自己马上破三位数（kg）的体重，心里无限难过，每次媳妇儿问我啥时候去健身，我都感到像被闪电击中了似的，办了健身卡被人嘲笑成了洗澡卡，20年，减不到150斤我就。。。。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>19年太多的遗憾，太多的后悔莫及，当然也有一些成绩和自我肯定，19年已经过去了，希望在20年，能够成为一个更优秀的人。<br><img src="https://i.loli.net/2019/12/31/jMlO5sPxFyhIkai.jpg" alt="WechatIMG6.jpeg"><br>感谢我可爱的同事，年底收到了礼物真的很开心。</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>杂记随感</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>你好2020</title>
    <url>/2020/01/01/Hello-2020/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="2020元旦伊始"><a href="#2020元旦伊始" class="headerlink" title="2020元旦伊始"></a>2020元旦伊始</h1><p>时间过的真快，19年睡了一觉就成了过去的一年，今天是元旦，早上8：00起了床，简单洗漱后我出了门，新年新气象，去年没有坚持的晨跑，今年想要坚持一下，所以一早就出门跑了会儿步，太久没活动了，只是跑了半个小时就气喘吁吁，只好回家，但是即使是这半个小时，我感觉呼吸了新鲜的空气，整个人也精神了不少，回到家坐在阳台上，拿出小王宁送我的极少数手册开始研究了起来，生活还是应该有点仪式感何况是新年伊始，手册中有很多建议，全部看过一遍以后我郑重的拿起了笔写下了我今天的行动计划。但是没有写年度计划，明天上班后跟领导还要谈一谈，谈过之后再定一下年度的计划。今天我的计划就是陪家人过好元旦这一天。</p>
<h1 id="元旦执行计划"><a href="#元旦执行计划" class="headerlink" title="元旦执行计划"></a>元旦执行计划</h1><ol>
<li>写一篇日志</li>
<li>将家人这一天游玩的过程以Vlog的形式记录下来，上传到西瓜视频上。</li>
<li>陪家人逛街，给桐桐买新衣裳。</li>
</ol>
<h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>吃过早饭后大概到了10:30，一家人收拾好以后终于可以出门了，今天有点风，一点点冷不是特别冷，空气还不错，天气听晴朗的，一家人开着车听着歌前往甘井子万达广场，20分钟左右我们就到了万达广场，首先我们先去看了桐桐心心念念的小猫咪，也就是猫咪咖啡馆里的那些小可爱，桐桐可能是受妈妈影响，很喜欢猫咪，但是又有一点点怕。大概看了10分钟的猫咪，我们继续下一站，上四楼给桐桐买新衣裳，桐桐看到满眼的漂亮衣裳很是兴奋，最终她挑选了一套带着向日葵花朵的淡蓝色衣裙，穿上漂亮的新衣裳，平时像个假小子似的桐桐也一下子害羞了起来，让妈妈和奶奶看完后还会让爸爸和爷爷看看，得到了大家的肯定以后，心满意足的买下了它，也不知道是不是试衣服试累了，桐桐嚷嚷着要吃饭，桐桐妈说有一家港式茶餐厅味道不错，之前和同事来过，于是我们就去了4楼的茶餐厅，说实话这是我头一次吃茶餐厅，我还跟我爸妈调侃说，这也算是我们来过一次香港了。去到餐厅时才11点多一点，客还没有上满，还有座位，我们找了个靠里的位置坐了下来，打开菜谱，桐桐妈挑了几样她觉得不错的菜，上菜时间稍微有点慢，期间桐桐有些不耐烦，坐也坐不住，终于等到了吃的上来，可是觉得大多数吃的都太偏甜，爸妈和我都吃不太惯，桐桐吃的还不错，大概吃了半个小时就吃完了，出门的时候门口已经排起了长队，还好来的早一点，不然吃饭都要等了。本打算带着桐桐回家睡个觉，下午要到姥爷家串门，可桐桐说没有逛够，正巧这时看到了一楼有小丑在折气球玩具，我们就下到一楼找小丑玩了，小丑给桐桐折了个贵宾犬，小丑是荣耀手机的员工，可能是元旦策划的活动吧，反正来了就来了，进去看看也好，看了新出的V30手机，感觉并不是很喜欢，店员说有旧机抵值的活动，我问了他我的7p128g还能值多少，他打了几个电话后回复我1400块，哎，三年前7000块买的手机，现在只值1400了，算了还是用着吧，出了荣耀手机店又去了旁边的华为，看了看新出的mate30pro，这个手机是真的不错，当然手机不错价格也美丽，6500+的价格真的是让我不舍得买，还是把钱留下来给桐桐吧。桐桐终于累了，嚷嚷着要走，于是一家人驱车去了姥姥家。</p>
<p>姥姥家在西南路，因为平时工作忙很少带桐桐去，这次去桐桐又不认识他们了，开始的时候很拘束，也不说话，一直到吃饭结束才终于愿意开口问好唱歌，因为家里没有电视机，到了姥姥家看到电视机很兴奋，一直在看，今天也算是过了瘾了，亲人就是即使很长时间不见面，但一见面就特别亲的人，饭从5：30一直吃到8:30，聊了工作，聊了生活，聊了困惑，聊了坦然，我终于知道了长辈们的智慧，了解了身体健康的重要性，20年一定要锻炼出一副好的身体，对家人负责。</p>
<p>9:30回到了家，心里挺高兴的，新年第一天陪家人一起度过了充实的一天，回到家把今天路上录下来的视频剪成了短视频上传到了西瓜视频，这也是我今年的一个想法，记录我们一家人的幸福生活，如果有粉丝有点播的话还能赚点钱，没有的话也记录了桐桐的成长，算是一点纪念吧。最后写下了这篇日记，写完之后我就要睡觉去了，明天一早就要起床，明天起我就要走路去上班了，为了有一副好身体，加油。</p>
<p>今天的目标都完成了，很开心～～</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>杂记随感</category>
      </categories>
  </entry>
  <entry>
    <title>Vue 响应式原理的实现（课程笔记）</title>
    <url>/2020/02/21/Implementation-of-the-vue-response-principle/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近一直在追网课，说实话从业9年了，一直觉得前端发展非常快，而且一直充满着危机感，每天都要学习进步才有安稳的感觉，今天听了 vue 响应式原理实现的公开课，感觉还不错，做了如下笔记，帮助自己记忆，也希望能帮助大家。</p>
<h1 id="Vue2-原理"><a href="#Vue2-原理" class="headerlink" title="Vue2 原理"></a>Vue2 原理</h1><h2 id="什么是-defineProperty"><a href="#什么是-defineProperty" class="headerlink" title="什么是 defineProperty"></a>什么是 defineProperty</h2><p>defineProperty 其实是定义对象属性用的</p>
<blockquote>
<p>defineProperty 其实并不是核心的为一个对象做数据双向绑定，而是去给对象做属性标签，只不过是属性里 get 和 set 实现了响应式。</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性名</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>undefined</td>
</tr>
<tr>
<td>get</td>
<td>undefined</td>
</tr>
<tr>
<td>set</td>
<td>undefined</td>
</tr>
<tr>
<td>writable</td>
<td>false</td>
</tr>
<tr>
<td>enumerable</td>
<td>false</td>
</tr>
<tr>
<td>configurable</td>
<td>false</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123;</span><br><span class="line">	a:<span class="number">1</span>,</span><br><span class="line">	b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数 1、对象 2、属性 3、配置</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(ob,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">	writable:<span class="literal">false</span>,</span><br><span class="line">	enumerable:<span class="literal">true</span>,</span><br><span class="line">	configurable:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(ob,<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// 1</span></span><br><span class="line">ob.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(ob.a) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>下面我们实现一下双向绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(ob,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">	get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;a is be get&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">999</span>;</span><br><span class="line">	&#125;, </span><br><span class="line">	set:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;a is be set&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">999</span>;</span><br><span class="line">	&#125;, </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(ob,<span class="string">&#x27;a&#x27;</span>)) <span class="comment">// 999</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改造代码实现双向绑定（存取值）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _val = obj.a; <span class="comment">// 暂存</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(ob,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">	get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;a is be get&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> _val;</span><br><span class="line">	&#125;, </span><br><span class="line">	set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">		_val = newVal <span class="comment">// 新值替换旧值</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;a is be set&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> _val;</span><br><span class="line">	&#125;, </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Vue-中从改变一个数据到发生改变的过程"><a href="#Vue-中从改变一个数据到发生改变的过程" class="headerlink" title="Vue 中从改变一个数据到发生改变的过程"></a>Vue 中从改变一个数据到发生改变的过程</h2><ol>
<li>改变数据触发 Set </li>
<li>Set 部分触发 notify（更新）<ol>
<li>Get 部分收集依赖</li>
</ol>
</li>
<li>更改对应的虚拟 Dom</li>
<li>重新 Render</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyVue.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单版本 vue</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyVue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.$data = &#123;</span><br><span class="line">		a: &#123;</span><br><span class="line">			b:<span class="number">1</span></span><br><span class="line">		&#125;, </span><br><span class="line">		c:<span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>);</span><br><span class="line">	<span class="built_in">this</span>.virtualDom = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="built_in">this</span>.observer(<span class="built_in">this</span>.$data);</span><br><span class="line">	<span class="built_in">this</span>.render();</span><br><span class="line">&#125;</span><br><span class="line">vue.property.observer = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _val, self = <span class="built_in">this</span>;</span><br><span class="line">	<span class="comment">// var dep = new Dep() -&gt; 源码中依赖收集对象</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123; <span class="comment">// 属性有可能是对象，要递归绑定</span></span><br><span class="line">		_val = obj[key];</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> _val === <span class="string">&#x27;Object&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">this</span>.observer(_val)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>.$data,key,&#123; <span class="comment">// 这里是实际绑定过程</span></span><br><span class="line">				get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">					<span class="comment">// 依赖收集</span></span><br><span class="line">					<span class="comment">// dep.depend(); -&gt; vue 源码中收集依赖的方法</span></span><br><span class="line">					<span class="keyword">return</span> _val</span><br><span class="line">				&#125;,</span><br><span class="line">				set:<span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">					_val = newVal</span><br><span class="line">					<span class="comment">// dep.notify(); -&gt; vue 源码中</span></span><br><span class="line">					self.render() <span class="comment">// AST语法树</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vue.property.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.virtualDom = <span class="string">&#x27;i am &#x27;</span>+<span class="built_in">this</span>.$data.b;</span><br><span class="line">	<span class="built_in">this</span>.el.innerHTML = <span class="built_in">this</span>.virtualDom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>自己实现Vue2数据双向绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;myVue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> mv = <span class="keyword">new</span> MyVue();</span></span><br><span class="line"><span class="javascript">			<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(<span class="string">&#x27;changes&#x27;</span>);</span></span><br><span class="line"><span class="javascript">				<span class="built_in">console</span>.log(mv.$data);</span></span><br><span class="line">				mv.$data.b = 222;</span><br><span class="line">			&#125;)</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>依赖收集：</p>
<ol>
<li>我们的data里面的数据并不是所有地方都用到</li>
<li>如果我们直接更新整个视图，浪费资源</li>
<li>先收集依赖改变的数据的组件，再更新依赖了数据的组件（Dep depend notify）</li>
</ol>
</blockquote>
<h3 id="格外注意的地方—数组怎么监听"><a href="#格外注意的地方—数组怎么监听" class="headerlink" title="格外注意的地方—数组怎么监听"></a>格外注意的地方—数组怎么监听</h3><p>definePropty 只能给对象进行 get set 绑定， 数组怎么办？</p>
<p>vue 中 使用了 <em><strong>装饰者模式</strong></em></p>
<blockquote>
<p>装饰者模式 Decorator模式（别名Wrapper）：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arraypro = <span class="built_in">Array</span>.property; <span class="comment">// 创建一个数组的原型对象</span></span><br><span class="line"><span class="keyword">var</span> arrob = <span class="built_in">Object</span>.create(arraypro); <span class="comment">// 避免影响原型链</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;push&#x27;</span>,<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;shift&#x27;</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method,index</span>)</span>&#123;</span><br><span class="line">	arrob[method]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 装饰者模式</span></span><br><span class="line">		<span class="keyword">var</span> ret = arraypro[method].apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">		dep.notify() <span class="comment">// 扩展了功能</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Vue3-实现双向绑定"><a href="#Vue3-实现双向绑定" class="headerlink" title="Vue3 实现双向绑定"></a>Vue3 实现双向绑定</h2><p>Proxy 是什么？</p>
<blockquote>
<p>Proxy 对象用于定义基本操作的自定义行为<br>和 definePropty 类似，功能几乎一样，只是用法上不同</p>
<ol>
<li>不会污染原对象</li>
<li>直接给对象就可以了</li>
<li>不需要借助外部变量 _val</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ob = &#123;</span><br><span class="line">	a:<span class="number">1</span>,</span><br><span class="line">	b:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newOb = <span class="keyword">new</span> <span class="built_in">Proxy</span>(ob,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">target,key,receiver</span>)</span>&#123; <span class="comment">// target 对象，key 属性</span></span><br><span class="line">		<span class="built_in">console</span>.log(target,key,receiver)</span><br><span class="line">		<span class="keyword">return</span> target[key]</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">target,key,value,receiver</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target.key,value); </span><br><span class="line">		<span class="comment">// 将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</span></span><br><span class="line">		<span class="comment">// return target[key] = value</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="为什么改用-Proxy"><a href="#为什么改用-Proxy" class="headerlink" title="为什么改用 Proxy"></a>为什么改用 Proxy</h3><ol>
<li>defineProperty 只能监听某个属性，不能全对象监听</li>
<li>可以省去<code>for in</code>循环提升代码执行效率</li>
<li>可以监听数组，不需要再为数组做特异性操作</li>
<li>不污染原对象</li>
<li>更优雅</li>
</ol>
<p>我们用 Proxy 实现一下 observe 方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue.property.observe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">	<span class="built_in">this</span>.$data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="built_in">this</span>.$data,&#123;</span><br><span class="line">		<span class="function"><span class="title">get</span>(<span class="params">target,key, receiver</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> target[key]</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="function"><span class="title">set</span>(<span class="params">target,key,newVal</span>)</span>&#123;</span><br><span class="line">			target[key] = newVal</span><br><span class="line">			self.render()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="还能用-Proxy-做什么"><a href="#还能用-Proxy-做什么" class="headerlink" title="还能用 Proxy 做什么"></a>还能用 Proxy 做什么</h4><ol>
<li>校验类型</li>
<li>真正的私有变量</li>
</ol>
<h5 id="校验类型"><a href="#校验类型" class="headerlink" title="校验类型"></a>校验类型</h5><p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类型验证</span></span><br><span class="line"><span class="comment">// 我们要创建一个对象，这个对象是个人，他有name和age两个属性</span></span><br><span class="line"><span class="comment">// name必须是中文，age必须是数字，大于18岁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用到了策略模式</span></span><br><span class="line"><span class="keyword">var</span> valid = &#123;</span><br><span class="line">	<span class="function"><span class="title">name</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> reg=<span class="regexp">/^[\u4E00-\u9FAS]=$/</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span> &amp;&amp; reg.test(value))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;, </span><br><span class="line">	<span class="function"><span class="title">age</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> &amp;&amp; value &gt; <span class="number">18</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	<span class="built_in">this</span>.age = age</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="built_in">this</span>,&#123;</span><br><span class="line">		<span class="function"><span class="title">get</span>(<span class="params">target,key</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> target[key]</span><br><span class="line">		&#125;, </span><br><span class="line">		<span class="function"><span class="title">set</span>(<span class="params">target,key,value</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(valid[key](value))&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value)</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(key+<span class="string">&#x27;is not valid&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">&#x27;name&#x27;</span>,<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>策略模式</strong></em><br>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
</blockquote>
<h5 id="真正的私有变量"><a href="#真正的私有变量" class="headerlink" title="真正的私有变量"></a>真正的私有变量</h5><p>vue-router 源码中，给 $router ,$route 用 defineProperty 定义 get 并返回本身，这样就不能修改属性了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&#x27;$router&#x27;</span>,&#123; <span class="comment">// Router 的实例</span></span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>._root._router;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&#x27;$route&#x27;</span>,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="comment">// 当前路由所在的状态</span></span><br><span class="line">			current: <span class="built_in">this</span>._root._router.history.current;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="虚拟Dom和diff算法"><a href="#虚拟Dom和diff算法" class="headerlink" title="虚拟Dom和diff算法"></a>虚拟Dom和diff算法</h2><p>虚拟Dom是虚拟的，他只在概念里面存在，在AST语法树，下面进行解释</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;p&gt;<span class="number">2</span>&lt;/p&gt;</span><br><span class="line">		&lt;p&gt;<span class="number">3</span>&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// diff 描述法</span></span><br><span class="line">diff &lt;div&gt;</span><br><span class="line">	props:&#123;</span><br><span class="line">		id:<span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	children:[</span><br><span class="line">		diff &lt;p&gt;</span><br><span class="line">			props:&#123;</span><br><span class="line">				id:xxx</span><br><span class="line">			&#125;</span><br><span class="line">			children:[</span><br><span class="line">				...</span><br><span class="line">			]</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象描述法</span></span><br><span class="line"><span class="keyword">var</span> virtual = &#123;</span><br><span class="line">	dom:<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">	props:&#123;</span><br><span class="line">		id:<span class="number">2</span></span><br><span class="line">	&#125;,</span><br><span class="line">	children:[</span><br><span class="line">		....</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每层结构都是一样的，那么是如何进行 diff 比对的呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * diff 算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="title">patchVnode</span>(<span class="params">oldVnode,vnode</span>)</span>&#123; <span class="comment">// 接收新旧节点</span></span><br><span class="line">	<span class="keyword">const</span> el = vnode.el = oldVnode.el; <span class="comment">// 拿出真实dom</span></span><br><span class="line">	<span class="keyword">let</span> i,oldCh = oldVnode.children ,ch = vnode.children <span class="comment">// 拿出新旧节点子元素children数组</span></span><br><span class="line">	<span class="keyword">if</span>(oldVnode === vnode) <span class="keyword">return</span>; <span class="comment">// 新旧节点一致，直接返回不进行后续操作</span></span><br><span class="line">	<span class="comment">// 分情况操作 --- 只有文字节点，删除了子元素，增加了子元素，子元素发生变动</span></span><br><span class="line">	<span class="comment">// 新旧节点都不为空，且不一样</span></span><br><span class="line">	<span class="keyword">if</span>(oldVnode.text !== <span class="literal">null</span> &amp;&amp; vnode.text !== <span class="literal">null</span> &amp;&amp; oldVnode.text !== vnode.text)&#123; <span class="comment">// 文字发生更新</span></span><br><span class="line">		api.setTextContent(el,vonde.text) <span class="comment">// 文字发生了更新，更新文字，给Dom，更新文字</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 不是单纯文字节点的话</span></span><br><span class="line">		updateEle(); <span class="comment">// 更新元素</span></span><br><span class="line">		<span class="keyword">if</span>(oldCh&amp;&amp;ch&amp;&amp;oldCh!==ch)&#123; <span class="comment">// 都有子元素，子元素变动</span></span><br><span class="line">			updateChildren() <span class="comment">// 调用更新子元素方法</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch)&#123; <span class="comment">// 增加子元素</span></span><br><span class="line">			createEl(vnode) <span class="comment">// 创建子元素</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(oldCh)&#123; <span class="comment">// 删除子元素</span></span><br><span class="line">			api.removeChildren(el) <span class="comment">// 调用删除子元素方法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码要多看，以下必看 <em><strong>Vue/react/axios/vue-router/Redux/Vuex</strong></em><br>为什么要看源码？？</p>
<ul>
<li>初级前端就会用vue或react — 从差不多水平的60%中挑出更好的人</li>
<li>提高思想–》看优秀的代码–》写优秀的代码</li>
<li>看源码能力，对高级前端是必备的。— 解决疑难杂症，看源码了解原理。</li>
</ul>
<h2 id="vue-性能优化"><a href="#vue-性能优化" class="headerlink" title="vue 性能优化"></a>vue 性能优化</h2><p>因为是公开课，所以时间上没来的及说完，以后自己在听别的有关的内容时再补上这块。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>只有不断学习才能进步，充分利用网络的便利性，找各种优质的教学资源，我相信，努力会有回报，加油！</p>
]]></content>
      <categories>
        <category>源码原理</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 设计模式 Design Pattern</title>
    <url>/2020/01/13/Javascript-Design-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在整理自己的知识体系，一方面为了夯实基础，另一方面也为了查缺补漏、重新理解，设计模式之前看过大概三四次，从最开始一点都不懂，到后面看了几遍以后慢慢理解，今天再次整理一下，希望这一遍下来之后能更加透彻的理解什么是设计模式。</p>
<a id="more"></a>

<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><blockquote>
<p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案<br>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
</blockquote>
<blockquote>
<p>　　使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。   —- 百度百科</p>
</blockquote>
<p>不知道大家看了上面的定义以后是什么感受，说实话我第一次看到这句话并没有什么深刻的认识，什么面向对象的软件设计，什么针对特定问题，什么优雅的解决方案，这都说的是什么，后来我看了几遍之后，上面这句话用我的理解翻译如下：</p>
<blockquote>
<p>软件开发过程中，解决某一类问题用到的一系列套路</p>
</blockquote>
<p>这就是我对设计模式的认识。当然这也不仅仅是我自己的认识，在跟其他的一些开发人员交流时，很多人都是这么认为的。</p>
<p>这些解决问题的方案实在是太好用了，所以大神就把它们抽象出来，然后起了个名字-就叫做设计模式了。</p>
<p>这么说大家可能还是不太明白，举个开发过程中可能遇到的实际例子吧。</p>
<blockquote>
<p>当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。那么这种场景下我们该如何解决这个问题呢？通常我们需要新增一个接口，兼容原来的接口和新的业务需求参数。<br>因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题。</p>
</blockquote>
<p>这就是设计模式的应用，实际上也许你还不知道设计模式这个词，但是你已经在工作中频繁的用到了设计模式，下面我们就来看看到底有哪些设计模式。</p>
<p>哦，对了，设计模式并不依赖于语言，它本身更像是一种软件的设计思想，因为我是一个前端，所以接下来具体实现的时候我会使用js来实现设计模式的用法。</p>
<h1 id="学习设计模式"><a href="#学习设计模式" class="headerlink" title="学习设计模式"></a>学习设计模式</h1><p>目前被普遍接受的经典的设计模式共有 <strong>23</strong> 种，而这23种设计模式又分为了 <strong>3大类</strong> ，看过一张图这里拿过来镇贴。<br><img src="https://s2.ax1x.com/2020/01/13/lHgD4H.jpg" alt="lHgD4H.jpg"><br>他们分别是</p>
<ul>
<li>创建型模式</li>
<li>结构型模式</li>
<li>行为型模式</li>
</ul>
<p>接下来，我将会将这23种，3大类设计模式一个个的拆解开来，跟大家一起学习一下，设计模式有哪些内容。</p>
<h2 id="创建型模式-6个"><a href="#创建型模式-6个" class="headerlink" title="创建型模式 6个"></a>创建型模式 6个</h2><p>这类模式用于<strong>对象的生成</strong>和<strong>生命周期的管理</strong>。<br>创建型模式可以决定生成哪些对象，提高了程序的灵活性。具体属于此类的模式清单如下，共有 <strong>5</strong> 个：</p>
<ul>
<li>单例模式（Singleton）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
<li>建造者模式（Builder）</li>
<li>原型模式（Prototype）</li>
<li>迭代器模式（Iterator）</li>
</ul>
<h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><p><strong><em>描述：</em></strong>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h3><p><strong><em>描述：</em></strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
<h3 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h3><p><strong><em>描述：</em></strong>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类</p>
<h3 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h3><p><strong><em>描述：</em></strong>将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p><strong><em>描述：</em></strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h3 id="迭代器模式（Iterator）"><a href="#迭代器模式（Iterator）" class="headerlink" title="迭代器模式（Iterator）"></a>迭代器模式（Iterator）</h3><p><strong><em>描述：</em></strong>提供一种方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。</p>
<h2 id="结构型模式-7个"><a href="#结构型模式-7个" class="headerlink" title="结构型模式 7个"></a>结构型模式 7个</h2><ul>
<li>适配器模式（Adapter）</li>
<li>组合模式（Compositor）</li>
<li>代理模式（Proxy）</li>
<li>桥梁模式（Bridge）</li>
<li>装饰模式（Decorator）</li>
<li>门面模式（Facade）</li>
<li>享元模式（Flyweight）</li>
</ul>
<h3 id="适配器模式（Adapter）"><a href="#适配器模式（Adapter）" class="headerlink" title="适配器模式（Adapter）"></a>适配器模式（Adapter）</h3><p><strong><em>描述：</em></strong>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
<h3 id="组合模式（Compositor）"><a href="#组合模式（Compositor）" class="headerlink" title="组合模式（Compositor）"></a>组合模式（Compositor）</h3><p><strong><em>描述：</em></strong>将对象组合成树形结构</p>
<h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="桥梁模式（Bridge）"><a href="#桥梁模式（Bridge）" class="headerlink" title="桥梁模式（Bridge）"></a>桥梁模式（Bridge）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="门面模式（Facade）"><a href="#门面模式（Facade）" class="headerlink" title="门面模式（Facade）"></a>门面模式（Facade）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h3><p><strong><em>描述：</em></strong></p>
<h2 id="行为型模式-10个"><a href="#行为型模式-10个" class="headerlink" title="行为型模式 10个"></a>行为型模式 10个</h2><ul>
<li>命名模式（Command）</li>
<li>解释器模式（Interpreter）</li>
<li>责任链模式（Chian of Responsibility）</li>
<li>观察者模式（Observer）</li>
<li>中介者模式（Mediator）</li>
<li>备忘录模式（Memento）</li>
<li>状态模式（State）</li>
<li>策略模式（Strategy）</li>
<li>模板方法模式（Template Method）</li>
<li>访问者模式（Visitor）</li>
</ul>
<h3 id="命名模式（Command）"><a href="#命名模式（Command）" class="headerlink" title="命名模式（Command）"></a>命名模式（Command）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="解释器模式（Interpreter）"><a href="#解释器模式（Interpreter）" class="headerlink" title="解释器模式（Interpreter）"></a>解释器模式（Interpreter）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="责任链模式（Chian-of-Responsibility）"><a href="#责任链模式（Chian-of-Responsibility）" class="headerlink" title="责任链模式（Chian of Responsibility）"></a>责任链模式（Chian of Responsibility）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h3><p><strong><em>描述：</em></strong></p>
<h3 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h3><p><strong><em>描述：</em></strong></p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>《高性能JAVASCRIPT》读书笔记</title>
    <url>/2013/06/17/Read-High-Performance-JavaScript/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近读了《高性能JAVASCRIPT》，下面将书中觉得有用的内容进行摘抄，放在下方。</p>
<h1 id="如何从小事提升JAVASCRIPT性能。"><a href="#如何从小事提升JAVASCRIPT性能。" class="headerlink" title="如何从小事提升JAVASCRIPT性能。"></a>如何从小事提升JAVASCRIPT性能。</h1><ol>
<li><p>将<code>&lt;script&gt;</code>标签写在<code>&lt;/body&gt;</code>之前——将脚本放在底部。</p>
</li>
<li><p>尽量少的<code>&lt;script&gt;</code>标签，减少页面中的外链数量，减少请求次数。</p>
</li>
<li><p>使用打包工具如：Yahoo！combo handler</p>
</li>
<li><p>使用动态延迟加载技术如：LazyLoad类库,LABjs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;lazyload-min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  LazyLoad.js([],function()&#123;</span><br><span class="line">    Application.init();</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在javascript中存储位置十分重要，尽量用局部变量代替对象成员的访问。</p>
</li>
<li><p>集合变数组提高查询效率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">function toArray(coll)&#123;</span><br><span class="line">  for(var i &#x3D; 0, a&#x3D;[], len&#x3D;coll.length; i&lt;len; i++)&#123;</span><br><span class="line">    a[i]&#x3D;col[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用局部变量缓存访问多次的成员<br>当便利一个集合时，首要优化原则是把集合存储在局部变量中，并把length缓存在循环外部，然后使用局部变量访问这些需要多次访问的元素。</p>
</li>
<li><p>使用原生DOM方法querySelectorAll（）遍历查找元素。</p>
</li>
<li><p>让元素脱离动画流，页面重排次数越多，程序响应越慢，要尽量减少重拍<br>方法：</p>
</li>
<li><ol>
<li>使用绝对定位使元素脱离文档流</li>
</ol>
</li>
<li><p>IE：hover<br>在大量元素使用：hover这个伪css选择器时，程序会降低响应速率，在大表格或列表的情况下</p>
</li>
</ol>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《让老板提拔你》读书笔记</title>
    <url>/2015/12/31/Read-Let-your-boss-promote-you/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近读了《让老板提拔你》，下面将书中觉得有用的内容进行摘抄，放在下方。</p>
<h1 id="定位自己"><a href="#定位自己" class="headerlink" title="定位自己"></a>定位自己</h1><p>正确认识自己，确定社会定位、职业定位。 定位-决定-定价</p>
<h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><p><em><strong>核心竞争力</strong></em> 与 <em><strong>职位</strong></em> <em><strong>契合度</strong></em> 是高薪关键所在</p>
<h3 id="契合度"><a href="#契合度" class="headerlink" title="契合度"></a>契合度</h3><ul>
<li>技能、专长、经历与职位要求的契合度</li>
<li>专业资质和等级与职位要求的契合度</li>
<li>综合素质与职位要求的契合度<h3 id="七大秘诀"><a href="#七大秘诀" class="headerlink" title="七大秘诀"></a>七大秘诀</h3></li>
<li>了解同行业薪酬的平均水平</li>
<li>赢得未来单位的心</li>
<li>先让对方开口</li>
<li>勇敢地开口要求</li>
<li>不要轻言放弃</li>
<li>把握时机很重要</li>
<li>说实话，别撒谎<h3 id="如何谈薪资"><a href="#如何谈薪资" class="headerlink" title="如何谈薪资"></a>如何谈薪资</h3></li>
<li>商洽薪酬的关键在于把握好谈话时机，切勿开门见山。<blockquote>
<p>只要有发展机会，我愿意接受贵单位的薪酬标准，不知道按规定这个工作岗位的薪酬标准是多少。</p>
</blockquote>
</li>
</ul>
<h3 id="将知识卖个好价钱"><a href="#将知识卖个好价钱" class="headerlink" title="将知识卖个好价钱"></a>将知识卖个好价钱</h3><p>推销自己既推销自己所掌握的知识即智慧，正确认识自己的价值是关键。</p>
<h3 id="高薪是因为“物有所值”"><a href="#高薪是因为“物有所值”" class="headerlink" title="高薪是因为“物有所值”"></a>高薪是因为“物有所值”</h3><ul>
<li>用业绩、用能力说话，是人才坦然面对高薪的心态。</li>
<li>高薪人才的求职方式 —- 圈内朋友引见、定向投简历、行业论坛、交流活动等。</li>
<li>高级人才不能经常跳槽要保持相对的职业稳定。—- 在一家公司少则3年多则6年 —- 接受挑战，把握机会。</li>
</ul>
<h3 id="失败丰富走向成功经验"><a href="#失败丰富走向成功经验" class="headerlink" title="失败丰富走向成功经验"></a>失败丰富走向成功经验</h3><p>强调在失败中吸取的经验，在未来中可以避免的损失。</p>
<h3 id="能为企业带来丰厚的利润才是人才"><a href="#能为企业带来丰厚的利润才是人才" class="headerlink" title="能为企业带来丰厚的利润才是人才"></a>能为企业带来丰厚的利润才是人才</h3><p>企业招聘员工的唯一目的：追求公司业绩最大化、利润最大化。</p>
<h1 id="高质高效工作全攻略"><a href="#高质高效工作全攻略" class="headerlink" title="高质高效工作全攻略"></a>高质高效工作全攻略</h1><ul>
<li>进行正确的自我评价</li>
<li>做最擅长做的事<ul>
<li>三个经济原则 —- 发挥人才优势。<ol>
<li>比较利益原则—–自己的专长对自己才是最有利的，勿与他人作比较。</li>
<li>机会成本原则—–选择一份工作放弃其他工作就是机会成本。</li>
<li>效率原则——–工作的成功不在于时间有多长，而在于成效有多少，附加值有多少。</li>
</ol>
</li>
</ul>
</li>
<li>马上行动</li>
<li>做事情要雷厉风行 ——— 成功属于踏实肯干的人</li>
<li>有条不紊地开展工作 ——- 制定时间计划</li>
<li>善于利用现代办公工具</li>
<li>给自己最大的工作空间</li>
<li>建立高效有序的办公环境</li>
<li>不要忘记最初想去的方向</li>
<li>“聪明”的向上级提出建议</li>
<li>专心做事，避免浮躁</li>
<li>多而不专，一事难成</li>
<li>“专”才有高质工作——–人才主要指专才–某个领域的高精尖人才–勿做全才，一专多能</li>
<li>做事要有条理</li>
</ul>
<h1 id="不要只把自己当成一个打工仔"><a href="#不要只把自己当成一个打工仔" class="headerlink" title="不要只把自己当成一个打工仔"></a>不要只把自己当成一个打工仔</h1><blockquote>
<p>要把工作当成事业</p>
</blockquote>
<ul>
<li>工作不仅仅是为了钱</li>
<li>对工作要有明确的价值取向<ol>
<li>认清人生的方向</li>
<li>开始学会醉卧探索和认知</li>
<li>认清工作价值与成就的关系</li>
<li>长期的工作规划</li>
<li>在生命的天平上衡量自身的价值</li>
</ol>
</li>
<li>巧妙应对与上司看法向左时的三条准则<ol>
<li>遇事考虑全局</li>
<li>辩证地看待问题</li>
<li>切记感情用事</li>
</ol>
</li>
<li>把单位的事当成自家的事</li>
<li>认真负责地用心工作</li>
<li>珍惜岗位，热爱自己的职业</li>
<li>永远是在为自己工作</li>
<li>敬重自己的工作</li>
<li>不要轻视薪水微薄的工作</li>
<li>永远对工作充满激情</li>
<li>以自己的工作为荣</li>
<li>不要被他人的观点所束缚</li>
<li>暂时的胜负并不会决定人生的最后走向</li>
<li>将弱势转化为优势</li>
<li>全力以赴做好每一天的工作</li>
<li>和优秀的人士在一起—见贤思齐、借梯爬楼<ul>
<li>如何争取跟优秀的人在一起<ol>
<li>不断的抛头露面</li>
<li>帮助可以帮助自己成就事业的人做事</li>
<li>与上司和比自己优秀的人士一起合作</li>
</ol>
</li>
</ul>
</li>
</ul>
<ol>
<li>尊重对方，严谨有致</li>
<li>切记奉承，要不卑不亢</li>
<li>态度自然，不必拘谨</li>
<li>陪衬得当，不可狂妄</li>
<li>主动真诚，做出姿态</li>
<li>求助求教，接受呵护</li>
</ol>
<ul>
<li>挑战自我，承担责任<ul>
<li>三条忠告<ol>
<li>全心全意工作</li>
<li>把自己视为合伙人</li>
<li>迎接变革的需求</li>
</ol>
</li>
</ul>
</li>
<li>自信独立，不随波逐流</li>
<li>敢于显示自己很重要</li>
<li>千万不能只知道抱怨上司</li>
<li>保持严谨认真的做事习惯</li>
<li>自主地做好手中的工作</li>
<li>踏踏实实地做好本职工作</li>
<li>丢掉工作散漫的坏习惯</li>
<li>不要让浮躁的性格困扰自己</li>
<li>不推诿，勇于承担责任</li>
<li>无论如何都不要拖延工作</li>
<li>糊弄工作只能是在糊弄自己</li>
<li>逊色的工作只会淘汰自己</li>
<li>千万别丢掉“得宠”之资</li>
<li>“一步登天”只会摔疼自己</li>
<li>别让“差不多”贻误了自己</li>
<li>能完成100%，就决不做99%</li>
</ul>
<h1 id="与上司相处"><a href="#与上司相处" class="headerlink" title="与上司相处"></a>与上司相处</h1><ul>
<li>不要做上司的“心腹”</li>
<li>适时恰当的赞美上司<ul>
<li>赞美上司，还要善于选择适当的场合</li>
<li>赞美上司，要学会巧借公众语言称赞</li>
<li>赞美上司，还要善于赞美不得志的上司</li>
</ul>
</li>
<li>主动与领导沟通</li>
<li>主动和上司保持联系 </li>
<li>用“心机”主动接近上司<ul>
<li>尽可能详细的了解上司</li>
<li>选择一个与领导尽可能近的位置</li>
<li>赢得上司青睐的方法 </li>
</ul>
</li>
<li>更有效的和上司沟通<ul>
<li>与上司沟通要简洁</li>
<li>与上司沟通要大度大气大方</li>
<li>与上司沟通，就要把自己先放一边 ——– 说话对事不对人</li>
</ul>
</li>
<li>四种和上司进行沟通的方法<ol>
<li>开诚布公式———提出问题，说出自己的理解认识，给出解决方案，寻求领导意思，执行领导的命令</li>
<li>先斩后奏式———因主客观原因导致的没有先汇报而是先解决的事，事后要将问题的分析方法，解决方法，实施方案以及结果做一份详尽的总结报告上交给领导</li>
<li>“含情脉脉”式——-通过交流一些工作上的问题来含蓄表达出个人的建议、需要</li>
<li>巧设比喻式———通过典型案例来暗示自己的意见和要求</li>
</ol>
</li>
<li>把话说到上司的心坎上</li>
<li>巧妙地为领导拾遗补缺<ol>
<li>诠释领导讲话的难点</li>
<li>强调领导的才干</li>
<li>化严肃为幽默</li>
<li>稳定情绪，委婉暗示</li>
</ol>
</li>
<li>工作中勤于请示汇报<ol>
<li>听懂上司的意图</li>
<li>探讨、磨合，达成共识</li>
<li>制定尽可能详尽的工作计划</li>
<li>随时向上司汇报任务的关键点</li>
<li>总结汇报</li>
</ol>
</li>
<li>用成功赢得上司的信任</li>
<li>工作中不要冲撞上司</li>
<li>处理好同上司之间的分歧<ol>
<li>圆融协调——领导不懂，下达了错误的指令<ol>
<li>私下向上司陈述意见，帮助上司做出正确的决策</li>
<li>如果上司采纳了下属的建议或意见，该下属有责任长期保守秘密</li>
<li>如果上司固执己见，那么无条件服从</li>
</ol>
</li>
<li>装聋作哑——不涉及到原则问题</li>
<li>棘手难题多权衡<ol>
<li>立刻插话纠正</li>
<li>提醒上司</li>
<li>暗示</li>
<li>事后补救</li>
<li>事后提醒</li>
</ol>
</li>
</ol>
</li>
<li>正确对待上司的批评</li>
<li>要善于服从自己的上司</li>
<li>正确化解来自上司的压力</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>博观约取，多读书读好书，丰富自己，变得睿智。</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>《晨间日记的奇迹》读书笔记</title>
    <url>/2016/10/27/Read-The-miracle-of-the-morning-journal/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天花了1天的时间读了《晨间日记的奇迹》，感觉整个人的认识发生了一些变化，下面把重要内容做一下摘抄总结。</p>
<h1 id="早上写日记的好处-——-提升效率"><a href="#早上写日记的好处-——-提升效率" class="headerlink" title="早上写日记的好处 —— 提升效率"></a>早上写日记的好处 —— 提升效率</h1><ul>
<li>可以做好一天的准备 — 计划性</li>
<li>可以正确的写出昨天发生的事 — 效率性&amp;忠诚性</li>
<li>可以中立的看待昨天 — 中立性</li>
<li>相对自由的时间 — 持续性</li>
<li>总结经验 — 活用性</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>日记 不等于 日志<br>日记 要记录 时间 天气 心情 — 因为这些有助于回忆和记录<br>不要投入过长时间 — 3分钟 — 日记私密性<br>晨间日记前7天只写好事 — 反省固然重要，但是成长更重要，持续性很重要 — 巴普洛夫的狗</p>
<h1 id="晨间日记2部分"><a href="#晨间日记2部分" class="headerlink" title="晨间日记2部分"></a>晨间日记2部分</h1><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><p>客观记录已经发生的事（昨天）— 经验智慧</p>
<h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h2><ul>
<li>今天应做的事 — 具体行动（来自昨天的总结</li>
<li>今天一定要做的事（紧急重要的事）— 变得更积极更主动</li>
<li>未来要做的事 — 不紧急但重要的事</li>
<li>连用日记 — 历史上的今天（过去一年同一天的事）</li>
</ul>
<h1 id="夜晚日记-VS-晨间日记"><a href="#夜晚日记-VS-晨间日记" class="headerlink" title="夜晚日记 VS 晨间日记"></a>夜晚日记 VS 晨间日记</h1><p>受当天情绪影响 — 更冷静</p>
<h1 id="梦想成真表"><a href="#梦想成真表" class="headerlink" title="梦想成真表"></a>梦想成真表</h1><table>
<thead>
<tr>
<th></th>
<th>过去</th>
<th>未来</th>
</tr>
</thead>
<tbody><tr>
<td>事实</td>
<td>IQ 智慧指数</td>
<td>NQ 人际关系指数</td>
</tr>
<tr>
<td>感情</td>
<td>EQ 情感指数</td>
<td>DQ 梦想指数</td>
</tr>
</tbody></table>
<ul>
<li>IQ — 晨间日记冷静回忆分析 — 提高决策正确性 IQ up</li>
<li>EQ — 冷静记录昨日的情绪／自省 — 变积极 EQ up</li>
<li>NQ — 总结昨天给今天设立“对／为XXX做某事” 很重要 NQ up</li>
<li>DQ — 不能只有眼前的事 每天都要确定一下自己的梦想 脸皮厚点没关系 重复或只有一句话也没关系 铭记于心最重要</li>
</ul>
<p>“忙碌”只是借口！“决心”才是问题！ 对未来充满期待的人才有行动力</p>
<h1 id="如何早起"><a href="#如何早起" class="headerlink" title="如何早起"></a>如何早起</h1><ul>
<li>设定起床音乐／用气味（精油）刺激起床／光线-电动窗帘早起自动拉开</li>
<li>早起后淋浴 — 配合音乐／冥想／呐喊 — 让自己充满动力保持清醒</li>
</ul>
<h1 id="写日记的五大好处"><a href="#写日记的五大好处" class="headerlink" title="写日记的五大好处"></a>写日记的五大好处</h1><ul>
<li>提升写作能力</li>
<li>谈话题材源源不断</li>
<li>提高贵人运</li>
<li>返现自我肉体和精神的状态与模式</li>
<li>在自己身上挖宝，彻底改变人生</li>
</ul>
<h1 id="记录的日记要常拿出来看看"><a href="#记录的日记要常拿出来看看" class="headerlink" title="记录的日记要常拿出来看看"></a>记录的日记要常拿出来看看</h1><p>记录日记时 — 问问自己的灵魂 然后写下真心话 — 灵魂日记<br><code>六度空间理论</code></p>
<h1 id="七种成功者的习惯"><a href="#七种成功者的习惯" class="headerlink" title="七种成功者的习惯"></a>七种成功者的习惯</h1><ul>
<li>习惯之一：积极主动别指望谁能推你走 — 主动行动，迈出第一步</li>
<li>习惯之二：以终为始忠于自己的人生计划。— 设立人生目标并坚持</li>
<li>习惯之三：要事第一选择当前该做的事</li>
<li>习惯之四：追求双赢远离角斗场</li>
<li>习惯之五：善于沟通换位思考的原则</li>
<li>习惯之六：统合综效 1+1可以大于2</li>
<li>习惯之七：不断更新全方位平衡自我</li>
</ul>
<p>早睡是为了身体，早起是为了我们的内心。— sugiponn</p>
<h1 id="晨间日记的格式"><a href="#晨间日记的格式" class="headerlink" title="晨间日记的格式"></a>晨间日记的格式</h1><p>晨间日记必须要设立的栏目 — 工作／金钱／健康／人际关系<br>要记下当日的日期／天气／温度／湿度</p>
<p>纬度标签<br>工作方面：</p>
<ul>
<li>能力开发／经营／管理／进货／工作人员／学习／资格／活动／企划案／想法／推广<br>金钱方面：</li>
<li>收入／指出／购入／股票／资产／储蓄／家用<br>健康方面：</li>
<li>饮食／运动／性／减肥／身体状况／锻炼身体／体重／脂肪<br>人际关系方面：</li>
<li>父母／家人／小孩／亲戚／情人／工作伙伴／朋友／熟人／联络事项／人脉网络<br>兴趣方面以及其他：</li>
<li>义工活动／阅读／运动／打扮／电影／音乐／游戏／喜欢的物品／今天必须要注意的事／美容／开心的事／购物</li>
</ul>
<p>劳动 — 职业 — 工作 — <em>乐趣</em></p>
<h1 id="三大原则和七大作战守则"><a href="#三大原则和七大作战守则" class="headerlink" title="三大原则和七大作战守则"></a>三大原则和七大作战守则</h1><ul>
<li><p>原则1:时间不超过3分钟 — 减少养成习惯的成本</p>
</li>
<li><p>原则2:决定好写晨间日记的地方 — 为了养成习惯</p>
</li>
<li><p>原则3:只写一个字也没关系 — 不要有压力</p>
</li>
<li><p>作战守则1:开心写日记 — 反省固然重要，鼓励更有作用 — 开始写晨间日记前七天只写好事</p>
</li>
<li><p>作战守则2:ONE-TWO作战 — 把动作分布容易养成习惯 — 形成固定动作</p>
</li>
<li><p>作战守则3:巴普洛夫的狗 — 开始写日记时候要有一个仪式 — 心理暗示</p>
</li>
<li><p>作战守则4:奖励自己 — 当习惯养成并坚持到一定时间，给自己一个奖励</p>
</li>
<li><p>作战守则5:宣告天下 — 借由他人的鼓励或压力形成动力／也可找到同志</p>
</li>
<li><p>作战守则6:一千日作战法 — 不管什么样的习惯坚持1000日就会成为永远的习惯 — 具体做法为记录 第XXX篇 晨间日记</p>
</li>
<li><p>作战守则7:为了别人 — 写晨间日记不只是为了自己，而且更是为了别人，身边人的幸福最终会影响到自己</p>
</li>
</ul>
<h1 id="应该先肯定自己，给自己打100分"><a href="#应该先肯定自己，给自己打100分" class="headerlink" title="应该先肯定自己，给自己打100分"></a>应该先肯定自己，给自己打100分</h1><ul>
<li>“总之，先… 病” 没有目标／没有梦想 — 回顾时一定会后悔！</li>
<li>“假如…，应该 病” 无法满足／没有动力 — 焦躁不安</li>
<li>共同点：失落感／空虚／</li>
</ul>
<h2 id="解决办法—-设立一个情境"><a href="#解决办法—-设立一个情境" class="headerlink" title="解决办法— 设立一个情境"></a>解决办法— 设立一个情境</h2><p>例：我要建立一个幸福的家庭 —&gt; 因此我要创造很多快乐的回忆 —&gt; 为了制造很多快乐的回忆 —&gt; 我必须要到很多的地方去看看 —&gt; 为了去很多地方看看，我觉得有辆车会更方便 —&gt; 买车 —&gt; 考驾照</p>
<p>不要总想自己哪里欠缺，要想自己想要得到什么，并且为了目标努力，你就会变的更完美。<br>拥有一个敢于大声喊出的梦想，不要羞涩，要为了梦想一步步的前进，最终达到梦想。</p>
<h1 id="提到的另外的书"><a href="#提到的另外的书" class="headerlink" title="提到的另外的书"></a>提到的另外的书</h1><p>《培育梦想种子》《日记的力量》《成功人士的七个习惯》</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>SSR</title>
    <url>/2020/02/11/SSR/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="什么是SSR"><a href="#什么是SSR" class="headerlink" title="什么是SSR"></a>什么是SSR</h1><h2 id="传统浏览器的vue纯浏览器渲染"><a href="#传统浏览器的vue纯浏览器渲染" class="headerlink" title="传统浏览器的vue纯浏览器渲染"></a>传统浏览器的vue纯浏览器渲染</h2><p>浏览器请求服务器，服务器返回静态资源 ，客户端负责渲染js</p>
<h2 id="ssr"><a href="#ssr" class="headerlink" title="ssr"></a>ssr</h2><p>浏览器请求服务器，node服务端渲染js后，返回对应的页面返回给浏览器</p>
<h2 id="SSR需要那些东西"><a href="#SSR需要那些东西" class="headerlink" title="SSR需要那些东西"></a>SSR需要那些东西</h2><h2 id="手写SSR"><a href="#手写SSR" class="headerlink" title="手写SSR"></a>手写SSR</h2><p>特性：</p>
<ul>
<li>每一次访问必须新建一个vue实例</li>
<li>只会触发组件的 beforeCreate和created钩子</li>
</ul>
<p>核心库</p>
<ul>
<li>vue</li>
<li>vue-server-renderer<h1 id="vue-next"><a href="#vue-next" class="headerlink" title="vue + next"></a>vue + next</h1><blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>
<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><!-- more -->
<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><!-- more -->]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>服务端渲染</tag>
        <tag>同构技术</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里镜像加速brew（转载）</title>
    <url>/2020/03/03/Speeding-up-brew-with-Ali-mirroring/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="使用-Alibaba-的-Homebrew-镜像源进行加速"><a href="#使用-Alibaba-的-Homebrew-镜像源进行加速" class="headerlink" title="使用 Alibaba 的 Homebrew 镜像源进行加速"></a>使用 Alibaba 的 Homebrew 镜像源进行加速</h1><p>平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：</p>
<ul>
<li>brew.git</li>
<li>homebrew-core.git</li>
<li>homebrew-bottles<br>通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址</li>
</ul>
<h2 id="1-替换-还原-brew-git-仓库地址"><a href="#1-替换-还原-brew-git-仓库地址" class="headerlink" title="1. 替换 / 还原 brew.git 仓库地址"></a>1. 替换 / 还原 brew.git 仓库地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换成阿里巴巴的 brew.git 仓库地址:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原为官方提供的 brew.git 仓库地址</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br></pre></td></tr></table></figure>

<h2 id="2-替换-还原-homebrew-core-git-仓库地址"><a href="#2-替换-还原-homebrew-core-git-仓库地址" class="headerlink" title="2. 替换 / 还原 homebrew-core.git 仓库地址"></a>2. 替换 / 还原 homebrew-core.git 仓库地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换成阿里巴巴的 homebrew-core.git 仓库地址:</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原为官方提供的 homebrew-core.git 仓库地址</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>

<h2 id="3-替换-还原-homebrew-bottles-访问地址"><a href="#3-替换-还原-homebrew-bottles-访问地址" class="headerlink" title="3. 替换 / 还原 homebrew-bottles 访问地址"></a>3. 替换 / 还原 homebrew-bottles 访问地址</h2><p>这个步骤跟你的 macOS 系统使用的 shell 版本有关系</p>
<p>所以，先来查看当前使用的 shell 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你的输出结果是 /bin/zsh，参考下方的 zsh 终端操作方式</span></span><br><span class="line"><span class="comment"># 如果你的输出结果是 /bin/bash，参考下方的 bash 终端操作方式</span></span><br></pre></td></tr></table></figure>
<h3 id="3-1-zsh-终端操作方式"><a href="#3-1-zsh-终端操作方式" class="headerlink" title="3.1 zsh 终端操作方式"></a>3.1 zsh 终端操作方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换成阿里巴巴的 homebrew-bottles 访问地址:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原为官方提供的 homebrew-bottles 访问地址</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"><span class="comment"># 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<h3 id="3-2-bash-终端操作方式"><a href="#3-2-bash-终端操作方式" class="headerlink" title="3.2 bash 终端操作方式"></a>3.2 bash 终端操作方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换 homebrew-bottles 访问 URL:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#x27;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原为官方提供的 homebrew-bottles 访问地址</span></span><br><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="comment"># 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置</span></span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>转载自：<a href="http://www.xiegangd.com/article/154055689187484">http://www.xiegangd.com/article/154055689187484</a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>HomeBrew</tag>
        <tag>Mac</tag>
        <tag>海外提速</tag>
      </tags>
  </entry>
  <entry>
    <title>v8引擎如何回收内存（笔记）</title>
    <url>/2020/02/23/V8-engine-memory-management-and-optimization/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="V8引擎如何回收垃圾"><a href="#V8引擎如何回收垃圾" class="headerlink" title="V8引擎如何回收垃圾"></a>V8引擎如何回收垃圾</h1><h2 id="为什么我们要关注内存"><a href="#为什么我们要关注内存" class="headerlink" title="为什么我们要关注内存"></a>为什么我们要关注内存</h2><ul>
<li>防止页面占用内存过大，引起客户端卡顿，甚至无响应</li>
<li>Node使用的也是v8，内存对于后端服务的性能至关重要。因为服务的持久性，后端更容易造成内存溢出<h2 id="v8引擎的内存回收机制"><a href="#v8引擎的内存回收机制" class="headerlink" title="v8引擎的内存回收机制"></a>v8引擎的内存回收机制</h2><h3 id="v8的内存分配"><a href="#v8的内存分配" class="headerlink" title="v8的内存分配"></a>v8的内存分配</h3>新生代内存空间</li>
<li>from</li>
<li>to<br>老生代内存空间<h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3></li>
<li>和操作系统有关 — 64位（1.4G）32位（0.7G）</li>
<li>64位下 新生代（64MB） 老生代（1400MB）</li>
<li>32位下 新生代（16MB） 老生代（700MB）</li>
</ul>
<p>为什么不占多一点内存</p>
<ul>
<li>js设计之初是为浏览器<ul>
<li>前端特点 — 不持久化，执行一遍就回收了，所以1.4G够用了</li>
<li>js回收内存会暂停执行代码</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>新生代简单的说就是<strong><em>复制</em></strong></p>
<ul>
<li>新生代用来放新产生的变量，根据条件放到老生代，有用的放到to里（把有用的留一边，清空另一边，往复进行）</li>
<li>算法复杂度（时间复杂度，空间复杂度）—- 牺牲空间换时间</li>
</ul>
<p>老生代就是<strong><em>标记、删除、整理</em></strong></p>
<ul>
<li>为什么要整理<ul>
<li>数组是需要连续的空间</li>
</ul>
</li>
</ul>
<p>新生代如何晋升到老生代</p>
<ul>
<li>变量是否经过回收，第二次回收放到老生代，第一次回收放到To</li>
<li>To空间使用了25%，放到老生代</li>
</ul>
<h3 id="V8是如何处理变量的"><a href="#V8是如何处理变量的" class="headerlink" title="V8是如何处理变量的"></a>V8是如何处理变量的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器查看内存</span></span><br><span class="line"><span class="built_in">window</span>.performance</span><br><span class="line"><span class="comment">// nodejs查看内存 --- nodejs是c++的，可以拓宽内存</span></span><br><span class="line">process.memoryUsage()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿内存的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> mem = process.memoryUsage();</span><br><span class="line">	<span class="keyword">var</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (bytes/<span class="number">1024</span>/<span class="number">1024</span>).toFixed(<span class="number">2</span>)+<span class="string">'MB'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'heapTotal:'</span>+format(mem.heapTotal)+<span class="string">'heapUsed:'</span>+format(mem.heapUsed))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量处理"><a href="#变量处理" class="headerlink" title="变量处理"></a>变量处理</h3><ul>
<li>内存主要就是存储变量等数据的</li>
<li>局部变量当程序执行结束，且没有引用的时候就会随着消失 — 可以被回收但不是说会马上回收</li>
<li>全局对象会始终存活到程序运行结束</li>
</ul>
<h1 id="如何查看V8内存使用情况"><a href="#如何查看V8内存使用情况" class="headerlink" title="如何查看V8内存使用情况"></a>如何查看V8内存使用情况</h1><h2 id="如何注意内存使用"><a href="#如何注意内存使用" class="headerlink" title="如何注意内存使用"></a>如何注意内存使用</h2><h3 id="优化内存的技巧"><a href="#优化内存的技巧" class="headerlink" title="优化内存的技巧"></a>优化内存的技巧</h3><ul>
<li>尽量不要定义全局变量</li>
<li>全局变量记得手动销毁掉<ul>
<li>不推荐开发时写delete – 支持有问题，严格模式有bug</li>
<li>赋值为 undefined/null  undefined 是变量 null 是保留字</li>
</ul>
</li>
<li>用匿名自执行函数变全局为局部<ul>
<li><code>(function(){})()</code> </li>
</ul>
</li>
<li>尽量避免使用闭包 —- 错误的观点，ie5时代的问题 —- 尽量避免使用闭包引用</li>
</ul>
<p>闭包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> size = <span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">	<span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(size)</span><br><span class="line">	<span class="keyword">return</span> arr1</span><br><span class="line">&#125;</span><br><span class="line">a() <span class="comment">// 这样就没问题</span></span><br><span class="line"><span class="keyword">var</span> b = a() <span class="comment">// 因为引用所以无法销毁</span></span><br></pre></td></tr></table></figure>
<h3 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h3><ul>
<li>滥用缓存</li>
<li>大内存量操作</li>
</ul>
<p>所有的优化都可以用缓存来解决，缓存通常都在全局，缓存可以直接拿来用；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">	a.push(<span class="keyword">new</span> <span class="built_in">Array</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加缓存锁</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.length&gt;<span class="number">4</span>)&#123;</span><br><span class="line">		a.shift();</span><br><span class="line">	&#125;</span><br><span class="line">	a.push(<span class="keyword">new</span> <span class="built_in">Array</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不要用v8来缓存<ul>
<li>一定要用要的话加锁</li>
</ul>
</li>
</ul>
<p>nodejs中读取大文件要用流的形式，不要用读文件到buffer<br>fs.readFile()<br>fs.createReadStream()</p>
<p>浏览器中，大文件上传记得切片<br>file.slice(0,1000)<br>file.slice(1000,2000)</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>内存回收</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode ESLint JS代码静态检测工具</title>
    <url>/2017/10/12/VSCode-ESLint/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VSCode是新一代IDE，方便灵活的插件安装方式让它强大无比，对前端友好，让它成为了越来越多前端开发者的首选IDE，编辑器虽好，但是要自己安装符合自己需求的插件才行，下面介绍一款插件，名叫ESLint，是用来静态检测js代码的工具，让你的js代码在编辑过程中就能找到错误，提高代码质量，好了废话不多说下面介绍如何安装和配置这款插件。</p>
<span id="more"></span>
<h1 id="安装ESLint插件"><a href="#安装ESLint插件" class="headerlink" title="安装ESLint插件"></a>安装ESLint插件</h1><p>打开VSCode编辑器，在左侧右下角有一个安装插件的图标，点击后就可以打开插件市场，输入ESLint，就会有个黄色的图标出现在你面前，不用犹豫双击它，稍等一会它就安装完了，是不是超简单。</p>
<h1 id="安装NPM依赖"><a href="#安装NPM依赖" class="headerlink" title="安装NPM依赖"></a>安装NPM依赖</h1><p>ESLint插件运行需要一些依赖，对于用过npm包管理工具的人来讲小意思啦，我把代码放到下面，需要的直接粘贴运行就好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局安装eslint</span><br><span class="line">npm i eslint -g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果用到html中的js校验</span><br><span class="line">npm i eslint-plugin-html -g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果用到es2015语法</span><br><span class="line">npm i babel-eslint -g</span><br></pre></td></tr></table></figure>
<h1 id="配置eslint配置文件到项目根目录"><a href="#配置eslint配置文件到项目根目录" class="headerlink" title="配置eslint配置文件到项目根目录"></a>配置eslint配置文件到项目根目录</h1><p>配置文件名称如下：<br><strong>eslintrc.json</strong><br>内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;plugins&quot;: [</span><br><span class="line">                &#x2F;&#x2F; &quot;react&quot;,</span><br><span class="line">                &quot;html&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;env&quot;: &#123;</span><br><span class="line">                &quot;node&quot;: true,</span><br><span class="line">                &quot;jquery&quot;: true,</span><br><span class="line">                &quot;es6&quot;: true,</span><br><span class="line">                &quot;browser&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;globals&quot;: &#123;</span><br><span class="line">                &quot;angular&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class="line">        &quot;rules&quot;: &#123;</span><br><span class="line">                &#x2F;&#x2F;官方文档 http:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;rules&#x2F;</span><br><span class="line">                &#x2F;&#x2F;参数：0 关闭，1 警告，2 错误</span><br><span class="line">                &#x2F;&#x2F; &quot;quotes&quot;: [0, &quot;single&quot;],                  &#x2F;&#x2F;建议使用单引号</span><br><span class="line">                &#x2F;&#x2F; &quot;no-inner-declarations&quot;: [0, &quot;both&quot;],     &#x2F;&#x2F;不建议在&#123;&#125;代码块内部声明变量或函数</span><br><span class="line">                &quot;no-extra-boolean-cast&quot;: 1, &#x2F;&#x2F;多余的感叹号转布尔型</span><br><span class="line">                &quot;no-extra-semi&quot;: 1, &#x2F;&#x2F;多余的分号</span><br><span class="line">                &quot;no-extra-parens&quot;: 0, &#x2F;&#x2F;多余的括号</span><br><span class="line">                &quot;no-empty&quot;: 1, &#x2F;&#x2F;空代码块</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;使用前未定义</span><br><span class="line">                &quot;no-use-before-define&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &quot;nofunc&quot;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &quot;complexity&quot;: [0, 10], &#x2F;&#x2F;圈复杂度大于*</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;定义数组或对象最后多余的逗号</span><br><span class="line">                &quot;comma-dangle&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &quot;never&quot;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F; 不允许对全局变量赋值,如 window &#x3D; &#39;abc&#39;</span><br><span class="line">                &quot;no-global-assign&quot;: [&quot;error&quot;, &#123;</span><br><span class="line">                        &#x2F;&#x2F; 定义例外</span><br><span class="line">                        &#x2F;&#x2F; &quot;exceptions&quot;: [&quot;Object&quot;]</span><br><span class="line">                &#125;],</span><br><span class="line">                &quot;no-var&quot;: 0, &#x2F;&#x2F;用let或const替代var</span><br><span class="line">                &quot;no-const-assign&quot;: 2, &#x2F;&#x2F;不允许const重新赋值</span><br><span class="line">                &quot;no-class-assign&quot;: 2, &#x2F;&#x2F;不允许对class重新赋值</span><br><span class="line">                &quot;no-debugger&quot;: 1, &#x2F;&#x2F;debugger 调试代码未删除</span><br><span class="line">                &quot;no-console&quot;: 0, &#x2F;&#x2F;console 未删除</span><br><span class="line">                &quot;no-constant-condition&quot;: 2, &#x2F;&#x2F;常量作为条件</span><br><span class="line">                &quot;no-dupe-args&quot;: 2, &#x2F;&#x2F;参数重复</span><br><span class="line">                &quot;no-dupe-keys&quot;: 2, &#x2F;&#x2F;对象属性重复</span><br><span class="line">                &quot;no-duplicate-case&quot;: 2, &#x2F;&#x2F;case重复</span><br><span class="line">                &quot;no-empty-character-class&quot;: 2, &#x2F;&#x2F;正则无法匹配任何值</span><br><span class="line">                &quot;no-invalid-regexp&quot;: 2, &#x2F;&#x2F;无效的正则</span><br><span class="line">                &quot;no-func-assign&quot;: 2, &#x2F;&#x2F;函数被赋值</span><br><span class="line">                &quot;valid-typeof&quot;: 1, &#x2F;&#x2F;无效的类型判断</span><br><span class="line">                &quot;no-unreachable&quot;: 2, &#x2F;&#x2F;不可能执行到的代码</span><br><span class="line">                &quot;no-unexpected-multiline&quot;: 2, &#x2F;&#x2F;行尾缺少分号可能导致一些意外情况</span><br><span class="line">                &quot;no-sparse-arrays&quot;: 1, &#x2F;&#x2F;数组中多出逗号</span><br><span class="line">                &quot;no-shadow-restricted-names&quot;: 2, &#x2F;&#x2F;关键词与命名冲突</span><br><span class="line">                &quot;no-undef&quot;: 1, &#x2F;&#x2F;变量未定义</span><br><span class="line">                &quot;no-unused-vars&quot;: 1, &#x2F;&#x2F;变量定义后未使用</span><br><span class="line">                &quot;no-cond-assign&quot;: 2, &#x2F;&#x2F;条件语句中禁止赋值操作</span><br><span class="line">                &quot;no-native-reassign&quot;: 2, &#x2F;&#x2F;禁止覆盖原生对象</span><br><span class="line">                &quot;no-mixed-spaces-and-tabs&quot;: 0,</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;代码风格优化 --------------------------------------</span><br><span class="line">                &quot;no-irregular-whitespace&quot;: 0,</span><br><span class="line">                &quot;no-else-return&quot;: 0, &#x2F;&#x2F;在else代码块中return，else是多余的</span><br><span class="line">                &quot;no-multi-spaces&quot;: 0, &#x2F;&#x2F;不允许多个空格</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;object直接量建议写法 : 后一个空格前面不留空格</span><br><span class="line">                &quot;key-spacing&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;beforeColon&quot;: false,</span><br><span class="line">                                &quot;afterColon&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &quot;block-scoped-var&quot;: 1, &#x2F;&#x2F;变量应在外部上下文中声明，不应在&#123;&#125;代码块中</span><br><span class="line">                &quot;consistent-return&quot;: 1, &#x2F;&#x2F;函数返回值可能是不同类型</span><br><span class="line">                &quot;accessor-pairs&quot;: 1, &#x2F;&#x2F;object getter&#x2F;setter方法需要成对出现</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;换行调用对象方法  点操作符应写在行首</span><br><span class="line">                &quot;dot-location&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &quot;property&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;no-lone-blocks&quot;: 1, &#x2F;&#x2F;多余的&#123;&#125;嵌套</span><br><span class="line">                &quot;no-labels&quot;: 1, &#x2F;&#x2F;无用的标记</span><br><span class="line">                &quot;no-extend-native&quot;: 1, &#x2F;&#x2F;禁止扩展原生对象</span><br><span class="line">                &quot;no-floating-decimal&quot;: 1, &#x2F;&#x2F;浮点型需要写全 禁止.1 或 2.写法</span><br><span class="line">                &quot;no-loop-func&quot;: 1, &#x2F;&#x2F;禁止在循环体中定义函数</span><br><span class="line">                &quot;no-new-func&quot;: 1, &#x2F;&#x2F;禁止new Function(...) 写法</span><br><span class="line">                &quot;no-self-compare&quot;: 1, &#x2F;&#x2F;不允与自己比较作为条件</span><br><span class="line">                &quot;no-sequences&quot;: 1, &#x2F;&#x2F;禁止可能导致结果不明确的逗号操作符</span><br><span class="line">                &quot;no-throw-literal&quot;: 1, &#x2F;&#x2F;禁止抛出一个直接量 应是Error对象</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;不允return时有赋值操作</span><br><span class="line">                &quot;no-return-assign&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &quot;always&quot;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;不允许重复声明</span><br><span class="line">                &quot;no-redeclare&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;builtinGlobals&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;不执行的表达式</span><br><span class="line">                &quot;no-unused-expressions&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;allowShortCircuit&quot;: true,</span><br><span class="line">                                &quot;allowTernary&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;no-useless-call&quot;: 1, &#x2F;&#x2F;无意义的函数call或apply</span><br><span class="line">                &quot;no-useless-concat&quot;: 1, &#x2F;&#x2F;无意义的string concat</span><br><span class="line">                &quot;no-void&quot;: 1, &#x2F;&#x2F;禁用void</span><br><span class="line">                &quot;no-with&quot;: 1, &#x2F;&#x2F;禁用with</span><br><span class="line">                &quot;space-infix-ops&quot;: 0, &#x2F;&#x2F;操作符前后空格</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;jsdoc</span><br><span class="line">                &quot;valid-jsdoc&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;requireParamDescription&quot;: true,</span><br><span class="line">                                &quot;requireReturnDescription&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;标记未写注释</span><br><span class="line">                &quot;no-warning-comments&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;terms&quot;: [</span><br><span class="line">                                        &quot;todo&quot;,</span><br><span class="line">                                        &quot;fixme&quot;,</span><br><span class="line">                                        &quot;any other term&quot;</span><br><span class="line">                                ],</span><br><span class="line">                                &quot;location&quot;: &quot;anywhere&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;curly&quot;: 0 &#x2F;&#x2F;if、else、while、for代码块用&#123;&#125;包围</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eslint就是根据这个配置表来进行js语法校验的。</p>
<h1 id="最后重启VSCode完成插件安装"><a href="#最后重启VSCode完成插件安装" class="headerlink" title="最后重启VSCode完成插件安装"></a>最后重启VSCode完成插件安装</h1><p>重启后控制台显示ESLint server is running说明插件已经生效，好啦接下来就愉快的写代码吧。</p>
]]></content>
      <categories>
        <category>效率工具</category>
        <category>VSCode插件</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础</title>
    <url>/2017/08/30/Vue-basic/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司技术选型选择了VUE，下面就记录一下在学习Vue中遇到的一些知识点，有些在官方手册里已经讲的很详细了，这里就简单带过，主要对cli产生的以及自行添加的一些项目目录进行一下解释，希望对正在学习Vue的同学提供一点帮助，如果本文有谬误之处还请各位指出，谢谢各位支持。</p>
<span id="more"></span>
<h3 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global vue-cli</span><br><span class="line">vue init webpack my-project</span><br><span class="line">cd my-project</span><br><span class="line">npm install（推荐用cnpm install）</span><br><span class="line">如果没有cnpm ，先安装cnpm镜像</span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h3 id="目录讲解"><a href="#目录讲解" class="headerlink" title="目录讲解"></a>目录讲解</h3><blockquote>
<ul>
<li>build和config ：项目开发和打包时候的相关配置；</li>
<li>node_modules ：项目所需要的依赖文件；</li>
<li>src ：主应用/页面相关文件；<ul>
<li>assets ： 静态资源文件；</li>
<li>components ：组件；</li>
<li>res：资源<ul>
<li>css： 公共css或是css预处理文件；</li>
<li>js：   公共js文件</li>
<li>img：公共图片</li>
</ul>
</li>
<li>router ：路由配置文件；</li>
<li>views ： 视图文件，其实也是vue组件。按照业务功能划分模块；</li>
<li>vuex : 状态管理的配置文件；</li>
<li>App.vue : 主组件；</li>
<li>main.js： 入口文件，初始化vue实例并使用需要的插件</li>
</ul>
</li>
<li>index.html ： 主html页面；</li>
<li>dist：webpack打包生成的文件；</li>
<li>package.json：记录依赖相关信息</li>
</ul>
</blockquote>
<h3 id="文件的加载顺序"><a href="#文件的加载顺序" class="headerlink" title="文件的加载顺序:"></a>文件的加载顺序:</h3><p>当我们执行命令 <code>npm run dev</code>的时候根据配置文件<code>dev-server.js</code>里的相关配置去加载<code>webpack</code>的相关配置文件 在<code>webpack.base.conf</code>里面<code>entry</code>入口文件就配置了<code>app：&#39;./src/main.js&#39;</code> </p>
<p>所以当我们在运行<code>npm run dev</code>的时候就开始通过<code>main.js</code>执行了。<code>main.js</code> 初始化vue实例并且加载相关配置插件，然后通过<code>app.vue</code>文件去访问各个组件</p>
<h3 id="Build-dev-server-js主要完成以下几件事情："><a href="#Build-dev-server-js主要完成以下几件事情：" class="headerlink" title="Build/dev-server.js主要完成以下几件事情："></a>Build/dev-server.js主要完成以下几件事情：</h3><ol>
<li>检查node和npm的版本；</li>
<li>引入相关插件和配置；</li>
<li>创建express服务器和webpack编译器；</li>
<li>配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware）；</li>
<li>挂载代理服务和中间件；</li>
<li>配置静态资源；</li>
<li>启动服务器监听特定端口（8080）；</li>
<li>自动打开浏览器并打开特定网址（localhost:8080）；</li>
</ol>
<h3 id="Build-huild-js主要完成以下几件事情："><a href="#Build-huild-js主要完成以下几件事情：" class="headerlink" title="Build/huild.js主要完成以下几件事情："></a>Build/huild.js主要完成以下几件事情：</h3><ol>
<li>loading动画；</li>
<li>删除创建目标文件夹；</li>
<li>webpack编译；</li>
<li>输出信息</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h4><p>设置转码的规则和插件（使用es6语法必须安装插件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-preset-es2015</span><br></pre></td></tr></table></figure>

<p>presets 字段是用来设定转码规则;</p>
<h4 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h4><p>配置文件编码格式的文件</p>
<ul>
<li>indent_style:  设置缩进风格，tab或者空格;</li>
<li>indent_size:  缩进的宽度;</li>
<li>tab_width:   设置tab的列数。默认是indent_size;</li>
<li>end_of_line： 换行符，lf、cr和crlf;</li>
<li>charset：  编码;</li>
<li>trim_trailing_whitespace： 设为true表示会除去换行行首的任意空白字符;</li>
<li>insert_final_newline:   设为true表明使文件以一个空白行结尾;</li>
<li>root: 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件;</li>
</ul>
<h4 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a>.eslintignore</h4><p>忽略不符合eslint规范的文件, （一般会忽略掉第三方引用的插件）</p>
<h4 id="eslintrc-js"><a href="#eslintrc-js" class="headerlink" title=".eslintrc.js"></a>.eslintrc.js</h4><p>定义代码规则</p>
<h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p>配置文件，用于配置不需要加入版本管理的文件</p>
<h3 id="VUE-文件解释"><a href="#VUE-文件解释" class="headerlink" title=".VUE 文件解释"></a>.VUE 文件解释</h3><ul>
<li>template： 展示模板</li>
<li>import ： 导入组件已经js文件</li>
<li>export default： <ul>
<li>data：数据源；</li>
<li>methods：方法；                </li>
<li>mounted：页面加载之后执行的方法；    </li>
<li>created：页面生成时加载的方法；</li>
</ul>
</li>
<li>style：  样式代码  其中scoped表示样式作用范围为本vue文件</li>
</ul>
<h3 id="网络访问"><a href="#网络访问" class="headerlink" title="网络访问"></a>网络访问</h3><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><ol>
<li>发送请求：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios#request(config)；</span><br><span class="line">axios#get(url[, config])；</span><br><span class="line">axios#delete(url[, config])；</span><br><span class="line">axios#head(url[, config])；</span><br><span class="line">axios#post(url[, data[, config]])；</span><br><span class="line">axios#put(url[, data[, config]])；</span><br><span class="line">axios#patch(url[, data[, config]])；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>处理响应：</li>
</ol>
<ul>
<li>Promise语法；</li>
<li>处理结果：then；</li>
<li>处理异常：catch；</li>
</ul>
<ol start="3">
<li>拦截器（use/reject）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios.interceptors.response.use；</span><br><span class="line">axios.interceptors.rquest.use；</span><br><span class="line">reject(移除请求拦截)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>参数：</li>
</ol>
<ul>
<li>json（默认）；</li>
<li>qs；</li>
</ul>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ul>
<li>Prpos：父组件对子组件；</li>
<li>自定义事件：子组件对父组件；</li>
<li>消息总线：任意两个组件；</li>
<li>状态管理：Vuex（适用于大型单页面开发）</li>
</ul>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li>配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      name: &#39;Hello&#39;,</span><br><span class="line">      component: Hello</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导航</li>
</ol>
<ul>
<li>push</li>
<li>replace</li>
<li>go</li>
</ul>
<ol start="3">
<li>参数传递</li>
</ol>
<ul>
<li>RESTful url参数</li>
<li>参数查询 query</li>
<li>锚点  hash: ‘#data’</li>
</ul>
<ol start="4">
<li>嵌套路由</li>
</ol>
<ul>
<li>Children</li>
</ul>
<ol start="5">
<li>钩子</li>
</ol>
<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteLeave</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><blockquote>
<p>Vuex是什么？</p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<ul>
<li>state里面就是存放的我们所要用到的状态；</li>
<li>mutations就是存放如何更改状态的方法 ，同步操作；</li>
<li>getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。</li>
<li>actions就是mutation的加强版，它可以通过commit</li>
<li>mutations中的方法来改变状态，最重要的是它可以进行异步操作。 </li>
<li>modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。</li>
</ul>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue VSCode Snippets 自动生成Vue代码片段的VSCode扩展</title>
    <url>/2017/08/30/Vue-VSCode-Snippets/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现代化的IDE已经把开发者变得越来越懒，但是我觉得这样挺好的，让工具完成手工反复重复的工作，提高工作效率的同时降低开发者的疲劳感，Vue VSCode Snippets就是这样一个VSC插件，它可以用简单的几个字母就敲出一整块代码片段，在学习和做VUE项目时可以极大地提高工作效率，下面就介绍一下插件的常见命令。</p>
<span id="more"></span>

<p>此插件可用比较简单的写法生成代码片段，非常适合开发工作，减少代码工作量。</p>
<p>Script</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>vbase</td>
<td>Single file component base</td>
</tr>
<tr>
<td>vbase</td>
<td>Single file component base</td>
</tr>
<tr>
<td>vdata</td>
<td>Component data as a function</td>
</tr>
<tr>
<td>vmethod</td>
<td>Vue method</td>
</tr>
<tr>
<td>vcomputed</td>
<td>Vue computed property</td>
</tr>
<tr>
<td>vwatcher</td>
<td>Vue watcher with new and old value args</td>
</tr>
<tr>
<td>vprops</td>
<td>Props with type and default</td>
</tr>
<tr>
<td>vimport</td>
<td>Import one component into another</td>
</tr>
<tr>
<td>vimport-c</td>
<td>Import one component into another within the export statement</td>
</tr>
<tr>
<td>vimport-export</td>
<td>Import one component into another and use it within the export statement</td>
</tr>
<tr>
<td>vfilter</td>
<td>Vue filter</td>
</tr>
<tr>
<td>vmixin</td>
<td>Create a Vue Mixin</td>
</tr>
<tr>
<td>vmixin-use</td>
<td>Bring a mixin into a component to use</td>
</tr>
<tr>
<td>vc-direct</td>
<td>Vue create a custom directive</td>
</tr>
<tr>
<td>vimport-lib</td>
<td>Import a library</td>
</tr>
<tr>
<td>vimport-gsap</td>
<td>Import GreenSock with Timeline and Eases</td>
</tr>
<tr>
<td>vanimhook-js</td>
<td>Using the Transition component JS hooks in methods</td>
</tr>
</tbody></table>
<!-- more -->
<p>Template</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>vfor</td>
<td>v-for directive</td>
</tr>
<tr>
<td>vmodel</td>
<td>Semantic v-model directive</td>
</tr>
<tr>
<td>vmodel-num</td>
<td>Semantic v-model number directive</td>
</tr>
<tr>
<td>von</td>
<td>v-on click handler with arguments</td>
</tr>
<tr>
<td>vel-props</td>
<td>Component element with props</td>
</tr>
<tr>
<td>vsrc</td>
<td>Image src binding</td>
</tr>
<tr>
<td>vstyle</td>
<td>Inline style binding</td>
</tr>
<tr>
<td>vstyle-obj</td>
<td>Inline style binding with objects</td>
</tr>
<tr>
<td>vclass</td>
<td>Class binding</td>
</tr>
<tr>
<td>vclass-obj</td>
<td>Class binding with objects</td>
</tr>
<tr>
<td>vclass-obj-mult</td>
<td>Multiple conditional class bindings</td>
</tr>
<tr>
<td>vanim</td>
<td>Transition component with JS hooks</td>
</tr>
</tbody></table>
<p>Vuex</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>vstore</td>
<td>Base for Vuex store.js</td>
</tr>
<tr>
<td>vgetters</td>
<td>Vuex Getter</td>
</tr>
<tr>
<td>vmutation</td>
<td>Vuex Mutation</td>
</tr>
<tr>
<td>vaction</td>
<td>Vuex Action</td>
</tr>
<tr>
<td>vstore-import</td>
<td>Import vuex store into main.js</td>
</tr>
</tbody></table>
<p>Extra (plaintext)</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>gitignore</td>
<td>.gitignore file presets</td>
</tr>
<tr>
<td>vinc</td>
<td>incrementer</td>
</tr>
<tr>
<td>vdec</td>
<td>decrementer</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>效率工具</category>
        <category>VSCode插件</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插件开发（笔记）</title>
    <url>/2020/02/24/Vue-plug-in-development/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="vue插件开发"><a href="#vue插件开发" class="headerlink" title="vue插件开发"></a>vue插件开发</h1><blockquote>
<p>Vue.use({install(Vues){}})</p>
</blockquote>
<h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><p>把给到的内容执行一下<br>举例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Vue.use(a) <span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p>有 install 就执行 install</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">a.install = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Vue.use(a) <span class="comment">// b</span></span><br></pre></td></tr></table></figure>
<p>再进一步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">a.install = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// console.log(&#x27;b&#x27;)</span></span><br><span class="line">	vue.mixin(&#123; <span class="comment">// 抽离公共逻辑 ， 缺点：命名冲突，难以阅读</span></span><br><span class="line">		<span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123; <span class="comment">// data数据少的时候可以不用vuex 用mixin</span></span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				c:<span class="string">&#x27;this is mixin&#x27;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods:&#123;</span><br><span class="line">			<span class="comment">// 混入方法</span></span><br><span class="line">			<span class="comment">// 提示性弹窗 原：import 控制 显隐 现在：在根节点引入，通过mixin在方法控制显隐</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 混入生命周期</span></span><br><span class="line">		<span class="function"><span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">// 所有组件的create生命周期都执行 mixin先执行</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">Vue.use(a) <span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>vue.util.defineReactive()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue.util.defineReactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">	testa: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">	test.testa = <span class="number">2</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line">vue.mixin(&#123;</span><br><span class="line">	<span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.test = test</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vue.extend vue.util.extend</p>
<p>vue.util.extend ===&gt; 简单做了个拷贝,拷贝到一起</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vue.util.extend(a,b)</span><br></pre></td></tr></table></figure>
<p>vue.extend ===&gt; 获取到某个对象的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Constrator = vue.extend(obj)</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Constrator()</span><br></pre></td></tr></table></figure>

<p>手写vue-router</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myVueRouter.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistoryRoute</span>()</span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.current = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vueRouter</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.mode = options.mode || <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">		<span class="built_in">this</span>.history = <span class="keyword">new</span> HistoryRoute</span><br><span class="line">		<span class="built_in">this</span>.routes = options.routes||[]</span><br><span class="line">		<span class="built_in">this</span>.routesMap = <span class="built_in">this</span>.createMap(<span class="built_in">this</span>.routes)</span><br><span class="line">		<span class="built_in">this</span>.init()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">this</span>.mode == <span class="string">&#x27;hash&#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">// 自动加上 #</span></span><br><span class="line">			location.hash?<span class="string">&quot;&quot;</span>:location.hash=<span class="string">&quot;/&quot;</span></span><br><span class="line">			<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>.history.current = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>.history.current = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			location.pathname?<span class="string">&quot;&quot;</span>:location.pathname=<span class="string">&quot;/&quot;</span></span><br><span class="line">			<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>.history.current = location.hash.pathname</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>.history.current = location.hash.pathname</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">createMap</span>(<span class="params">router</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> router.reduce(<span class="function">(<span class="params">memo,current</span>)=&gt;</span>&#123;</span><br><span class="line">			memo[current.path] = current.component</span><br><span class="line">		&#125;)			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vueRouter.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">	Vue.mixin(&#123;</span><br><span class="line">		<span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 组件还未实例化好</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">this</span>.$options &amp;&amp; <span class="built_in">this</span>.$options.router)&#123; <span class="comment">// 有配置而且引入路由</span></span><br><span class="line">				<span class="built_in">this</span>._root = <span class="built_in">this</span></span><br><span class="line">				<span class="built_in">this</span>._router = <span class="built_in">this</span>.$option.router</span><br><span class="line"></span><br><span class="line">				Vue.util.defineReactive(<span class="built_in">this</span>,<span class="string">&#x27;current&#x27;</span>,<span class="built_in">this</span>._router.history)</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">this</span>._root = <span class="built_in">this</span>.$parent._root</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 增强健壮性</span></span><br><span class="line">			<span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,<span class="string">&#x27;$route&#x27;</span>,&#123;</span><br><span class="line">				<span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="built_in">this</span>._root._router</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	Vue.component(<span class="string">&#x27;router-view&#x27;</span>,&#123;</span><br><span class="line">		<span class="function"><span class="title">render</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">			<span class="comment">// 如何根据当前的current，获取到对应的组件</span></span><br><span class="line">			<span class="keyword">let</span> current = <span class="built_in">this</span>._self._root._router.history.current</span><br><span class="line">			<span class="keyword">let</span> routerMap = <span class="built_in">this</span>._self._root._router.routeMap</span><br><span class="line">			<span class="keyword">return</span> h(routeMap[current])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾java开发技能</title>
    <url>/2019/12/30/begin-learn-java/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近愈发觉得越想往上走，越不能局限在前端开发的领域，再往上走前后端都是通的，最近在知乎上看到一句话，说是到了架构师甚至专家的层面以后，就没有什么前端架构师或者前端专家和后端架构师、后端专家了，只有前端出身的技术专家，和后端出身的技术专家，越往上越注重人的综合能力，当一个人能够解决一个项目的技术选型、架构等工作后，对于公司或者团队来说，那就是个巨大的宝藏。</p>
<span id="more"></span>

<h2 id="公司这一年"><a href="#公司这一年" class="headerlink" title="公司这一年"></a>公司这一年</h2><p>最近对于自己的发展有一些迷茫，这一年公司前端的发展可以说是几经转折，我自己呢也一直在摇摆到底是做管理还是做技术，也参加了公司组织的部门经理的答辩，在部门前端的管理工作中也切实的了解到自己在为人处事方面不够圆润。所以目前也算是断了从事管理的念头，更希望能在技术上更进一步，前端目前看来已经不算是我的短板，而我的短板就是只会前端，一直在前端周围打转，其实如果不是看了那篇帖子，以及公司对专家岗位的要求，我可能还会更进一步在前端方向深入研究，但目前看更紧急的应该是补充一下后端的开发知识了，于是上周末开始我就开始了java的学习</p>
<h2 id="为什么选择java"><a href="#为什么选择java" class="headerlink" title="为什么选择java"></a>为什么选择java</h2><p>为什么选择java作为后端入门，实话讲好多前端开发应该都会问这个问题，明明有更熟悉的nodejs可以作为后端技能进行扩展，我这里的理由是目前大多数公司的包括外面公司的开发人员大都还是以java作为主要语言作为后端编写的选择，另外前端js中好多的设计也是借鉴或者照搬了java中的一些思想，可以说在学习java过程中也会自然而然的提高对js的理解，更重要的是，java相对于其他语言来说资料也更多，上手也更容易，因为这些因素吧，最终我选择了java作为后端的主要学习目标。</p>
<h2 id="怎么学习java"><a href="#怎么学习java" class="headerlink" title="怎么学习java"></a>怎么学习java</h2><p>java上大学的时候实际有系统的学过的，只是实习之后就再也没有使用过，如今9年过去了，java对于我可能也只剩下些零星的记忆，说实话刚一开始怎么学，从哪里学让我都有点无从下手，这里还要感谢一下我后端的开发伙伴，给了我很多很好的建议，看书的话大都是基础的太基础，实战的又经常忽略基础，最终我打算还是以视频教程2.5倍速快速过一遍java基础，然后再深入学习一下springboot框架，最后再进行实战，以此掌握java开发技能。</p>
<h3 id="开始学习java"><a href="#开始学习java" class="headerlink" title="开始学习java"></a>开始学习java</h3><p>最终我选择了在B站上看黑马的java基础+实战课程的教学视频，说实话黑马的教学视频还是讲的很仔细的，老师讲的也很有趣，只是一节课10多分钟，只有一个知识点，对于我来说还是有些慢，所以我就开了2.5倍速加快进就这么着看，上周末两天时间，看了130多课，今天的内容记忆不太深刻，趁着不是那么忙又看了30多课，感觉收获还是满满的，接下来的每一天都会看上30课左右，希望自己能在3个月的时间完全上手java开发，相信我可以做到。</p>
<h2 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h2><p>从今天起，每天都要把自己学习的进度做个总结，看看这一天自己收获了多少，希望30岁这年我重新起步，迈向更高更好的未来。</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>杂记随感</category>
      </categories>
  </entry>
  <entry>
    <title>webpack中loader和plugin之间的区别</title>
    <url>/2020/01/22/Wepack-Tips/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习Webpack相关的知识的时候对loader和plugin有点迷惑，两个特性都是用来做打包相关处理，那么他们有什么区别呢，为了弄清楚他们有什么区别，我开始了疯狂的查找资料，虽说每篇文章都说了一些自己的认识，但是并没有一个特别标准或者说容易理解的答案，我且先将它们记录下来，以便日后回顾之时可以有一些感触。那么接下来我将开始webpack的解迷之旅。</p>
<a id="more"></a>

<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><p>在研究loader和plugin之前区别之前，我们先来看看一个webpack配置的常见结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: path.join(__dirname, <span class="string">"../src/js/index.js"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    publicPath: <span class="string">"/"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader配置</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">"style-loader"</span>,</span><br><span class="line">          <span class="string">"css-loader"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 重新创建html文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">"首页"</span>,</span><br><span class="line">      filename: <span class="string">"index.html"</span>,</span><br><span class="line">      template: path.resolve(__dirname, <span class="string">"../src/index.html"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    ......</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>webpack的打包原理</em></strong></p>
<ul>
<li>识别入口文件</li>
<li>通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)</li>
<li>webpack做的就是分析代码，转换代码，编译代码，输出代码</li>
<li>最终形成打包后的代码</li>
</ul>
<h2 id="什么是loader"><a href="#什么是loader" class="headerlink" title="什么是loader"></a>什么是loader</h2><p>我们可以看到loader实际上是在module的rules下，用对象的方式表示了需要处理的文件类型，和需要用哪些loader做处理</p>
<blockquote>
<p>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中。</p>
</blockquote>
<ul>
<li>处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行</li>
<li>第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码</li>
</ul>
<h2 id="什么是plugin"><a href="#什么是plugin" class="headerlink" title="什么是plugin"></a>什么是plugin</h2><blockquote>
<p>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。</p>
</blockquote>
<h2 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h2><p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的<strong>文件转换过程</strong></p>
<p><strong>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</strong></p>
<p>下面我们来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"MyPlugin constructor:"</span>, options);</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler)&#123;</span><br><span class="line">    compiler.plugin(<span class="string">"compilation"</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"MyPlugin"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// webpack.config.js配置：</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyPlugin(&#123;<span class="attr">param</span>: <span class="string">"my plugin"</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该plugin后，执行的顺序：</p>
<ol>
<li>webpack启动后，在读取配置的过程中会执行new MyPlugin(options)初始化一个MyPlugin获取其实例</li>
<li>在初始化compiler对象后，就会通过compiler.plugin(事件名称，回调函数)监听到webpack广播出来的事件</li>
<li>并且可以通过compiler对象去操作webpack</li>
</ol>
]]></content>
      <categories>
        <category>前端工程化</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确使用时间[转载]</title>
    <url>/2020/01/09/career/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近各种技术博客，各种技术文章，各种牛人前辈的学习心得都在看，最近看了一个不错的文章叫做《如何正确使用时间》<br>感觉还是很不错的，特别适合年轻的程序员看一下。下面将全文贴在下方，如果需要也可以去原文查看。</p>
<p><a href="http://caibaojian.com/interview-map/career/">原文</a></p>
<p>你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。</p>
<h2 id="花时间补基础，读文档"><a href="#花时间补基础，读文档" class="headerlink" title="花时间补基础，读文档"></a>花时间补基础，读文档</h2><p>在工作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实或者文档没有仔细看。</p>
<p>基础是你技术的基石，一定要花时间打好基础，而不是追各种新的技术。一旦你的基础扎实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。</p>
<p>文档同样也是一门技术的基础。一个优秀的库，开发人员肯定已经把如何使用这个库都写在文档中了，仔细阅读文档一定会是少写 bug 的最省事路子。</p>
<h2 id="学会搜索"><a href="#学会搜索" class="headerlink" title="学会搜索"></a>学会搜索</h2><p>如果你还在使用百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样一个关键字，使用百度和谷歌，谷歌基本完胜的。即使你使用中文在谷歌中搜索，得到的结果也往往是谷歌占优，所以如果你想迅速的通过搜索引擎来解决问题，那一定是谷歌。</p>
<h2 id="学点英语"><a href="#学点英语" class="headerlink" title="学点英语"></a>学点英语</h2><p>说到英语，一定是大家所最不想听的。其实我一直认为程序员学习英语是简单的，因为我们工作中是一直接触着英语，并且看懂技术文章，文档所需要的单词量是极少的。我时常在群里看到大家发出一个问题的截图问什么原因，其实在截图中英语已经很明白的说明了问题的所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节省时间中很重要的一点。</p>
<p>那么如何去学习呢，chrome 装个翻译插件，直接拿英文文档或文章读，不会的就直接划词翻译，然后记录下这个单词并背诵。每天花半小时看点英文文档和文章，坚持两个月，你的英语水平不说别的，看文档和文章绝对不会有难题了。这一定是一个很划算的个人时间投资，花点时间学习英语，能为你将来的技术之路铺平很多坎。</p>
<h2 id="画个图，想一想再做"><a href="#画个图，想一想再做" class="headerlink" title="画个图，想一想再做"></a>画个图，想一想再做</h2><p>你是否遇到过这种问题，需求一下来，看一眼，然后马上就按照设计稿开始做了，可能中间出个问题导致你需要返工。</p>
<p>如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想一想，画一画。考虑一下设计稿中是否可以找到可以拆分出来的复用组件，是否存在之前写过的组件。该如何组织这个界面，数据的流转是怎么样的。然后画一下这个页面的需求，最后再动手做。</p>
<h2 id="利用好下班时间学习"><a href="#利用好下班时间学习" class="headerlink" title="利用好下班时间学习"></a>利用好下班时间学习</h2><p>说到下班时间，那可能就有人说了公司很迟下班，这其实是国内很普遍的情况。但是我认为正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。</p>
<p>可以这么说，大部分的 996 公司，加班的这些时间并不会增加你的技术，无非就是在写一些重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃饭的，如果你长久呆在一个长时间加班的公司，不能增长你的技术还要吞噬你的下班学习时间，那么你一定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到非 996 的公司。</p>
<p>那么如果你有足够的下班时间，一定要花上 1， 2 小时去学习，上班大家基本都一样，技术的精进就是看下班以后的那几个小时了。如果你能利用好下班时间来学习，坚持下去，时间一定会给你很好的答复。</p>
<h2 id="列好-ToDo"><a href="#列好-ToDo" class="headerlink" title="列好 ToDo"></a>列好 ToDo</h2><p>我喜欢规划好一段时间内要做的事情，并且要把事情拆分为小点。给 ToDo 列好优先级，紧急的优先级最高。相同优先级的我喜欢先做简单的，因为这样一旦完成就能划掉一个，提高成就感。</p>
<h2 id="反思和整理"><a href="#反思和整理" class="headerlink" title="反思和整理"></a>反思和整理</h2><p>每周末都会花上点时间整理下本周记录的笔记和看到的不错文章。然后考虑下本周完成的工作和下周准备要完成的工作。</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>人生思考</category>
      </categories>
      <tags>
        <tag>经验之谈</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器兼容性问题解决方案</title>
    <url>/2017/08/29/browser-incompatibility-problem-solution/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为前端，浏览器就是你的战场，而不同的浏览器就是不同的敌人，敌人有相同之处，也各有特点，这不同的特点就是不同浏览器的兼容性，下面就聊聊浏览器的兼容问题，如何解决不同浏览器的兼容性。</p>
<span id="more"></span>
<p><strong>普及</strong>：浏览器的兼容性问题，往往是个别浏览器（没错，就是那个与众不同的浏览器）对于一些标准的定义不一致导致的。俗话说：没有IE就没有伤害。</p>
<p><strong>贴士</strong>：内容都是自己总结的，不免会出现错误或者bug，欢迎更正和补充，本帖也会不断更新。</p>
<h4 id="Normalize-css"><a href="#Normalize-css" class="headerlink" title="Normalize.css"></a>Normalize.css</h4><p>不同浏览器的默认样式存在差异，可以使用 <code>Normalize.css</code>抹平这些差异。当然，你也可以定制属于自己业务的 <code>reset.css</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;normalize&#x2F;7.0.0&#x2F;normalize.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>简单粗暴法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="html5shiv-js"><a href="#html5shiv-js" class="headerlink" title="html5shiv.js"></a>html5shiv.js</h4><p>解决 ie9 以下浏览器对 html5 新增标签不识别的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;html5shiv&#x2F;3.7.3&#x2F;html5shiv.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<!-- more -->
<h4 id="respond-js"><a href="#respond-js" class="headerlink" title="respond.js"></a>respond.js</h4><p>解决 ie9 以下浏览器不支持 CSS3 Media Query 的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;picturefill&#x2F;3.0.3&#x2F;picturefill.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="IE-条件注释"><a href="#IE-条件注释" class="headerlink" title="IE 条件注释"></a>IE 条件注释</h4><p>IE 的条件注释仅仅针对IE浏览器，对其他浏览器无效<br><img src="https://user-gold-cdn.xitu.io/2017/8/28/31714eaf3a9bc272c50dbf1e1279f14b?imageView2/0/w/1280/h/960" alt="image"></p>
<h4 id="IE-属性过滤器（较为常用的hack方法）"><a href="#IE-属性过滤器（较为常用的hack方法）" class="headerlink" title="IE 属性过滤器（较为常用的hack方法）"></a>IE 属性过滤器（较为常用的hack方法）</h4><p>针对不同的 IE 浏览器，可以使用不同的字符来对特定的版本的 IE 浏览器进行样式控制<br><img src="https://user-gold-cdn.xitu.io/2017/8/28/e8c1a14cca725798b5aaa88bf5d23de8?imageView2/0/w/1280/h/960" alt="image"><br><img src="https://user-gold-cdn.xitu.io/2017/8/28/ad406608b75744baa6f89ae3c26ba69d?imageView2/0/w/1280/h/960" alt="image"></p>
<h4 id="浏览器-CSS-兼容前缀"><a href="#浏览器-CSS-兼容前缀" class="headerlink" title="浏览器 CSS 兼容前缀"></a>浏览器 CSS 兼容前缀</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-o-transform:rotate(7deg); &#x2F;&#x2F; Opera</span><br><span class="line"></span><br><span class="line">-ms-transform:rotate(7deg); &#x2F;&#x2F; IE</span><br><span class="line"></span><br><span class="line">-moz-transform:rotate(7deg); &#x2F;&#x2F; Firefox</span><br><span class="line"></span><br><span class="line">-webkit-transform:rotate(7deg); &#x2F;&#x2F; Chrome</span><br><span class="line"></span><br><span class="line">transform:rotate(7deg); &#x2F;&#x2F; 统一标识语句</span><br></pre></td></tr></table></figure>
<p><em><strong>补充：</strong></em> 目前可以采用自动化插件完成，插件名称叫做 <code>Autoprefixer</code>，他可以解析css文件并且添加前缀到css内容里。</p>
<p>把 <code>Auroprefixer</code> 添加到资源构建工具如：<code>webpack</code>后，就可以不用再手动补全浏览器前缀了，这里只需要你按照W3C的标准来书写css代码，剩下的工作就交给插件完成，目前<code>webpack</code>、<code>gulp</code>、<code>grunt</code>都有相应的插件，是不是开心啊。</p>
<h4 id="a-标签的几种-CSS-状态的顺序"><a href="#a-标签的几种-CSS-状态的顺序" class="headerlink" title="a 标签的几种 CSS 状态的顺序"></a>a 标签的几种 CSS 状态的顺序</h4><p>很多新人在写 a 标签的样式，会疑惑为什么写的样式没有效果，或者点击超链接后，hover、active 样式没有效果，其实只是写的样式被覆盖了。</p>
<p>正确的a标签顺序应该是：<code>==love hate==</code></p>
<ol>
<li>link:平常的状态</li>
<li>visited:被访问过之后</li>
<li>hover:鼠标放到链接上的时候</li>
<li>active:链接被按下的时候</li>
</ol>
<h4 id="完美解决-Placeholder"><a href="#完美解决-Placeholder" class="headerlink" title="完美解决 Placeholder"></a>完美解决 <code>Placeholder</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;Name *&quot; onFocus&#x3D;&quot;this.value &#x3D; &#39;&#39;;&quot; onBlur&#x3D;&quot;if (this.value &#x3D;&#x3D; &#39;&#39;) &#123;this.value &#x3D; &#39;Name *&#39;;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="清除浮动-最佳实践"><a href="#清除浮动-最佳实践" class="headerlink" title="清除浮动 最佳实践"></a>清除浮动 最佳实践</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fl &#123; float: left; &#125;</span><br><span class="line">.fr &#123; float: right; &#125;</span><br><span class="line">.clearfix:after &#123; display: block; clear: both; content: &quot;&quot;; visibility: hidden; height: 0; &#125;</span><br><span class="line">.clearfix &#123; zoom: 1; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="BFC-解决边距重叠问题"><a href="#BFC-解决边距重叠问题" class="headerlink" title="BFC 解决边距重叠问题"></a>BFC 解决边距重叠问题</h4><p>当相邻元素都设置了 margin 边距时，margin 将取最大值，舍弃小值。为了不让边距重叠，可以给子元素加一个父元素，并设置该父元素为 BFC：<code>overflow: hidden</code>;</p>
<div class="box" id="box">
  <p>Lorem ipsum dolor sit.</p>

  <div style="overflow: hidden;">
    <p>Lorem ipsum dolor sit.</p>
  </div>

  <p>Lorem ipsum dolor sit.</p>
</div>

<h4 id="IE6-双倍边距的问题"><a href="#IE6-双倍边距的问题" class="headerlink" title="IE6 双倍边距的问题"></a>IE6 双倍边距的问题</h4><p>设置 ie6 中设置浮动，同时又设置 <code>margin</code>，会出现双倍边距的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: inline;</span><br></pre></td></tr></table></figure>
<h4 id="解决-IE9-以下浏览器不能使用-opacity"><a href="#解决-IE9-以下浏览器不能使用-opacity" class="headerlink" title="解决 IE9 以下浏览器不能使用 opacity"></a>解决 IE9 以下浏览器不能使用 opacity</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">filter: alpha(opacity &#x3D; 50);</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style &#x3D; 0, opacity &#x3D; 50);</span><br></pre></td></tr></table></figure>
<h4 id="解决-IE6-不支持-fixed-绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题"><a href="#解决-IE6-不支持-fixed-绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题" class="headerlink" title="解决 IE6 不支持 fixed 绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题"></a>解决 IE6 不支持 fixed 绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* IE6 hack *&#x2F;</span><br><span class="line">*html, *html body &#123;</span><br><span class="line">  background-image: url(about:blank);</span><br><span class="line">  background-attachment: fixed;</span><br><span class="line">&#125;</span><br><span class="line">*html #menu &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: expression(((e&#x3D;document.documentElement.scrollTop) ? e : document.body.scrollTop) + 100 + &#39;px&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IE6-背景闪烁的问题"><a href="#IE6-背景闪烁的问题" class="headerlink" title="IE6 背景闪烁的问题"></a>IE6 背景闪烁的问题</h4><p>问题：链接、按钮用 CSSsprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是 IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载</p>
<p>解决：可以用 JavaScript 设置 ie6 缓存这些图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.execCommand(&quot;BackgroundImageCache&quot;, false, true);</span><br></pre></td></tr></table></figure>
<h4 id="解决在-IE6-下，列表与日期错位的问题"><a href="#解决在-IE6-下，列表与日期错位的问题" class="headerlink" title="解决在 IE6 下，列表与日期错位的问题"></a>解决在 IE6 下，列表与日期错位的问题</h4><p>日期<span> 标签放在标题 <a> 标签之前即可<br><img src="https://user-gold-cdn.xitu.io/2017/8/28/6797c276197029d941ee577d877d6be3?imageView2/0/w/1280/h/960" alt="image"></p>
<h4 id="解决-IE6-不支持-min-height-属性的问题"><a href="#解决-IE6-不支持-min-height-属性的问题" class="headerlink" title="解决 IE6 不支持 min-height 属性的问题"></a>解决 IE6 不支持 min-height 属性的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min-height: 350px;</span><br><span class="line">_height: 350px;</span><br></pre></td></tr></table></figure>

<h4 id="让-IE7-IE8-支持-CSS3-background-size属性"><a href="#让-IE7-IE8-支持-CSS3-background-size属性" class="headerlink" title="让 IE7 IE8 支持 CSS3 background-size属性"></a>让 IE7 IE8 支持 CSS3 background-size属性</h4><p>由于 background-size 是 CSS3 新增的属性，所以 IE 低版本自然就不支持了，但是老外写了一个 htc 文件，名叫 background-size polyfill，使用该文件能够让 IE7、IE8 支持 background-size 属性。其原理是创建一个 img 元素插入到容器中，并重新计算宽度、高度、left、top 等值，模拟 background-size 的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  background-image: url(&#39;img&#x2F;37.png&#39;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  -ms-behavior: url(&#39;css&#x2F;backgroundsize.min.htc&#39;);</span><br><span class="line">  behavior: url(&#39;css&#x2F;backgroundsize.min.htc&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IE6-7-line-height-失效的问题"><a href="#IE6-7-line-height-失效的问题" class="headerlink" title="IE6-7 line-height 失效的问题"></a>IE6-7 line-height 失效的问题</h4><p>问题：在ie 中 img 与文字放一起时，line-height 不起作用</p>
<p>解决：都设置成 float</p>
<h4 id="td-自动换行的问题"><a href="#td-自动换行的问题" class="headerlink" title="td 自动换行的问题"></a>td 自动换行的问题</h4><p>问题：table 宽度固定，td 自动换行</p>
<p>解决：设置 <code>Tabl</code>e 为 <code>table-layout: fixed</code>，<code>td</code> 为 <code>word-wrap: break-word</code></p>
<h4 id="让层显示在-FLASH-之上"><a href="#让层显示在-FLASH-之上" class="headerlink" title="让层显示在 FLASH 之上"></a>让层显示在 FLASH 之上</h4><p>想让层的内容显示在 flash 上，把 FLASH 设置透明即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&lt;param name&#x3D;&quot; wmode &quot; value&#x3D;&quot;transparent&quot; &#x2F;&gt;</span><br><span class="line">2、&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="键盘事件-keyCode-兼容性写法"><a href="#键盘事件-keyCode-兼容性写法" class="headerlink" title="键盘事件 keyCode 兼容性写法"></a>键盘事件 keyCode 兼容性写法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var inp &#x3D; document.getElementById(&#39;inp&#39;)</span><br><span class="line">var result &#x3D; document.getElementById(&#39;result&#39;)</span><br><span class="line"></span><br><span class="line">function getKeyCode(e) &#123;</span><br><span class="line">  e &#x3D; e ? e : (window.event ? window.event : &quot;&quot;)</span><br><span class="line">  return e.keyCode ? e.keyCode : e.which</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inp.onkeypress &#x3D; function(e) &#123;</span><br><span class="line">  result.innerHTML &#x3D; getKeyCode(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求窗口大小的兼容写法"><a href="#求窗口大小的兼容写法" class="headerlink" title="求窗口大小的兼容写法"></a>求窗口大小的兼容写法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）</span><br><span class="line">&#x2F;&#x2F; 1600 * 525</span><br><span class="line">var client_w &#x3D; document.documentElement.clientWidth || document.body.clientWidth;</span><br><span class="line">var client_h &#x3D; document.documentElement.clientHeight || document.body.clientHeight;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 网页内容实际宽高（包括工具栏和滚动条等边线）</span><br><span class="line">&#x2F;&#x2F; 1600 * 8</span><br><span class="line">var scroll_w &#x3D; document.documentElement.scrollWidth || document.body.scrollWidth;</span><br><span class="line">var scroll_h &#x3D; document.documentElement.scrollHeight || document.body.scrollHeight;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 网页内容实际宽高 (不包括工具栏和滚动条等边线）</span><br><span class="line">&#x2F;&#x2F; 1600 * 8</span><br><span class="line">var offset_w &#x3D; document.documentElement.offsetWidth || document.body.offsetWidth;</span><br><span class="line">var offset_h &#x3D; document.documentElement.offsetHeight || document.body.offsetHeight;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 滚动的高度</span><br><span class="line">var scroll_Top &#x3D; document.documentElement.scrollTop||document.body.scrollTop;</span><br></pre></td></tr></table></figure>
<h4 id="DOM-事件处理程序的兼容写法（能力检测）"><a href="#DOM-事件处理程序的兼容写法（能力检测）" class="headerlink" title="DOM 事件处理程序的兼容写法（能力检测）"></a>DOM 事件处理程序的兼容写法（能力检测）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var eventshiv &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; event兼容</span><br><span class="line">    getEvent: function(event) &#123;</span><br><span class="line">        return event ? event : window.event;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; type兼容</span><br><span class="line">    getType: function(event) &#123;</span><br><span class="line">        return event.type;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; target兼容</span><br><span class="line">    getTarget: function(event) &#123;</span><br><span class="line">        return event.target ? event.target : event.srcelem;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加事件句柄</span><br><span class="line">    addHandler: function(elem, type, listener) &#123;</span><br><span class="line">        if (elem.addEventListener) &#123;</span><br><span class="line">            elem.addEventListener(type, listener, false);</span><br><span class="line">        &#125; else if (elem.attachEvent) &#123;</span><br><span class="line">            elem.attachEvent(&#39;on&#39; + type, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 在这里由于.与&#39;on&#39;字符串不能链接，只能用 []</span><br><span class="line">            elem[&#39;on&#39; + type] &#x3D; listener;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 移除事件句柄</span><br><span class="line">    removeHandler: function(elem, type, listener) &#123;</span><br><span class="line">        if (elem.removeEventListener) &#123;</span><br><span class="line">            elem.removeEventListener(type, listener, false);</span><br><span class="line">        &#125; else if (elem.detachEvent) &#123;</span><br><span class="line">            elem.detachEvent(&#39;on&#39; + type, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            elem[&#39;on&#39; + type] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加事件代理</span><br><span class="line">    addAgent: function (elem, type, agent, listener) &#123;</span><br><span class="line">        elem.addEventListener(type, function (e) &#123;</span><br><span class="line">            if (e.target.matches(agent)) &#123;</span><br><span class="line">                listener.call(e.target, e); &#x2F;&#x2F; this 指向 e.target</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 取消默认行为</span><br><span class="line">    preventDefault: function(event) &#123;</span><br><span class="line">        if (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.returnValue &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻止事件冒泡</span><br><span class="line">    stopPropagation: function(event) &#123;</span><br><span class="line">        if (event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.cancelBubble &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>兼容性</category>
      </categories>
      <tags>
        <tag>兼容性问题</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用node开发自定义cli工具</title>
    <url>/2020/02/19/develop-custom-cli-tools-using-node/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章想写一写前端工程化相关的内容，原因一呢是是结合公司业务给自己定的业绩指标包含这些内容，另外一个原因是因为听了网易前端唐磊说过的一句话，前端leader干什么，很重要的工作就是前端工程化，高级以上不懂前端工程化很难。</p>
<p>今天听了公开课讲到了用node写一个自己的cli，说实话正是工作所需，课程讲的有点快，没有从头跟下来，自己上完了课又上网上找了些资料，终于把步骤弄明白了，下面就把如何自定义一个cli来帮助提升开发效率。同时也完成了一个业务指标，心里美滋滋。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>如果你看到这篇文章，也想跟着我的步骤写一下这个自定义cli，那么如下的知识还是有一些为好。</p>
<ul>
<li>基础的nodejs相关知识</li>
</ul>
<p>没错就只需要会一些node的基础知识就可以了，接下来正式开始</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>首先，我们要给我们的命令行工具起个名字，比如我们熟悉的 vue 命令行就是 vue-cli ，因为我写完了要给公司用，所以我起的名字是 tfd-cli ，你们喜欢叫什么你们随意</p>
<p>首先创建一个名字为 <code>tfd-cli</code> 的文件目录，然后在目录下执行 <code>node</code> 工程的初始化命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init -y <span class="comment">// 初始化项目 -y 默认全部yes的参数</span></span><br></pre></td></tr></table></figure>
<p>命令执行完成后 <code>tfd-cli</code> 目录下会生成一个我们熟悉的 <code>package.json</code> 文件，我们打开 <code>package.json</code> 文件，增加一段代码，如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 追加的代码</span></span><br><span class="line">"bin": &#123;</span><br><span class="line">	"tfd": "index.js"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追加完成后，<code>package.json</code> 文件中的内容是这样的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"tfd-cli"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"tfd"</span>: <span class="string">"index.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说当我们执行 <code>tfd</code> 命令时它就会找同级目录下的 <code>index.js</code> 文件执行其中代码，我们目前还没有 <code>index.js</code>，文件，那么我们手动创建一个 <code>index.js</code> 的文件，然后在里面写下如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure>
<p>执行完这些还不够，因为我们是开发环境所以还有一步操作是要将 <code>tfd</code> 命令告知 <code>npm</code>，该如何处理，所以我们要执行如下命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm link</span><br></pre></td></tr></table></figure>
<p>这里如果执行不成功，请用管理员权限执行，执行完成后我们会得到一个 <code>package-lock.json</code> 的文件，内容如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"tfd-cli"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"lockfileVersion"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此一来，我们就可以在任何目录下执行命令行 <code>tfd</code> 就会执行 <code>index.js</code> 文件了，这里我们会在控制面板中输出 <code>hello world</code> ，怎么样是不是小有成就感，我们接着往下来。</p>
<h1 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h1><p>我们写个命令行工具肯定不是为了输出个 <code>hello world</code> 这么简单，而是希望通过用户输入内容后根据条件输出一些东西，那么让我们想想一个命令行工具应该具备哪些指令呢？</p>
<ul>
<li>查看命令行工具版本</li>
<li>查看帮助文档</li>
<li>初始化模板</li>
<li>列出模板类型</li>
<li>等等</li>
</ul>
<p>那么用指令该如何描述呢</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">tfd -V|--version //查看工具版本号</span><br><span class="line">tfd -h|--help //查看使用帮助</span><br><span class="line">tfd init &lt;template-name&gt; &lt;project-name&gt; //基于指定模板进行项目初始化</span><br><span class="line">tfd list //列出所有可用模板</span><br></pre></td></tr></table></figure>
<p>为了执行命令，这里我们要引入一个 <code>node</code> 包叫做 <code>commander</code>，因此我们要先执行一下 <code>install</code> 命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install commander</span><br></pre></td></tr></table></figure>
<p>接着我们就可以在 <code>index.js</code> 里面写指令了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"><span class="keyword">const</span> cmd = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd -V|--version</span></span><br><span class="line">cmd.version(<span class="string">'0.1.0'</span>);  <span class="comment">// -V|--version时输出版本号0.1.0</span></span><br></pre></td></tr></table></figure>
<p>到这一步我们在控制台敲一下 <code>tfd -V</code> 你会发现什么也没输出，这是因为到这一步我们还无法解析 <code>tfd -V</code> 操作，在这之前我们要知道一个命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.argv <span class="comment">// 使用process.argv获取命令行参数</span></span><br></pre></td></tr></table></figure>
<p>当我们把这句话加到 <code>console.log</code> 中在 <code>index.js</code> 中输出时你会看到控制台打印出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"><span class="keyword">const</span> cmd = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd -V|--version</span></span><br><span class="line">cmd.version(<span class="string">'0.1.0'</span>);  <span class="comment">// -V|--version时输出版本号0.1.0</span></span><br><span class="line"><span class="built_in">console</span>.log(process.argv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台</span></span><br><span class="line">[ <span class="string">'/usr/local/bin/node'</span>, <span class="string">'/usr/local/bin/tfd'</span>, <span class="string">'-V'</span> ]</span><br></pre></td></tr></table></figure>
<p>接下来我们要让<code>commander</code>获取参数执行命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"><span class="keyword">const</span> cmd = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd -V|--version</span></span><br><span class="line">cmd.version(<span class="string">'0.1.0'</span>);  <span class="comment">// -V|--version时输出版本号0.1.0</span></span><br><span class="line"><span class="comment">// console.log(process.argv)</span></span><br><span class="line">cmd.parse(process.argv);</span><br></pre></td></tr></table></figure>
<p>这个时候我们再在控制台输入 <code>tfd -V</code> 时，我们就会发现，控制台输出了 <code>0.1.0</code>，这样我们就完成了查版本的指令，接下来我们完成其他的指令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"><span class="keyword">const</span> cmd = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd -V|--version</span></span><br><span class="line">cmd.version(<span class="string">'0.1.0'</span>);  <span class="comment">// -V|--version时输出版本号0.1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd init &lt;template&gt; &lt;project&gt;</span></span><br><span class="line">cmd</span><br><span class="line">  .command(<span class="string">'init &lt;template&gt; &lt;project&gt;'</span>) <span class="comment">// 参数</span></span><br><span class="line">  .description(<span class="string">'初始化项目模板'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">templateName, projectName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(templateName, projectName);</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// tfd list</span></span><br><span class="line">cmd</span><br><span class="line">  .command(<span class="string">'list'</span>)</span><br><span class="line">  .description(<span class="string">'查看所有可用模板'</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">          a   a模板</span></span><br><span class="line"><span class="string">          b   b模板</span></span><br><span class="line"><span class="string">          c   c模板</span></span><br><span class="line"><span class="string">      `</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// console.log(process.argv)</span></span><br><span class="line">cmd.parse(process.argv);</span><br></pre></td></tr></table></figure>
<p>这个时候我们在控制台上输入 <code>tfd -h</code> 的时候，控制台会输出如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Usage: tfd [options] [command]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version              output the version number</span><br><span class="line">  -h, --help                 output usage information</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  init &lt;template&gt; <span class="xml"><span class="tag">&lt;<span class="name">project</span>&gt;</span>  初始化项目模板</span></span><br><span class="line"><span class="xml">  list                       查看所有可用模板</span></span><br></pre></td></tr></table></figure>
<p>这样我们就实现了自定义命令，我们执行一下 <code>tfd init template1 project1</code>，我们可以看到，控制台中输出了 <code>template1 project1</code>，也就是说<code>command</code>命令后尖括号中指向了<code>action</code>中的参数，我们就可以通过判断<code>action</code>中的参数做具体的操作了。</p>
<p>通常模板可以选择从本地拷贝一份，但更常用的是从线上拷贝一份，比如从<code>github</code>中，接下来我们就看看如何从<code>github</code>中拷贝一个模板作为项目的初始化工程</p>
<h2 id="github上创建模板仓库"><a href="#github上创建模板仓库" class="headerlink" title="github上创建模板仓库"></a>github上创建模板仓库</h2><p>首先我们要在github上创建两个仓库 <code>tpl-1</code> <code>tpl-2</code>，这里为了从<code>github</code>中下载仓库我们需要一个<code>node</code>包支持，让我们请出<code>download-git-repo</code>，别忘了执行安装命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install download-git-repo</span><br></pre></td></tr></table></figure>
<p>安装完依赖之后让我们再去<code>index.js</code>填点东西，首先引入下载依赖，然后是创建下载的 <code>template</code> 抽象对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"><span class="keyword">const</span> cmd = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> download = <span class="built_in">require</span>(<span class="string">'download-git-repo'</span>);</span><br><span class="line"><span class="comment">// 可用模板</span></span><br><span class="line"><span class="keyword">const</span> templates = &#123;</span><br><span class="line">    <span class="string">'tpl-1'</span>: &#123;</span><br><span class="line">        url: <span class="string">'https://github.com/lixuguang/tpl-1'</span>,</span><br><span class="line">        downloadUrl: <span class="string">'https://github.com:lixuguang/tpl-1#master'</span>,</span><br><span class="line">        description: <span class="string">'tfd-cli脚手架测试模板1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'tpl-2'</span>: &#123;</span><br><span class="line">        url: <span class="string">'https://github.com/lixuguang/tpl-2'</span>,</span><br><span class="line">        downloadUrl: <span class="string">'https://github.com:lixuguang/tpl-2#master'</span>,</span><br><span class="line">        description: <span class="string">'tfd-cli脚手架测试模板2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd -V|--version</span></span><br><span class="line">cmd.version(<span class="string">'0.1.0'</span>);  <span class="comment">// -V|--version时输出版本号0.1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd init &lt;template&gt; &lt;project&gt;</span></span><br><span class="line">cmd</span><br><span class="line">  .command(<span class="string">'init &lt;template&gt; &lt;project&gt;'</span>) <span class="comment">// 参数</span></span><br><span class="line">  .description(<span class="string">'初始化项目模板'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">templateName, projectName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(templateName, projectName);</span></span><br><span class="line">      <span class="keyword">let</span> &#123;downloadUrl&#125; = templates[templateName];        </span><br><span class="line">        <span class="comment">// 第一个参数是github仓库地址，第二个参数是创建的项目目录名，第三个参数是clone</span></span><br><span class="line">        download(downloadUrl, projectName, &#123;<span class="attr">clone</span>: <span class="literal">true</span>&#125;, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'模板下载失败'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'模板下载成功'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// tfd list</span></span><br><span class="line">cmd</span><br><span class="line">  .command(<span class="string">'list'</span>)</span><br><span class="line">  .description(<span class="string">'查看所有可用模板'</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(`</span></span><br><span class="line">    <span class="comment">//       a   a模板</span></span><br><span class="line">    <span class="comment">//       b   b模板</span></span><br><span class="line">    <span class="comment">//       c   c模板</span></span><br><span class="line">    <span class="comment">//   `)</span></span><br><span class="line">    <span class="comment">// 通过获取templates里的key可以获取到模板名称</span></span><br><span class="line">    <span class="keyword">const</span> templateName = <span class="built_in">Object</span>.keys(templates)</span><br><span class="line">    <span class="built_in">console</span>.log(templateName)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// console.log(process.argv)</span></span><br><span class="line">cmd.parse(process.argv);</span><br></pre></td></tr></table></figure>
<p>这样当我们执行 <code>tfd list</code> 就可以看到有哪些模板了，然后执行<code>tfd init tpl-1 newproject</code> 就可以依据 <code>tpl-1</code> 模板创建出 <code>newproject</code> 工程，这个过程实际上就是从<code>github</code>仓库克隆一份<code>tpl-1</code>作为模板创建工程<code>newproject</code></p>
<p><strong><em>这里需要注意的是download地址跟github仓库地址有点出入，比如github仓库地址是<a href="https://github.com/xxx/xxx而下载地址是https://github.com:xxx/xxx" target="_blank" rel="noopener">https://github.com/xxx/xxx而下载地址是https://github.com:xxx/xxx</a></em></strong></p>
<p>虽然这样执行完成后就完成了基本的cli的雏形，但是毕竟不灵活，我们在使用<code>vue-cli</code>时，它的创建过程是问答式和选择式的，另外每个过程都会有进度显示什么的，那么要怎么添加这些功能呢，我们接着往下做。</p>
<h2 id="进阶增加功能"><a href="#进阶增加功能" class="headerlink" title="进阶增加功能"></a>进阶增加功能</h2><h3 id="使用inquirer进行命令行答询"><a href="#使用inquirer进行命令行答询" class="headerlink" title="使用inquirer进行命令行答询"></a>使用<code>inquirer</code>进行命令行答询</h3><p><code>inquirer</code> 是一个进行命令行答询的库，通过它我们就可以创建问答式的内容，首先还是安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install inquirer</span><br></pre></td></tr></table></figure>
<h3 id="使用handlebars修改package-json"><a href="#使用handlebars修改package-json" class="headerlink" title="使用handlebars修改package.json"></a>使用handlebars修改package.json</h3><p>我们都知道在使用<code>vue-cli</code>的初始化命令后，会在项目目录下生成一个<code>package.json</code>文件，它就像是这个项目的基因序列一样，影响着项目的整个结构。模板是固定的，那要修改其中的<code>package.json</code>符合自己项目的需要，就要用到<code>handlebars</code>这个库来改写<code>package.json</code>文件，老规矩先安装它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install handlebars</span><br></pre></td></tr></table></figure>
<h3 id="使用ora在命令行中显示加载状态"><a href="#使用ora在命令行中显示加载状态" class="headerlink" title="使用ora在命令行中显示加载状态"></a>使用ora在命令行中显示加载状态</h3><p>我们在装任何依赖时都会有进度条显示进度，如果没有进度条又没有任何响应，会让用户迷茫，为了友好，我们就要加进度条，这里我们需要引入<code>ora</code>这个库来完成进度显示，我们接着安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install ora</span><br></pre></td></tr></table></figure>
<h3 id="使用chalk和log-symbols增加命令行输出样式"><a href="#使用chalk和log-symbols增加命令行输出样式" class="headerlink" title="使用chalk和log-symbols增加命令行输出样式"></a>使用chalk和log-symbols增加命令行输出样式</h3><p>为了让命令行有红红绿绿的效果以及符号效果，我们需要使用<code>chalk</code>和<code>log-symbols</code>来丰富样式，少废话，接着装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install chalk log-symbols</span><br></pre></td></tr></table></figure>

<h3 id="集大成"><a href="#集大成" class="headerlink" title="集大成"></a>集大成</h3><p>终于安装完一堆的依赖，别忘了在<code>index.js</code>中引入，让我们看看具体如何使用这些库吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">//使用node开发命令行工具所执行JavaScript脚本必须在顶部加入 #!/usr/bin/env node 声明该命令行脚本是node.js写的</span></span><br><span class="line"><span class="keyword">const</span> cmd = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> download = <span class="built_in">require</span>(<span class="string">'download-git-repo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iq = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);       <span class="comment">// 命令行答询</span></span><br><span class="line"><span class="keyword">const</span> hb = <span class="built_in">require</span>(<span class="string">'handlebars'</span>);       <span class="comment">// 修改package.json文件</span></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>);         <span class="comment">// 命令行中加载状态标识</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);     <span class="comment">// 命令行输出字符颜色</span></span><br><span class="line"><span class="keyword">const</span> ls = <span class="built_in">require</span>(<span class="string">'log-symbols'</span>);      <span class="comment">// 命令行输出符号</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); <span class="comment">// node fs原生模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用模板</span></span><br><span class="line"><span class="keyword">const</span> templates = &#123;</span><br><span class="line">    <span class="string">'tpl-1'</span>: &#123;</span><br><span class="line">        url: <span class="string">'https://github.com/lixuguang/tpl-1'</span>,</span><br><span class="line">        downloadUrl: <span class="string">'https://github.com:lixuguang/tpl-1#master'</span>,</span><br><span class="line">        description: <span class="string">'tfd-cli脚手架测试模板1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'tpl-2'</span>: &#123;</span><br><span class="line">        url: <span class="string">'https://github.com/lixuguang/tpl-2'</span>,</span><br><span class="line">        downloadUrl: <span class="string">'https://github.com:lixuguang/tpl-2#master'</span>,</span><br><span class="line">        description: <span class="string">'tfd-cli脚手架测试模板2'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd -V|--version</span></span><br><span class="line">cmd.version(<span class="string">'0.1.0'</span>);  <span class="comment">// -V|--version时输出版本号0.1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tfd init &lt;template&gt; &lt;project&gt;</span></span><br><span class="line">cmd</span><br><span class="line">  .command(<span class="string">'init &lt;template&gt; &lt;project&gt;'</span>) <span class="comment">// 参数</span></span><br><span class="line">  .description(<span class="string">'初始化项目模板'</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">templateName, projectName</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(templateName, projectName);</span></span><br><span class="line">      <span class="keyword">let</span> &#123;downloadUrl&#125; = templates[templateName];   </span><br><span class="line">      <span class="comment">//下载github项目，下载墙loading提示</span></span><br><span class="line">      <span class="keyword">const</span> loading = ora(<span class="string">'模板下载中...'</span>).start();      </span><br><span class="line">      <span class="comment">// 第一个参数是github仓库地址，第二个参数是创建的项目目录名，第三个参数是clone</span></span><br><span class="line">      download(downloadUrl, projectName, &#123;<span class="attr">clone</span>: <span class="literal">true</span>&#125;, err =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span>(err)&#123;</span><br><span class="line">              <span class="comment">// console.log('模板下载失败');</span></span><br><span class="line">              loading.fail(<span class="string">'模板下载失败'</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">// console.log('模板下载成功');</span></span><br><span class="line">              spinner.succeed(<span class="string">'模板下载成功'</span>);</span><br><span class="line">              <span class="comment">// 命令行答询</span></span><br><span class="line">              iq.prompt([</span><br><span class="line">                &#123;</span><br><span class="line">                    type: <span class="string">'input'</span>, <span class="comment">// 类型 输入框</span></span><br><span class="line">                    name: <span class="string">'name'</span>, <span class="comment">// 字段 key</span></span><br><span class="line">                    message: <span class="string">'请输入项目名称'</span>, <span class="comment">// 描述</span></span><br><span class="line">                    <span class="keyword">default</span>: projectName <span class="comment">// 默认值</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    type: <span class="string">'input'</span>,</span><br><span class="line">                    name: <span class="string">'description'</span>,</span><br><span class="line">                    message: <span class="string">'请输入项目简介'</span>,</span><br><span class="line">                    <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    type: <span class="string">'input'</span>,</span><br><span class="line">                    name: <span class="string">'author'</span>,</span><br><span class="line">                    message: <span class="string">'请输入作者名称'</span>,</span><br><span class="line">                    <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123; <span class="comment">// answers 是一个对象，对象的 key 为上面答询的 name 的值，value 为 用户输入的值，如果未输入，就取默认值</span></span><br><span class="line">                <span class="comment">// 根据命令行答询结果修改 package.json 文件</span></span><br><span class="line">                <span class="keyword">let</span> packageContent = fs.readFileSync(<span class="string">`<span class="subst">$&#123;projectName&#125;</span>/package.json`</span>, <span class="string">'utf8'</span>); <span class="comment">// 同步方式以 utf-8 字符集获得下载好的项目目录下的 package.json 文件</span></span><br><span class="line">                <span class="keyword">let</span> packageResult = hb.compile(packageContent)(answers); <span class="comment">// 将用户输入项与原内容混合获得新内容</span></span><br><span class="line">                fs.writeFileSync(<span class="string">`<span class="subst">$&#123;projectName&#125;</span>/package.json`</span>, packageResult); <span class="comment">// 重新同步方式写入到 package.json 文件中</span></span><br><span class="line">                <span class="comment">// 用chalk和log-symbols改变命令行输出样式</span></span><br><span class="line">                <span class="built_in">console</span>.log(ls.success, chalk.green(<span class="string">'模板项目文件准备成功！'</span>));</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// tfd list</span></span><br><span class="line">cmd</span><br><span class="line">  .command(<span class="string">'list'</span>)</span><br><span class="line">  .description(<span class="string">'查看所有可用模板'</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(`</span></span><br><span class="line">    <span class="comment">//       a   a模板</span></span><br><span class="line">    <span class="comment">//       b   b模板</span></span><br><span class="line">    <span class="comment">//       c   c模板</span></span><br><span class="line">    <span class="comment">//   `)</span></span><br><span class="line">    <span class="comment">// 通过获取templates里的key可以获取到模板名称</span></span><br><span class="line">    <span class="keyword">const</span> templateName = <span class="built_in">Object</span>.keys(templates)</span><br><span class="line">    <span class="built_in">console</span>.log(templateName)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// console.log(process.argv)</span></span><br><span class="line">cmd.parse(process.argv);</span><br></pre></td></tr></table></figure>

<p>到这里你自己的命令行工具就创建完成了，当然还可以继续丰富，比如加上选择条件等，这个就更复杂了，不在本文中展开，后续会继续改进这个命令行工具，当然如果要将自己的命令行工具给其他人用当然要先发布出去，就像我们要用<code>vue-cli</code>，首先要在<code>npm</code>上下载下来，同样的我们要想让别人用，就得先上传到<code>npm</code>上。</p>
<h1 id="发布到npm上"><a href="#发布到npm上" class="headerlink" title="发布到npm上"></a>发布到npm上</h1><p>首先你需要有一个npm的账号，没有赶快去注册一个，在控制台中输入<code>npm login</code>，它会让你依次输入 <code>Username</code> <code>Password</code> <code>Email</code> ，当你都按照要求输入完之后，成功的话你会获得如下信息<code>Logged in as XXX on https://registry.npm.org/.</code>，再接下来执行 <code>npm publish</code> 命令，你的自定义脚手架就会发布到<code>npm</code>上，供他人下载使用，怎么样，学会了么？</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章会有后续持续进化跟进，多篇文章连续，只要我的cli工具还在进化，文章就会继续，欢迎跟进。</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- async、await</title>
    <url>/2020/03/24/do-it-yourselfery-async-await/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>就是利用 <code>generator</code> （生成器）分割代码片段。然后我们使用一个函数让其自迭代，每一个 <code>yield</code> 用 <code>promise</code> 包裹起来。执行下一步的时机由 <code>promise</code> 来控制</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; <span class="comment">// 将返回值 promise 化</span></span><br><span class="line">      <span class="keyword">var</span> gen = fn.apply(self, args); <span class="comment">// 获取迭代器实例</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">_next</span>(<span class="params">value</span>) </span>&#123; <span class="comment">// 执行下一步</span></span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">'next'</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">_throw</span>(<span class="params">err</span>) </span>&#123; <span class="comment">// 抛出异常</span></span><br><span class="line">        asyncGeneratorStep(gen, resolve, reject, _next, _throw, <span class="string">'throw'</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">      _next(<span class="literal">undefined</span>); <span class="comment">// 第一次触发</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- EventEmitter(事件触发器)</title>
    <url>/2020/03/24/do-it-yourselfery-EventEmitter/</url>
    <content><![CDATA[<h1 id="实现一个-EventEmitter"><a href="#实现一个-EventEmitter" class="headerlink" title="实现一个 EventEmitter"></a>实现一个 <code>EventEmitter</code></h1><ol>
<li>创建一个 <code>Event</code> 类，包含<strong><em>构造函数、绑定、解绑、触发</em></strong>方法</li>
<li><code>on</code> 监听event事件，事件触发时调用fn函数。根据字典创建事件数组，如果事件处理不存在，那么就推入数组，反之返回原数组</li>
<li><code>off</code> 从字典中获取当前事件数组，如果获取值是数组，那么判断解绑哪个事件，如果没填清空全部（数组长度置为零），否则从事件数组删除选择的事件</li>
<li><code>emit</code> 触发event事件，并把参数arg1,arg2,arg3….传给事件处理函数，跟解绑外层判断一样，内层把删除改为执行即可</li>
<li><code>once</code> 为指定事件注册一个单次监听器，单次监听器最多只触发一次，触发后立即解除监听器。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 储存事件的数据结构</span></span><br><span class="line">    <span class="comment">// 为查找迅速， 使用对象（字典）</span></span><br><span class="line">    <span class="keyword">this</span>._cache = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定</span></span><br><span class="line">  on(event, callback) &#123;</span><br><span class="line">    <span class="comment">// 为了按类查找方便和节省空间</span></span><br><span class="line">    <span class="comment">// 将同一类型事件放到一个数组中</span></span><br><span class="line">    <span class="comment">// 这里的数组是队列， 遵循先进先出</span></span><br><span class="line">    <span class="comment">// 即新绑定的事件先触发</span></span><br><span class="line">    <span class="keyword">let</span> fns = (<span class="keyword">this</span>._cache[event] = <span class="keyword">this</span>._cache[event] || [])</span><br><span class="line">    <span class="keyword">if</span>(fns.indexOf(callback) === <span class="number">-1</span>) &#123;</span><br><span class="line">      fns.push(callback)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解绑</span></span><br><span class="line">  off (event, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>._cache[event]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(callback) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = fns.indexOf(callback)</span><br><span class="line">        <span class="keyword">if</span>(index !== <span class="number">-1</span>) &#123;</span><br><span class="line">          fns.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 全部清空</span></span><br><span class="line">        fns.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发emit</span></span><br><span class="line">  emit(event, ...args) &#123;</span><br><span class="line">    <span class="keyword">let</span> fns = <span class="keyword">this</span>._cache[event]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">      fns.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        fn(...args)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性绑定</span></span><br><span class="line">  once(event, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> onceCallback = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 定义一个只执行一次就解绑的方法</span></span><br><span class="line">      callback.call(<span class="keyword">this</span>); <span class="comment">// 使用call改变this指向</span></span><br><span class="line">      <span class="keyword">this</span>.off(event, onceCallback); <span class="comment">// 解绑</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.on(event, onceCallback); <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的接下来我们调用一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="keyword">new</span> Event()</span><br><span class="line"></span><br><span class="line">e.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'on'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// e.trigger('click', '666')</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- call、apply、bind</title>
    <url>/2020/03/24/do-it-yourselfery-call-apply/</url>
    <content><![CDATA[<h1 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h1><p>先来看一个call实例，看看call到底做了什么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>从代码的执行结果，我们可以看到，call首先改变了this的指向，使函数的this指向了foo,然后使bar函数执行了。<br>总结一下：</p>
<ul>
<li>call改变函数this指向</li>
<li>调用函数</li>
</ul>
<h1 id="自己动手"><a href="#自己动手" class="headerlink" title="自己动手"></a>自己动手</h1><ol>
<li>首先我们对参数 <code>context</code> 做了兼容处理，不传值， <code>context</code> 默认值为 <code>window</code> ；</li>
<li>然后我们将函数挂载到 <code>context</code> 上面, <code>context.fn = this</code> ；</li>
<li>处理参数，将传入 <code>myCall</code> 的参数截取，去除第一位，然后转为数组；</li>
<li>调用 <code>context.fn</code> ，此时 <code>fn</code> 的 <code>this</code> 指向 <code>context</code> ；</li>
<li>删除对象上的属性 <code>delete context.fn</code> ；</li>
<li>将结果返回。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>; <span class="comment">// 将函数挂载到对象的fn属性上</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>); <span class="comment">// 处理传入的参数</span></span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args); <span class="comment">// 通过对象的属性调用该方法</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn; <span class="comment">// 删除该属性</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 返回结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>apply</code> 跟 <code>call</code> 的区别在于参数， 其他没有差别，实现如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myApply的参数形式为(obj,[arg1,arg2,arg3]);</span></span><br><span class="line"><span class="comment">// 所以myApply的第二个参数为[arg1,arg2,arg3]</span></span><br><span class="line"><span class="comment">// 这里我们用扩展运算符来处理一下参数的传入方式</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123; <span class="comment">// 判断是否有第二个参数</span></span><br><span class="line">    result = context.fn(…<span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// 有的话传入执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn() <span class="comment">// 没有的话空参执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>bind</code> 和 <code>call</code> 、 <code>apply</code> 作用都是改变 <code>this</code> 的指向，区别在于 <code>bind</code> 改变后不会立即执行，而 <code>call</code> 和 <code>apply</code> 会立即执行，我们看一下 <code>bind</code> 的用法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=<span class="string">"zs"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age=<span class="number">18</span>;</span><br><span class="line">  <span class="keyword">this</span>.gender=<span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">  hobby:<span class="string">"看书"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> changePerson = Person.bind(obj); <span class="comment">// 将构造函数的this绑定为obj</span></span><br><span class="line">changePerson(); <span class="comment">// 直接调用构造函数,函数会操作obj对象,给其添加三个属性;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// =&gt; &#123;hobby:"看书",name:"zs",age:18,gender:'男'&#125;</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> changePerson(); <span class="comment">// 用改变了this 指向的构造函数,new一个实例出来</span></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// =&gt; Person &#123;name:"zs",age:18,gender:'男'&#125;</span></span><br></pre></td></tr></table></figure>
<p>仔细观察上面的代码，再看输出结果。</p>
<p>我们对 <code>Person</code> 类使用了 <code>bind</code> 将其 <code>this</code> 指向 <code>obj</code> ，得到了 <code>changePerson</code> 函数，此处如果我们直接调用 <code>changeperson</code> 会改变 <code>obj</code> ，若用 <code>new</code> 调用 <code>changeperson</code> 会得到实例 <code>p</code>，并且其 <code>__proto__</code> 指向 <code>Person</code> ,我们发现 <code>bind</code> 失效了。</p>
<p>我们得到结论：<strong><em>用 <code>bind</code> 改变了 <code>this</code> 指向的函数，如果用 <code>new</code> 操作符来调用， <code>bind</code> 将会失效</em></strong>。</p>
<p>这个对象就是这个构造函数的实例，那么只要在函数内部执行 <strong>* this instanceof 构造函数 *</strong> 来判断其结果是否为 <code>true</code> ，就能判断函数是否是通过 <code>new</code> 操作符来调用了，若结果为 <code>true</code> 则是用 <code>new</code> 操作符调用的，总结如下：</p>
<ol>
<li>保存当前 <code>this</code> 指向</li>
<li>保存环境上下文</li>
<li>保存参数，去掉第一个对象参数</li>
<li>返回待执行函数<ol>
<li>数组化剩余参数</li>
<li>判断是否为构造函数</li>
<li>若是执行构造函数，若不是改变 <code>this</code> 指向执行<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>; <span class="comment">// 1、保存函数</span></span><br><span class="line">  context = context || <span class="built_in">window</span>; <span class="comment">// 2、保存目标对象</span></span><br><span class="line">  <span class="keyword">let</span> rest = [...arguments].slice(<span class="number">1</span>); <span class="comment">// 3、保存目标对象之外的参数,将其转化为数组;</span></span><br><span class="line">  <span class="comment">// 此处开始与 call 和 apply 不同，不是返回结果，而是返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 4、返回一个待执行的函数</span></span><br><span class="line">    <span class="keyword">let</span> rest2 = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 5、这里的arguments是F函数的参数，转换为数组;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...rest2) <span class="comment">// 6、若是用new操作符调用,则直接用new 调用原函数,并用扩展运算符传递参数</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      _this.apply(context,rest.concat(rest2));  <span class="comment">// 7、用apply调用第一步保存的函数，并绑定this，传递合并的参数数组，</span></span><br><span class="line">                                                <span class="comment">// 即context._this(rest.concat(rest2))</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- Object.create()</title>
    <url>/2020/03/24/do-it-yourselfery-create/</url>
    <content><![CDATA[<h1 id="实现一个-Object-create-方法"><a href="#实现一个-Object-create-方法" class="headerlink" title="实现一个 Object.create() 方法"></a>实现一个 <code>Object.create()</code> 方法</h1><ol>
<li>创建一个空匿名函数</li>
<li>函数原型对象指向传入对象实例</li>
<li>返回构造函数创建的实例</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> =  <span class="title">function</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- Array.isArray</title>
    <url>/2020/03/24/do-it-yourselfery-isArray/</url>
    <content><![CDATA[<h1 id="实现一个Array-isArray"><a href="#实现一个Array-isArray" class="headerlink" title="实现一个Array.isArray"></a>实现一个Array.isArray</h1><p>思路很简单，就是利用 <code>Object.prototype.toString</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.myIsArray = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Object</span>(o)) === <span class="string">'[object Array]'</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- Array.prototype.flat()函数</title>
    <url>/2020/03/24/do-it-yourselfery-flat/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>将多层数组扁平化</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFlat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">      arr = arr.concat(item.myFlat()); <span class="comment">// 如果是数组的话继续循环</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      arr.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有另外一种实现方式，非常好用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myFlat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.toString() <span class="comment">// =&gt; "1,2,3,4"</span></span><br><span class="line">			.split(<span class="string">","</span>)   		<span class="comment">// =&gt; ["1", "2", "3", "4"]</span></span><br><span class="line">			.map(<span class="function"><span class="params">item</span> =&gt;</span> +item); <span class="comment">// =&gt; [1, 2, 3, 4]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- new</title>
    <url>/2020/03/24/do-it-yourselfery-new/</url>
    <content><![CDATA[<h1 id="实现一个new操作符"><a href="#实现一个new操作符" class="headerlink" title="实现一个new操作符"></a>实现一个new操作符</h1><p>我们首先知道new做了什么：</p>
<ol>
<li>创建一个空的简单 <code>JavaScript</code> 对象（即{}）</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象</li>
<li>将步骤（1）新创建的对象作为 <code>this</code> 的上下文</li>
<li>如果该函数没有返回对象，则返回 <code>this</code></li>
</ol>
<p>知道new做了什么，接下来我们就来实现它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">	<span class="comment">// 获得构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 将空对象指向构造函数的原型链</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, Con.prototype);</span><br><span class="line">	<span class="comment">// obj.__proto__ = Con.prototype // 链接到原型</span></span><br><span class="line">  <span class="comment">// obj绑定到构造函数上，便可以访问构造函数中的属性，即this.obj.Con(args)</span></span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 如果返回的result是一个对象则返回</span></span><br><span class="line">  <span class="comment">// new方法失效，否则返回obj</span></span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : <span class="keyword">this</span>.obj;</span><br><span class="line">	<span class="comment">// return typeof result === 'object' ? result : obj// 确保 new 出来的是个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- jsonp</title>
    <url>/2020/01/09/do-it-yourselfery-jsonp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试中时常会出现需要手动实现某个功能的要求，所以我准备整理一个自己动手实现系列文章，第一个呢就是自己动手实现 <code>jsonp</code></p>
<h2 id="实现-jsonp-思路"><a href="#实现-jsonp-思路" class="headerlink" title="实现 jsonp 思路"></a>实现 <code>jsonp</code> 思路</h2><ol>
<li>将传入的data数据转化为url字符串形式</li>
<li>处理url中的回调函数</li>
<li>创建一个script标签并插入到页面中</li>
<li>挂载回调函数</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">(function (window,document) &#123;</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	var jsonp &#x3D; function (url,data,callback) &#123;</span><br><span class="line">		&#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">		&#x2F;&#x2F; &#123;id:1,name:&#39;jack&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;jack</span><br><span class="line">		var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">		for(var key in data)&#123;</span><br><span class="line">			dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">		&#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">		var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">		dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">		var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">		scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">		window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">			callback(data); &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">			document.body.removeChild(scriptEle);</span><br><span class="line">		&#125;</span><br><span class="line">		document.body.appendChild(scriptEle);</span><br><span class="line">	&#125;</span><br><span class="line">	window.$jsonp &#x3D; jsonp;</span><br><span class="line">&#125;)(window,document)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- Array.prototype.map()</title>
    <url>/2020/03/24/do-it-yourselfery-map/</url>
    <content><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>先看看 <code>reduce</code> 和 <code>map</code> 的使用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[,array</span>) </span>&#123;<span class="comment">/* Return element for new_array */</span> &#125;[, thisArg])</span><br><span class="line"><span class="keyword">let</span> result = arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>第一种用 <code>for</code> 实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">    arr.push(callback.call(thisArg, <span class="keyword">this</span>[i], i, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第二种用 <code>reduce</code> 实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span>(<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">accumulator, currentValue, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    accumulator.push(callback.call(thisArg, currentValue, index, array));</span><br><span class="line">    <span class="keyword">return</span> accumulator;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- promise</title>
    <url>/2020/01/13/do-it-yourselfery-promise/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试中时常会出现需要手动实现某个功能的要求，所以我准备整理一个自己动手实现系列文章，这一次呢就是自己动手实现 <code>promise</code></p>
<h2 id="实现-promise-思路"><a href="#实现-promise-思路" class="headerlink" title="实现 promise 思路"></a>实现 <code>promise</code> 思路</h2><p><strong>基础步骤</strong></p>
<ol>
<li>设定三个状态 <code>PENDING</code> 、 <code>FULFILLED</code> 、 <code>REJECTED</code>  ，只能由 <code>PENDING</code> 改变为 <code>FULFILLED</code> 、 <code>REJECTED</code> ，并且只能改变一次</li>
<li><code>MyPromise</code> 接收一个函数 <code>executor</code> ， <code>executor</code> 有两个参数 <code>resolve</code> 方法和 <code>reject</code> 方法</li>
<li><code>resolve</code> 将 <code>PENDING</code> 改变为 <code>FULFILLED</code></li>
<li><code>reject</code> 将 <code>PENDING</code> 改变为 <code>FULFILLED</code></li>
<li><code>promise</code> 变为 <code>FULFILLED</code> 状态后具有一个唯一的 <code>value</code></li>
<li><code>promise</code> 变为 <code>REJECTED</code> 状态后具有一个唯一的 <code>reason</code></li>
</ol>
<p>** <code>then</code> 方法**</p>
<ol>
<li><code>then</code> 方法接受两个参数 <code>onFulfilled</code> 、 <code>onRejected</code> ，它们分别在状态由 <code>PENDING</code> 改变为 <code>FULFILLED</code> 、 <code>REJECTED</code> 后调用</li>
<li>一个 <code>promise</code> 可绑定多个 <code>then</code> 方法</li>
<li><code>then</code> 方法可以同步调用也可以异步调用</li>
<li>同步调用：状态已经改变，直接调用 <code>onFulfilled</code> 方法</li>
<li>异步调用：状态还是 <code>PENDING</code> ，将 <code>onFulfilled</code> 、 <code>onRejected</code> 分别加入两个函数数组 <code>onFulfilledCallbacks</code> 、 <code>onRejectedCallbacks</code> ，当异步调用 <code>resolve</code> 和 <code>reject</code> 时，将两个数组中绑定的事件循环执行。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义MyPromise模拟Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;func&#125;</span> </span>executor 接收函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.state = PENDING; <span class="comment">// 默认状态为 pending</span></span><br><span class="line">	<span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义成功失败的函数数组</span></span><br><span class="line">	<span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义成功回调</span></span><br><span class="line">	<span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">			<span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">				func();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义失败回调</span></span><br><span class="line">	<span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">			<span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">			<span class="keyword">this</span>.reason = reason;</span><br><span class="line">			<span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">				func();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		executor(resolve, reject);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">		reject(reason);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">		<span class="keyword">case</span> FULFILLED:</span><br><span class="line">			onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> REJECTED:</span><br><span class="line">			onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PENDING:</span><br><span class="line">			<span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then方法异步调用"><a href="#then方法异步调用" class="headerlink" title="then方法异步调用"></a>then方法异步调用</h2><p>如下面的代码：输入顺序是：1、2、ConardLi</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'ConardLi'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>虽然 <code>resolve</code> 是同步执行的，我们必须保证 <code>then</code> 是异步调用的，我们用 <code>setTimeout</code> 来模拟异步调用（并不能实现微任务和宏任务的执行机制，只是保证异步调用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> reason;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">		<span class="keyword">case</span> FULFILLED:</span><br><span class="line">			setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			&#125;, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> REJECTED:</span><br><span class="line">			setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">			&#125;, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PENDING:</span><br><span class="line">			<span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then方法链式调用"><a href="#then方法链式调用" class="headerlink" title="then方法链式调用"></a>then方法链式调用</h2><p>保证链式调用，即 <code>then</code> 方法中要返回一个新的 <code>promise</code> ，并将 <code>then</code> 方法的返回值进行 <code>resolve</code> 。</p>
<p><em>注意：这种实现并不能保证 <code>then</code> 方法中返回一个新的 <code>promise</code> ，只能保证链式调用</em>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> reason;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个新的MyPromise对象</span></span><br><span class="line">	<span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">			<span class="keyword">case</span> FULFILLED:</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">						resolve(x);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">						reject(reason);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REJECTED:</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">						resolve(x);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">						reject(reason);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PENDING:</span><br><span class="line">				<span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">							resolve(x);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">							reject(reason);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, <span class="number">0</span>);</span><br><span class="line">				&#125;)</span><br><span class="line">				<span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">							resolve(x);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">							reject(reason);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, <span class="number">0</span>);</span><br><span class="line">				&#125;)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>若上面没有定义 <code>reject</code> 方法，所有的异常会走向 <code>catch</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>不管是 <code>resolve</code> 还是 <code>reject</code> 都会调用 <code>finally</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">		fn();</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;, reason =&gt; &#123;</span><br><span class="line">		fn();</span><br><span class="line">		<span class="keyword">throw</span> reason;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p><code>Promise.resolve</code> 用来生成一个直接处于 <code>FULFILLED</code> 状态的 <code>Promise</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><p><code>Promise.reject</code> 用来生成一个直接处于 <code>REJECTED</code> 状态的 <code>Promise</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h2><p>接受一个 <code>promise</code> 数组，当所有 <code>promise</code> 状态 <code>resolve</code> 后，执行 <code>resolve</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">			resolve([]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> result = [];</span><br><span class="line">			<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">					result[i] = data;</span><br><span class="line">					<span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">						resolve(result);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h2><p>接受一个 <code>promise</code> 数组，当有一个 <code>promise</code> 状态 <code>resolve</code> 后，执行 <code>resolve</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">			resolve();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">					resolve(data);</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如此一个自定义的 <code>promise</code> 就实现了，怎么样学回来吗？</p>
]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- Array.prototype.reduce</title>
    <url>/2020/03/24/do-it-yourselfery-reduce/</url>
    <content><![CDATA[<h1 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>

<h1 id="自己动手"><a href="#自己动手" class="headerlink" title="自己动手"></a>自己动手</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span>(<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue ? initialValue : <span class="keyword">this</span>[<span class="number">0</span>]; <span class="comment">// 第一次使用判断时候有initialValue参数，如果有用他，没有用this[0]，这里this指的是传入的数组，this[0]就是数组第一项</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initialValue ? <span class="number">0</span> : <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123; <span class="comment">// 如果有初始值从0开始循环，不然从1开始</span></span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>; <span class="comment">// 保留当前this指向</span></span><br><span class="line">    accumulator = callback(accumulator, <span class="keyword">this</span>[i], i, _this); <span class="comment">// </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator; <span class="comment">// 返回迭代器的终值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>试用一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = arr.myReduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> &#123;</span><br><span class="line">  acc += val;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- 事件代理</title>
    <url>/2020/03/24/do-it-yourselfery-%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"color-list"</span>&gt;</span><br><span class="line">  &lt;li&gt;red&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;yellow&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;blue&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;green&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;black&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;white&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  (function () &#123;</span></span><br><span class="line"><span class="regexp">    var color_list = document.getElementById('color-list');</span></span><br><span class="line"><span class="regexp">    color_list.addEventListener('click', showColor, true);</span></span><br><span class="line"><span class="regexp">    function showColor(e) &#123;</span></span><br><span class="line"><span class="regexp">      var x = e.target;</span></span><br><span class="line"><span class="regexp">      if (x.nodeName.toLowerCase() === 'li') &#123;</span></span><br><span class="line"><span class="regexp">        alert(x.innerHTML);</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;)();</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- Vue双向绑定</title>
    <url>/2020/03/24/do-it-yourselfery-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h1 id="Vue-2-x-的-Object-defineProperty-版本"><a href="#Vue-2-x-的-Object-defineProperty-版本" class="headerlink" title="Vue 2.x 的 Object.defineProperty 版本"></a>Vue 2.x 的 <code>Object.defineProperty</code> 版本</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">'default'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> span = <span class="built_in">document</span>.getElementById(<span class="string">'span'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">'text'</span>, &#123;</span><br><span class="line">  <span class="comment">// 数据变化 —&gt; 修改视图</span></span><br><span class="line">  <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">    input.value = newVal;</span><br><span class="line">    span.innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  data.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Vue-3-x-的-proxy-版本"><a href="#Vue-3-x-的-proxy-版本" class="headerlink" title="Vue 3.x 的 proxy 版本"></a>Vue 3.x 的 <code>proxy</code> 版本</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  text: <span class="string">'default'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> span = <span class="built_in">document</span>.getElementById(<span class="string">'span'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据劫持</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="comment">// 数据变化 —&gt; 修改视图</span></span><br><span class="line">    input.value = value;</span><br><span class="line">    span.innerHTML = value;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视图更改 --&gt; 数据变化</span></span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  proxy.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>源码原理</category>
        <category>自己动手实现系列</category>
      </categories>
      <tags>
        <tag>自己动手实现系列</tag>
      </tags>
  </entry>
  <entry>
    <title>给我的Hexo博客添加文章内容搜索功能</title>
    <url>/2020/01/13/hexo-search/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年我下定决心一定要好好地写博客，完善博客的内容，所以最近把原来记在各种笔记中的文章内容都一一转移到了博客，内容一多想找一篇文章时就变得很麻烦，我得去归档中或者分类中一篇篇的找，所以我觉得是时候该给我的博客添加搜索的功能了，我看了博客的config文件，其中并没有搜索相关的配置，我又看了主题的配置文件，这下让我找到了，有个local_search的选项，于是我就开始了博客搜索的研究。</p>
<span id="more"></span>
<h2 id="主题里的搜索配置"><a href="#主题里的搜索配置" class="headerlink" title="主题里的搜索配置"></a>主题里的搜索配置</h2><p>这段代码是这样的，实际上我只需要把 <code>enable</code> 从 <code>false</code> 变成 <code>true</code> 就好了</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后我又看了一下上面提供的依赖地址，这里还需要做两步，一个是安装搜索的依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>接着就是在博客系统的配置最下方加入下面这段话</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<p>到这里如果没什么问题，那么搜索功能就加上了，怎么样简单吧。如果你遇到什么问题，可以到上面的地址看一下，上面有详细的说明，我这里就不贴代码了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>希望大家都能丰富自己的技术博客，拥有属于自己的一片技术天地。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>博客技巧</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 GitLab CI/CD 的自动化构建、发布实践</title>
    <url>/2019/12/31/gitlab-cicd/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司于去年开始代码版本管理从SVN迁移到了Git，采用的GitLab程序做管理，但是自动构建采用的是Jekins，最近在给博客做自动构建的时候了解到的了Github的Actions，我就在想，是不是GitLab也有自己的自动构建能力，因为之前在参与项目的时候也看到GitLab上有CI/CD相关的内容，但是没有仔细的去看，趁这次机会就一起研究一下。</p>
<a id="more"></a>

<h2 id="说一下目前公司的构建和发布流程"><a href="#说一下目前公司的构建和发布流程" class="headerlink" title="说一下目前公司的构建和发布流程"></a>说一下目前公司的构建和发布流程</h2><p>1、<strong><em>手动构建时代</em></strong>：开发人员在测试需要验证环境的时候，在本地执行打包构建命令，然后将包放到服务器上，整个过程30分钟左右。<br>2、<strong><em>自动构建时代</em></strong>目前公司的构建是要在Jekins中，首先是在Jekins中配置拉去代码的仓库地址和代码分支，写好构建的脚本，在需要构建时候进行构建，一次配置后构建全程只需要点一下构建时间长度跟项目代码需要下载的依赖时间有关，通常不超过5分钟，需要注意的是要在构建前同步一下代码版本<br><strong><em>划重点</em></strong><br>在原来的手动构建时代，代码是以开发本地的代码为准，代码版本很可能跟最新的代码有出入，而且依赖于开发的电脑设备，如果他请假了，那么就GG了；另外通过一次配置后整个构建的时间从30分钟降到了5分钟，一次节省25分钟，那么一个项目周期下节省的工时就非常可观了。</p>
<h2 id="为什要使用GitLab-CI-CD进行构建"><a href="#为什要使用GitLab-CI-CD进行构建" class="headerlink" title="为什要使用GitLab CI/CD进行构建"></a>为什要使用GitLab CI/CD进行构建</h2><p>这里实际上没有太大的必要将公司的Jekins替换为GitLab的CI/CD进行自动构建，但是呢，因为公司本身采用的就是GitLab作为代码仓库管理代码，它本身又提供了CI/CD的功能，本着多学一点是一点的原则，我就花点时间研究一下它。</p>
<h2 id="什么是-GitLab-CI-CD"><a href="#什么是-GitLab-CI-CD" class="headerlink" title="什么是 GitLab CI/CD"></a>什么是 GitLab CI/CD</h2><p>下面我就要开始把我了解到的GitLab CI/CD的使用方式说一下，从零开始搭建GitLab CI/CD。</p>
<h3 id="1-简要介绍-GitLab-CI-CD"><a href="#1-简要介绍-GitLab-CI-CD" class="headerlink" title="1. 简要介绍 GitLab CI/CD"></a>1. 简要介绍 GitLab CI/CD</h3><p>代码提交到GitLab上后，满足指定条件之后会触发pipeline进行自动化构建、发布。<br><strong><em>pipeline</em></strong>可以理解为构建任务，里面可以包含多个流程，比如下载依赖、运行测试、编译、部署。<br>那么pipeline什么时候触发，分为几个流程，每个流程做什么，需要在项目的<strong><em>.gitlab-ci.yml</em></strong>文件中的定义。<br>这点呢跟Jekins里面实际上做的也是同样的事，在线下开发做构建时候也是做这些事，只是通过脚本之后这些事都可以交给计算机做了。</p>
<h3 id="2-GitLab-CI-CD-整体流程"><a href="#2-GitLab-CI-CD-整体流程" class="headerlink" title="2. GitLab CI/CD 整体流程"></a>2. GitLab CI/CD 整体流程</h3><ul>
<li>GitLab CI/CD 的 pipeline 具体流程和操作在 .gitlab-ci.yml 文件中申明。</li>
<li>触发 pipeline 后，由 GitLab Runner 根据  .gitlab-ci.yml 文件运行。</li>
<li>运行结束后将返回至 GitLab 系统。</li>
</ul>
<h4 id="2-1-gitlab-ci-yml-文件"><a href="#2-1-gitlab-ci-yml-文件" class="headerlink" title="2.1 .gitlab-ci.yml 文件"></a>2.1 .gitlab-ci.yml 文件</h4><p>.gitlab-ci.yml 文件是一个申明式文件，用于定义 GitLab CI/CD 流程分为几个阶段，每个阶段分别干什么。</p>
<p>关于具体干什么、怎么干，主要使用命令行和脚本操作，稍后会在实践部分做细致的介绍。</p>
<p>如果涉及一些逻辑的话，会使用脚本（shell）。</p>
<h4 id="2-2-GitLab-Runner"><a href="#2-2-GitLab-Runner" class="headerlink" title="2.2 GitLab Runner"></a>2.2 GitLab Runner</h4><p>GitLab Runner 是 CI 的执行环境，负责执行 gitlab-ci.yml 文件，并将结果返回给 GitLab 系统。Runner 具体可以有多种形式，docker、虚拟机或 shell，在注册 runner 时选定方式。实际上就是运行脚本的容器环境。</p>
<h2 id="3-从零搭建一个-GitLab-CI-CD-的基本步骤"><a href="#3-从零搭建一个-GitLab-CI-CD-的基本步骤" class="headerlink" title="3. 从零搭建一个 GitLab CI/CD 的基本步骤"></a>3. 从零搭建一个 GitLab CI/CD 的基本步骤</h2><p>上面介绍了一些GitLab构建的主要环节和名词概念，接下来我将给大家介绍一下如何从零搭建一个GitLab CI/CD，一起体验一把GitLab CI/CD的整个流程。</p>
<h3 id="3-1-新建一个-GitLab-项目"><a href="#3-1-新建一个-GitLab-项目" class="headerlink" title="3.1 新建一个 GitLab 项目"></a>3.1 新建一个 GitLab 项目</h3><p>我这用的是公司的自有仓库，各位可以在开源GitLab上创建自己的项目</p>
<h3 id="3-2-配置Runner"><a href="#3-2-配置Runner" class="headerlink" title="3.2 配置Runner"></a>3.2 配置Runner</h3><p>GitLab 提供了一些共享的Runner，我们可以不处理Runner，这里可以理解为，它提供了一些现成的脚本运行环境，不需要我们从头配置运行环境，so sweet～</p>
<h3 id="3-3-新建-gitlab-ci-yml-文件"><a href="#3-3-新建-gitlab-ci-yml-文件" class="headerlink" title="3.3 新建 .gitlab-ci.yml 文件"></a>3.3 新建 .gitlab-ci.yml 文件</h3><ol>
<li>拉取项目到本地</li>
<li>在项目根目录新建 .gitlab-ci.yml 文件</li>
<li>提交 .gitlab-ci.yml 文件</li>
<li>在项目的 CI/CD 中，可以看到 CI/CD 的运行情况<br>这个过程应该没人不会吧，没技术含量的我们简单一提，实际上最重要的就是.gitlab-ci.yml文件中要怎么去写，示例说明文件如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .gitlab-ci.yml 示例说明</span><br><span class="line"></span><br><span class="line">image: node</span><br><span class="line"># 定义 stages</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line"># 定义 job</span><br><span class="line"> build 阶段:</span><br><span class="line">  stage: build</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;build stage&quot;</span><br><span class="line"># 定义 job</span><br><span class="line">发布到测试环境:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;test stage&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="GitLab-CI-CD-实践"><a href="#GitLab-CI-CD-实践" class="headerlink" title="GitLab CI/CD 实践"></a>GitLab CI/CD 实践</h2><p>在实践部分，这里着重介绍 GitLab Runner 和 .gitlab-ci.yml 文件，主要的流程及遇到的问题和解决方案包含在 .gitlab-ci.yml 文件的介绍过程中。</p>
<h3 id="1-GitLab-Runner"><a href="#1-GitLab-Runner" class="headerlink" title="1. GitLab Runner"></a>1. GitLab Runner</h3><p>GitLab Runner 一般由 GitLab 系统维护者管理，配置后，同类项目可以共享，一般不需要进行修改。这里不进行具体介绍，主要介绍下使用过程中的注意点，具体使用可参考 GitLab Runner 文档。（<a href="https://docs.gitlab.com.cn/runner/）" target="_blank" rel="noopener">https://docs.gitlab.com.cn/runner/）</a></p>
<h4 id="1-1-GitLab-Runner-使用流程"><a href="#1-1-GitLab-Runner-使用流程" class="headerlink" title="1.1 GitLab Runner 使用流程"></a>1.1 GitLab Runner 使用流程</h4><ol>
<li>下载 GitLab Runner</li>
<li>注册 GitLab Runner</li>
<li>使用 GitLab Runner</li>
</ol>
<h4 id="1-2-GitLab-Runner-注意点"><a href="#1-2-GitLab-Runner-注意点" class="headerlink" title="1.2 GitLab Runner 注意点"></a>1.2 GitLab Runner 注意点</h4><p>在使用 Runner 的过程中，我们遇到了一些问题，下面简要介绍问题及解决方案，不做具体介绍。</p>
<h5 id="1-2-1-配置-Runner-后，push-代码，出发了-pipeline，但一直处于Pending状态"><a href="#1-2-1-配置-Runner-后，push-代码，出发了-pipeline，但一直处于Pending状态" class="headerlink" title="1.2.1 配置 Runner 后，push 代码，出发了 pipeline，但一直处于Pending状态"></a>1.2.1 配置 Runner 后，push 代码，出发了 pipeline，但一直处于Pending状态</h5><p>错误信息是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This job is stuck, because you don’t have any active runners that can run this job</span><br></pre></td></tr></table></figure>
<p>注册的 Runner，默认情况下，不会运用没有 <code>tag</code> 的 job，可以在 Settings→CI/CD→Runners Settings，去掉 Runner untagged jobs 即可。</p>
<h5 id="1-2-2-GitLab-Runner-的类型"><a href="#1-2-2-GitLab-Runner-的类型" class="headerlink" title="1.2.2 GitLab Runner 的类型"></a>1.2.2 GitLab Runner 的类型</h5><p>有三种类型的 Runner，</p>
<ul>
<li>Shared Runners 在整个系统所有项目都可以使用</li>
<li>Group Runners 注册后，同一个项目下的不同代码库共享</li>
<li>Specific Runners 需要给项目单独配置，使用 Specific Runners 注意考虑是否需要关闭 Shared Runners、和 Group Runners。</li>
</ul>
<h5 id="1-2-3-在-GitLab-CI-中使用-docker"><a href="#1-2-3-在-GitLab-CI-中使用-docker" class="headerlink" title="1.2.3 在 GitLab CI 中使用 docker"></a>1.2.3 在 GitLab CI 中使用 docker</h5><p>如果部署使用的是docker方式，那么在部署时需要在 GitLab CI/CD 中使用 docker 打镜像发布。可以参考 Building Docker images with GitLab CI/CD（<a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html）" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/docker/using_docker_build.html）</a></p>
<h5 id="1-2-4-在-GitLab-CI-CD-中访问-Runner-宿主机目录"><a href="#1-2-4-在-GitLab-CI-CD-中访问-Runner-宿主机目录" class="headerlink" title="1.2.4 在 GitLab CI/CD 中访问 Runner 宿主机目录"></a>1.2.4 在 GitLab CI/CD 中访问 Runner 宿主机目录</h5><p>我们使用的 Runner executor 是 Dokcer，在 Dokcer volumes 中配置需要访问的目录。</p>
<h3 id="2-gitlab-ci-yml-文件"><a href="#2-gitlab-ci-yml-文件" class="headerlink" title="2. .gitlab-ci.yml 文件"></a>2. .gitlab-ci.yml 文件</h3><p>.gitlab-ci.yml 详细的用法，可参考 GitLab CI/CD Pipeline Configuration Reference 文档（<a href="https://docs.gitlab.com/ee/ci/yaml/README.html）" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/yaml/README.html）</a></p>
<h4 id="2-1-gitlab-ci-yml-文件结构介绍"><a href="#2-1-gitlab-ci-yml-文件结构介绍" class="headerlink" title="2.1 .gitlab-ci.yml 文件结构介绍"></a>2.1 .gitlab-ci.yml 文件结构介绍</h4><ul>
<li><code>image</code> 是执行 CI/CD 依赖的 Docker 基础镜像。镜像中有 Node、Yarn、Dalp（内部 rsync 工具）。</li>
<li><code>stages</code> 中定义了我们的 pipeline 分为以下几个过程:<ol>
<li>下载依赖阶段 pre_build</li>
<li>构建阶段 build</li>
<li>发布阶段 deploy</li>
</ol>
</li>
<li><code>stage</code> 申明当前的阶段，在 stages 中使用</li>
<li><code>variables</code> 用于定义变量</li>
<li><code>before_script</code> 执行 script 前的操作</li>
<li><code>script</code> 当前 stage 需要执行的操作</li>
<li><code>changes</code> 指定 stage 触发条件</li>
<li><code>refs</code> 指定 stage 触发的分支</li>
</ul>
<p>下面具体看一下我们这个.gitlab-ci.yml文件实际的样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image: registry.thunisoft.com&#x2F;gitlab-ci&#x2F;node:v1.8</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">  # $CI_PROJECT_PATH  ：项目id,用于项目唯一区分本项目与其它项目</span><br><span class="line">  # $CI_PROJECT_DIR   ：本地项目路径</span><br><span class="line">  # $PROCESS_PATH     ：临时文件目录(包括日志和一些临时文件)</span><br><span class="line">  NODE_MODULES_PATH: &#x2F;runner-cache&#x2F;frontend&#x2F;$CI_PROJECT_PATH&#x2F;$CI_BUILD_REF_NAME&#x2F;node_modules</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">  - pre_build # 下载依赖阶段</span><br><span class="line">  - build # 构建阶段</span><br><span class="line">  - deploy # 测试发布阶段</span><br><span class="line"></span><br><span class="line"># 下载依赖:</span><br><span class="line">  before_script: # 下载依赖前准备脚本</span><br><span class="line">    # 无 node_modules 文件时，新建 node_modules 文件</span><br><span class="line">    - &#x2F;bin&#x2F;bash .&#x2F;ci&#x2F;mkdir.sh $NODE_MODULES_PATH</span><br><span class="line">    # 软链 node_modules 到宿主机</span><br><span class="line">    - ln -s $NODE_MODULES_PATH .</span><br><span class="line">    - cd webpack@lixuguang-project</span><br><span class="line"></span><br><span class="line">  stage: pre_build</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;npm install&quot;</span><br><span class="line">    - npm install  --network-timeout 60000 # 安装依赖</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - webpack@lixuguang-project&#x2F;package.json</span><br><span class="line">    refs:</span><br><span class="line">      - master</span><br><span class="line">      - ci</span><br><span class="line"></span><br><span class="line"># 构建:</span><br><span class="line">  stage: build</span><br><span class="line">  variables:</span><br><span class="line">    CI_COMMIT_BEFORE_SHA_PATH: &#x2F;mnt&#x2F;gv0&#x2F;gitlab-runner-cache&#x2F;$CI_PROJECT_PATH</span><br><span class="line">    CI_COMMIT_BEFORE_SHA_FILE_NAME: $CI_BUILD_REF_NAME.sh</span><br><span class="line">    CI_COMMIT_BEFORE_SHA_FILE: &#x2F;mnt&#x2F;gv0&#x2F;gitlab-runner-cache&#x2F;$CI_PROJECT_PATH&#x2F;$CI_BUILD_REF_NAME.sh</span><br><span class="line">  before_script:</span><br><span class="line">    # 建存此次 CI CI_COMMIT_SHA 的文件</span><br><span class="line">    - &#x2F;bin&#x2F;bash .&#x2F;ci&#x2F;mkfile.sh $CI_COMMIT_BEFORE_SHA_PATH $CI_COMMIT_BEFORE_SHA_FILE_NAME</span><br><span class="line">    # 软链 node_modules 到宿主机</span><br><span class="line">    - ln -s $NODE_MODULES_PATH .</span><br><span class="line">    - rm -rf web&#x2F;share&#x2F;*</span><br><span class="line">    - cd webpack@lixuguang-projects</span><br><span class="line">  script:</span><br><span class="line">    # 缓存上次ci</span><br><span class="line">    - source $CI_COMMIT_BEFORE_SHA_FILE</span><br><span class="line">    - echo &quot;CI_COMMIT_BEFORE_SHA&#x3D;$CI_COMMIT_SHA&quot; &gt; $CI_COMMIT_BEFORE_SHA_FILE</span><br><span class="line">    - python3 ..&#x2F;ci&#x2F;build.py   # 编译</span><br><span class="line">    - &#x2F;bin&#x2F;bash ..&#x2F;ci&#x2F;commit.sh   # 提交编译结果</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - www_src&#x2F;**&#x2F;*</span><br><span class="line">    refs:</span><br><span class="line">      - master</span><br><span class="line">      - ci</span><br><span class="line"></span><br><span class="line"># 测试发布:</span><br><span class="line">  stage: deploy</span><br><span class="line">  variables:</span><br><span class="line">    PROCESS_PATH: &#x2F;mnt&#x2F;gv0&#x2F;gitlab-runner-cache&#x2F;deploy&#x2F;process&#x2F;$CI_JOB_ID  # 目录不要换，用于日志服务器获取日志展示</span><br><span class="line">  script:</span><br><span class="line">    - mkdir $PROCESS_PATH # 建立发布临时路径，存放发布配置中间文件和结果日志用</span><br><span class="line">    - dplt $CI_PROJECT_DIR&#x2F;.deploy_test.yml $CI_PROJECT_PATH $CI_PROJECT_DIR&#x2F;web&#x2F; $PROCESS_PATH</span><br><span class="line">    # dplt 发布yml配置</span><br><span class="line">    - echo &quot;发布完成，错误日志查看http:&#x2F;&#x2F;172.18.78.11:8089&#x2F;log?path&#x3D;&quot;$PROCESS_PATH</span><br><span class="line">    - echo &#96;ls $PROCESS_PATH&#x2F;*.log&#96;</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - web&#x2F;**&#x2F;*</span><br><span class="line">    refs:</span><br><span class="line">      - test</span><br></pre></td></tr></table></figure>

<h4 id="2-2-下载依赖阶段（pre-build-stage）"><a href="#2-2-下载依赖阶段（pre-build-stage）" class="headerlink" title="2.2 下载依赖阶段（pre_build stage）"></a>2.2 下载依赖阶段（pre_build stage）</h4><p>下载依赖的方案是：当 package.json 文件发生变化时，触发 pre_build stage，执行 npm install。下载的 node_modules 放在宿主机下，执行时通过软链获取依赖。</p>
<h4 id="2-3-构建阶段（build-stage）"><a href="#2-3-构建阶段（build-stage）" class="headerlink" title="2.3 构建阶段（build stage）"></a>2.3 构建阶段（build stage）</h4><p>构建阶段，分为 3 部分</p>
<ol>
<li>diff 文件变化</li>
<li>前端 build</li>
<li>commit build 后结果</li>
</ol>
<h5 id="2-3-1-diff-文件变化"><a href="#2-3-1-diff-文件变化" class="headerlink" title="2.3.1 diff 文件变化"></a>2.3.1 diff 文件变化</h5><p>每次 CI 时，将当前 CI commit SHA（CI_COMMIT_SHA 变量）存在文件中，存为 CI_COMMIT_BEFORE_SHA 变量， diff 时，git diff 当前 CI 与上次 commit SHA 的变化。</p>
<h5 id="2-3-2-前端-build"><a href="#2-3-2-前端-build" class="headerlink" title="2.3.2 前端 build"></a>2.3.2 前端 build</h5><p>根据 git diff 的变化情况，确定本次需要打包的内容。</p>
<h5 id="2-3-3-commit-打包后生成的-HTML-文件"><a href="#2-3-3-commit-打包后生成的-HTML-文件" class="headerlink" title="2.3.3 commit 打包后生成的 HTML 文件"></a>2.3.3 commit 打包后生成的 HTML 文件</h5><p>在 GitLab CI/CD 提交代码时，使用 Git 凭证存储，提交打包后的 HTML 文件。Git 凭证存储细节可参考凭证存储文档(<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8</a>)</p>
<h4 id="2-4-发布阶段（deploy-stage）"><a href="#2-4-发布阶段（deploy-stage）" class="headerlink" title="2.4 发布阶段（deploy stage）"></a>2.4 发布阶段（deploy stage）</h4><p>发布阶段，使用内部的 rsync 工具 dplt 将打包后的 HTML 文件部署。dplt 可配置集群、机器列表。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是GitLab CI/CD的整个理论到实践的全部过程，实现之后你就可以解放双手了，是不是超爽。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>持续集成是什么？(<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a>)</p>
<p>什么是 CI/CD？(<a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener">https://www.redhat.com/zh/topics/devops/what-is-ci-cd</a>)</p>
<p>GitLab Docs(<a href="https://docs.gitlab.com/" target="_blank" rel="noopener">https://docs.gitlab.com/</a>)</p>
<p>Introduction to CI/CD with GitLab(<a href="https://docs.gitlab.com/ee/ci/introduction/" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/introduction/</a>)</p>
<p>用 GitLab CI 进行持续集成(<a href="https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/" target="_blank" rel="noopener">https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</a>)</p>
<p>如何实现前端工程的持续集成与持续部署？(<a href="https://www.zhihu.com/question/60194439" target="_blank" rel="noopener">https://www.zhihu.com/question/60194439</a>)</p>
<p>基于 GitLab CI 的前端工程CI/CD实践(<a href="https://github.com/giscafer/front-end-manual/issues/27" target="_blank" rel="noopener">https://github.com/giscafer/front-end-manual/issues/27</a>)</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
        <tag>自动构建</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始：学习Go（一）</title>
    <url>/2020/11/09/learn-go/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><a id="more"></a>]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决npm安装node-sass依赖慢的情况</title>
    <url>/2020/04/15/node-sass-slow-problem/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现代前端开发不用点预编译css都不好意思说自己咋写样式，虽说这么说有点夸张，但是确实是一个普遍现象吧，我们在开发中常见到的预编译css的话主要是sass和less，那么今天的主角就是其中的sass，可以说sass让人又爱又恨，爱呢是喜欢她赋予了css函数的特性，恨呢就是用的时候实在是麻烦，所以有的人就投奔了less的怀抱，他俩很像，但是有的项目已经用了sass那也没办法，嫁鸡随鸡，但是日子还得过，想办法过的好一点嘛。</p>
<p>其实这里说到sass用起来麻烦主要还是在安装依赖的时候，想必用过的人都知道我说的是啥，原来只能是不停的重试，最近在知乎上看到篇文章，聪明的解决了这个问题，所以赶紧学习记录下来，学会了就是自己的。</p>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用sass时要安装node-sass包，但是这个npm包安装不尽慢的要命，下载下来之后还要进行编译，编译环境不合适或者网速不好的时候，光为了这个包的使用花上个把小时绝对正常，记得第一次折腾他用了小半天的时间。</p>
<p>那么有没有什么方法可以解决这个问题呢？</p>
<p>有痛点就会有人想办法解决，但是包名已经占用了，想用的话还是要有点配置的代价，但总好过编译和下载</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我这里假设你是知道 yarn 这个工具的，对的，接下来我们要用 yarn 进行安装，但是安装的不是 node-sass ，而是一个叫做 node-sass-install 的这个包， 安装他的话就不用在安装 node-sass 这个包了，通常来说安装这个包不会超过10s ， 当然网速不好的话超过10s了也别怪我，总之要比装 node-sass 要快上很多，命令如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add node-sass-install</span><br></pre></td></tr></table></figure>
<p>是不是很简单，当然如果你觉得为了安装 node-sass 还要再装个 yarn （鄙视你居然不用 yarn ），那你也可以用 npm 安装，命令稍有不同，长了一点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install node-sass-install -D</span><br><span class="line">npx node-sass-install</span><br></pre></td></tr></table></figure>
<p>比 yarn 多了一条命令，那么他为啥这么神奇呢，且听我分析一下</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个 node-sass-install 其实只是在 package.json 的 dependencies 中做了一些配置，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;node-sass&quot;</span>:<span class="string">&quot;npm:dart-sass@latest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个配置的意思是，当你安装 node-sass-install 的时候，会依赖并下载 dart-sass， 然后起了个别名叫做 node-sass。偷梁换柱，狸猫换太子了，哈哈。<br>所以的所以呢，如果你在项目中用到 sass 的话建议你尝试一下新方法，说不定更香呢～</p>
]]></content>
      <categories>
        <category>NodeJS</category>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>npm相关资料</title>
    <url>/2017/08/30/npm-source/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近两年前端突然呈爆发增长之势，node的出现起了重要的作用，而node之中有一个重要的功能就是npm包管理工具，下面就记录一下我学习npm之中遇到的一些问题及解决方案，仅供各位参考。</p>
<span id="more"></span>

<blockquote>
<p>npm全称Node Package Manager，是node.js的模块依赖管理工具。由于npm的源在国外，所以国内用户使用起来各种不方便。下面整理出了一部分国内优秀的npm镜像资源，国内用户可以选择使用。</p>
</blockquote>
<h2 id="国内优秀npm镜像"><a href="#国内优秀npm镜像" class="headerlink" title="国内优秀npm镜像"></a>国内优秀npm镜像</h2><h3 id="淘宝npm镜像"><a href="#淘宝npm镜像" class="headerlink" title="淘宝npm镜像"></a>淘宝npm镜像</h3><ul>
<li>搜索地址：<a href="http://npm.taobao.org/">http://npm.taobao.org/</a></li>
<li>registry地址：<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org/</a></li>
</ul>
<h3 id="cnpmjs镜像"><a href="#cnpmjs镜像" class="headerlink" title="cnpmjs镜像"></a>cnpmjs镜像</h3><ul>
<li>搜索地址：<a href="http://cnpmjs.org/">http://cnpmjs.org/</a></li>
<li>registry地址：<a href="http://r.cnpmjs.org/">http://r.cnpmjs.org/</a></li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>有很多方法来配置npm的registry地址，下面根据不同情境列出几种比较常用的方法。以淘宝npm镜像举例：</p>
<h3 id="1-临时使用"><a href="#1-临时使用" class="headerlink" title="1.临时使用"></a>1.临时使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure>
<h3 id="2-持久使用"><a href="#2-持久使用" class="headerlink" title="2.持久使用"></a>2.持久使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置后可通过下面方式来验证是否成功</span><br><span class="line">npm config get registry</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure>
<h3 id="3-通过cnpm使用"><a href="#3-通过cnpm使用" class="headerlink" title="3.通过cnpm使用"></a>3.通过cnpm使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">cnpm install express</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NodeJS</category>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>rnpm</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>path.join 与 path.resolve 的区别</title>
    <url>/2020/03/23/path-join-vs-path-resolve/</url>
    <content><![CDATA[<h1 id="path-join-与-path-resolve-的区别"><a href="#path-join-与-path-resolve-的区别" class="headerlink" title="path.join 与 path.resolve 的区别"></a>path.join 与 path.resolve 的区别</h1><ol>
<li>对于以/开始的路径片段，path.join只是简单的将该路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃，就像是在terminal中使用cd命令一样。 </li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b&#x27;</span>) <span class="comment">// &#x27;a/b&#x27;</span></span><br><span class="line">path.resolve(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b&#x27;</span>) <span class="comment">// &#x27;/b&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>path.resolve总是返回一个以相对于当前的工作目录（working directory）的绝对路径。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.join(<span class="string">&#x27;./a&#x27;</span>, <span class="string">&#x27;./b&#x27;</span>) <span class="comment">// &#x27;a/b&#x27;</span></span><br><span class="line">path.resolve(<span class="string">&#x27;./a&#x27;</span>, <span class="string">&#x27;./b&#x27;</span>) <span class="comment">// &#x27;/Users/username/Projects/webpack-demo/a/b&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>由打印引起的一点小问题，写table时别忘了写thead和tbody</title>
    <url>/2020/02/12/print-table-problem/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天复工，公司一个小伙伴在群里问了一个问题</p>
<blockquote>
<p>如何在打印表格的时候，让超过一页的表格分割线不被截断</p>
</blockquote>
<p>说着他有贴上来了一张图，一张因为跨页被截断了的表格，说实话打印的场景接触的不多，打印表格一般都是制式的样式所以也不会出现这问题，一时间也没有头绪，想着这个是不是没什么办法解决，隔天他发来一个消息，说是解决了，给表格里加上了 <code>tr</code> <code>td</code> 就好了，接着他又发来一张图，还真是，不过上下边距发生了一些变化，我问他是不是自己改了边距所以好了，他说没改，然后我问他那他是怎么解决的，他说因为实在找不到问题解决方案和产生原因，于是就把代码重构了一下，按照标准写法写了一下，结果就好了。。。怎么说呢，也是神奇，我也到网上去查了查相关的材料，并没有特别对的上的原因，凭感觉来说，应该是thead和tbody上有默认的css样式解决了上面的问题，暂且记下这个问题，避免以后遇到又忘了是怎么回事。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端问题</category>
      </categories>
      <tags>
        <tag>奇怪问题</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS 下 RESTful 架构的最佳实践（课堂笔记）</title>
    <url>/2020/02/11/restful-architecture/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="什么是-RESTful"><a href="#什么是-RESTful" class="headerlink" title="什么是 RESTful"></a>什么是 RESTful</h2><blockquote>
<p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。</p>
</blockquote>
<p>实际上就是 url 风格/ 路由风格 ， 给出一种写路由的原则  —  面向资源<br>tip：静态路由利于seo优化 api/news/1，动态路由不利于seo优化 api/news?id=1</p>
<p>原来的风格<br>| 路由 | 功能 | 描述 |<br>| —- | —- |——|<br>| <a href="http://127.0.0.1/user/query/1">http://127.0.0.1/user/query/1</a>     | 查询 | 根据ID查询用户信息 |<br>| <a href="http://127.0.0.1/user/save">http://127.0.0.1/user/save</a>        | 保存 | 注册用户 |<br>| <a href="http://127.0.0.1/user/update">http://127.0.0.1/user/update</a>      | 更新 | 修改用户 |<br>| <a href="http://127.0.0.1/user/delete/%7Bid%7D">http://127.0.0.1/user/delete/{id}</a> | 删除 | 删除用户 |</p>
<p>RESTful — 面向资源：对于同一个资源都在同一个 URL 进行，通过判断 HTTP 请求的类型来决定做不同的事<br>/user 一个资源<br>| 路由                    | 请求类型 |<br>| ———————– | ——– |<br>| <a href="http://127.0.0.1/user/1">http://127.0.0.1/user/1</a> | GET      |<br>| <a href="http://127.0.0.1/user">http://127.0.0.1/user</a>   | POST     |<br>| <a href="http://127.0.0.1/user">http://127.0.0.1/user</a>   | PUT      |<br>| <a href="http://127.0.0.1/user">http://127.0.0.1/user</a>   | DELETE   |</p>
<p>URL 描述资源 ， HTTP 描述请求。（HTTP协议无语义无状态 —- 降低复杂度，业务无关 — 架构代码业务无关)</p>
<p>RESTful 采用的是顶层路由</p>
<blockquote>
<p>顶层路由设计：不需要有物理文件映射路由</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// express</span></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.get(<span class="string">&#x27;/case.avi&#x27;</span>,<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.send(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不需要对应物理文件</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<p>原生接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>); <span class="comment">// mysql</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co-mysql&#x27;</span>) <span class="comment">// 异步同步化</span></span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;md5-node&#x27;</span>) <span class="comment">// md5加密</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="keyword">let</span> db = mysql.createPool(&#123; <span class="comment">// 连接池自己管理 不用关闭</span></span><br><span class="line">	host:<span class="string">&#x27;localhost&#x27;</span>, </span><br><span class="line">	user:<span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">	password:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">	database:<span class="string">&#x27;user&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> conn = co(db)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = http.createServer(<span class="keyword">async</span> (req,res)=&gt;&#123;</span><br><span class="line">	<span class="keyword">if</span>(req.method === <span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(req.url === <span class="string">&#x27;/user&#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">// res.end(JSON.stringify(&#123;&#x27;message&#x27;:&#x27;对user发起post请求&#x27;&#125;))</span></span><br><span class="line">			req.on(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">async</span> (data)=&gt;&#123;</span><br><span class="line">				arr.push(data)</span><br><span class="line">			&#125;)</span><br><span class="line">			req.on(<span class="string">&#x27;end&#x27;</span>,<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">				<span class="keyword">let</span> buffer = Buffer.concat(arr);</span><br><span class="line">				<span class="comment">// json对象</span></span><br><span class="line">				<span class="keyword">let</span> &#123;username,pasword&#125; = <span class="built_in">JSON</span>.parse(buffer.toString())</span><br><span class="line">				<span class="comment">// console.log(username,pasword)</span></span><br><span class="line">				<span class="keyword">let</span> sql = <span class="string">`selct user from admin where user = <span class="subst">$&#123;username&#125;</span>`</span></span><br><span class="line">				<span class="keyword">let</span> data = <span class="keyword">await</span> conn.query(sql);</span><br><span class="line">				<span class="comment">// console.log(data)</span></span><br><span class="line">				<span class="keyword">if</span>(data.length &gt;=<span class="number">1</span> )&#123;</span><br><span class="line">					res.end(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">						<span class="string">&#x27;status&#x27;</span>:<span class="number">200</span>,</span><br><span class="line">						<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;用户名已经注册&#x27;</span></span><br><span class="line">					&#125;))</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="comment">// 写入数据库</span></span><br><span class="line">					password = md5(password);</span><br><span class="line">					<span class="keyword">let</span> sql = <span class="string">`INSERT INTO admin (user,password) VALUES (&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;,&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;)`</span></span><br><span class="line">					<span class="keyword">await</span> conn.query(sql);</span><br><span class="line">					res.end(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">						<span class="string">&#x27;status&#x27;</span>:<span class="number">200</span>,</span><br><span class="line">						<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;注册成功&#x27;</span></span><br><span class="line">					&#125;))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">if</span>(req.method === <span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(req.url === <span class="string">&#x27;/user&#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">// res.end(JSON.stringify(&#123;&#x27;message&#x27;:&#x27;对user发起get请求&#x27;&#125;))</span></span><br><span class="line">			<span class="keyword">let</span> sql = <span class="string">`SELECT id,user,password FROM admin`</span></span><br><span class="line">			<span class="keyword">let</span> data = <span class="keyword">await</span> conn.query(sql);</span><br><span class="line">			res.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .http 文件</span></span><br><span class="line">@url = http:<span class="comment">//localhost:3000</span></span><br><span class="line">@type = Content-Type: applications</span><br><span class="line"></span><br><span class="line">GET &#123;&#123;url&#125;&#125;/user HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">POST &#123;&#123;url&#125;&#125;/user HTTP/<span class="number">1.1</span></span><br><span class="line">&#123;&#123;type&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	username:<span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">	password:<span class="number">123456</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用express实现(express — generater yard ,koa — async await)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>); <span class="comment">// mysql</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co-mysql&#x27;</span>) <span class="comment">// 异步同步化</span></span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;md5-node&#x27;</span>) <span class="comment">// md5加密</span></span><br><span class="line"><span class="keyword">const</span> bodyparse = <span class="built_in">require</span>(<span class="string">&#x27;body-parse&#x27;</span>)</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="keyword">let</span> db = mysql.createPool(&#123;</span><br><span class="line">	host:<span class="string">&#x27;localhost&#x27;</span>, </span><br><span class="line">	user:<span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">	password:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">	database:<span class="string">&#x27;user&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> conn = co(db)</span><br><span class="line"></span><br><span class="line">app.use(bodyparse.urlencoded(&#123;</span><br><span class="line">	extended:<span class="literal">true</span> <span class="comment">// 返回对象是兼职对，false - string/array true - any</span></span><br><span class="line">&#125;))</span><br><span class="line">app.use(bodyparse.json())</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/user&#x27;</span>,<span class="keyword">async</span> (req.res)=&gt;&#123;</span><br><span class="line">	<span class="keyword">let</span> &#123; username , password&#125; = req.body</span><br><span class="line">	<span class="comment">// console.log(username,pasword)</span></span><br><span class="line">	<span class="keyword">let</span> sql = <span class="string">`selct user from admin where user = <span class="subst">$&#123;username&#125;</span>`</span></span><br><span class="line">	<span class="keyword">let</span> data = <span class="keyword">await</span> conn.query(sql);</span><br><span class="line">	<span class="comment">// console.log(data)</span></span><br><span class="line">	<span class="keyword">if</span>(data.length &gt;=<span class="number">1</span> )&#123;</span><br><span class="line">		res.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">			<span class="string">&#x27;status&#x27;</span>:<span class="number">200</span>,</span><br><span class="line">			<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;用户名已经注册&#x27;</span></span><br><span class="line">		&#125;))</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">// 写入数据库</span></span><br><span class="line">		password = md5(password);</span><br><span class="line">		<span class="keyword">let</span> sql = <span class="string">`INSERT INTO admin (user,password) VALUES (&#x27;<span class="subst">$&#123;username&#125;</span>&#x27;,&#x27;<span class="subst">$&#123;password&#125;</span>&#x27;)`</span></span><br><span class="line">		<span class="keyword">await</span> conn.query(sql);</span><br><span class="line">		res.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">			<span class="string">&#x27;status&#x27;</span>:<span class="number">200</span>,</span><br><span class="line">			<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;注册成功&#x27;</span></span><br><span class="line">		&#125;))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/user/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.send(req.params.id)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> sql = <span class="string">`SELECT id,user,password FROM admin WHERE id = <span class="subst">$&#123;req.params.id&#125;</span>`</span></span><br><span class="line">	<span class="keyword">let</span> data = <span class="keyword">await</span> conn.query(sql);</span><br><span class="line">	res.end(<span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>使用koa实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	host:<span class="string">&#x27;localhost&#x27;</span>, </span><br><span class="line">	user:<span class="string">&#x27;root&#x27;</span>, </span><br><span class="line">	password:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">	database:<span class="string">&#x27;user&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libs/database.js</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;../config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>); <span class="comment">// mysql</span></span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co-mysql&#x27;</span>) <span class="comment">// 异步同步化</span></span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="keyword">let</span> db = mysql.createPool(&#123;</span><br><span class="line">	host:config.host, </span><br><span class="line">	user:config.user, </span><br><span class="line">	password:config.password,</span><br><span class="line">	database:config.database</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> conn = co(db)</span><br><span class="line"></span><br><span class="line"><span class="comment">// router/user/index.js</span></span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">&#x27;md5-node&#x27;</span>) <span class="comment">// md5加密</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/user&#x27;</span>,<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">	ctx.body = <span class="string">&#x27;主页&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">router.post(<span class="string">&#x27;/user&#x27;</span>,<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">	<span class="keyword">let</span> &#123;username,password&#125; = ctx.request.body</span><br><span class="line">	<span class="comment">// console.log(username,password)</span></span><br><span class="line">	ctx.body = &#123;</span><br><span class="line">		username,password</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = router.routes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparse&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">&#x27;config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line">app.context.db = <span class="built_in">require</span>(<span class="string">&#x27;./libs/database&#x27;</span>)</span><br><span class="line">app.context.config = config</span><br><span class="line">app.use(body())</span><br><span class="line">router.use(<span class="string">&#x27;/api&#x27;</span>,<span class="built_in">require</span>(<span class="string">&#x27;./router/user&#x27;</span>))</span><br><span class="line">app.use(router.routes())</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>解决get请求过长的问题小记</title>
    <url>/2020/01/09/solve-get-params-so-long-problem/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在前天，公司里一位新入职的前端小伙伴找到我说遇到了一个问题，自己写的vue代码本地运行是好用的，但是打包后提给后台就访问不了接口了，刚开始我以为是代理配置的有问题，但是经过检查也没什么问题，因为是个<code>get</code>方法，所以我就直接在浏览器地址里敲了api地址，也能正常获取到数据，那么这么看就不是代理或者接口的问题，后来我又看了下调试工具，network中根本就没发出请求，我怀疑是直接前台就拦截了，最后我发现他这个api参数超级长，长的相当吓人，可以看一下下图。<br><img src="https://s2.ax1x.com/2020/01/09/lROUMt.png" alt="lROUMt.png"><br>我记得url是有长度限制的，于是我就把url变短再次请求，虽然因为参数不全，接口报了错，但是发出去了，由此我定位应该是url超长，因为vue中配置了什么导致的访问被拦截了。于是我就开始了搜索引擎查找解决方案之旅，接下来就把我了解到的信息一一整理。</p>
<span id="more"></span>

<h2 id="URL-限制"><a href="#URL-限制" class="headerlink" title="URL 限制"></a>URL 限制</h2><p>首先我在网上找到了一份资料介绍了URL长度的相关资料，从下面可以看出，从HTTP协议层面以及Get请求层面都没有什么限制，这个限制来自于<em><strong>浏览器或者服务器的限制</strong></em>。</p>
<blockquote>
<p>Microsoft Internet Explorer (Browser)<br>IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。<br>Firefox (Browser)<br>对于Firefox浏览器URL的长度限制为65,536个字符。<br>Safari (Browser)<br>URL最大长度限制为 80,000个字符。<br>Opera (Browser)<br>URL最大长度限制为190,000个字符。<br>Google (Browser)<br>URL最大长度限制为8182个字符。<br>Apache (Server)<br>能接受最大url长度为8,192个字符。<br>Microsoft Internet Information Server(IIS)<br>能接受最大url的长度为16,384个字符。</p>
</blockquote>
<p>而且，中文会进行编码，一个汉字编码后会生成9个字符，这样算来，IE下最多也就能输入231个中文，再多就完蛋了，那么通过get请求传递参数就会显得很麻烦。</p>
<p>通常情况下，这种超长参数的请求我们都会用post，有些地方也会说post请求没有长度限制，但是前面说了，实际上HTTP协议层面并没有任何的限制，限制只出现在浏览器或者服务器限制，get和post请求在底层上其实是一样的。</p>
<p>最后项目修改了请求类型，把 <code>get</code> 请求改成了 <code>post</code> 请求，在网上实际还找到了另外两个方案，如果对同一组参数频繁访问的化，也可以用 <code>post+get</code> 请求的方式去处理，或者用 <code>sessionStorage</code> 下面简单介绍一下。</p>
<ol>
<li>将预览内容 <code>post</code> 到服务端，根据一个唯一标识生成缓存(有效时间5分钟)，将唯一标识返回到前端，前端通过get方式传递唯一标识请求预览逻辑，拿到缓存的内容后渲染到页面。需要说明的是这里的缓存必须是分布式的。</li>
<li>通过H5的会话缓存 <code>sessionStorage</code> 将预览内容存储在浏览器，打开预览页后从 <code>sessionStorage</code> 中拿到内容就可以渲染出页面了。</li>
</ol>
<p>上述两种方案都不太符合我们的项目所以最终还是选择了最简单的方式</p>
<h2 id="GET-VS-POST"><a href="#GET-VS-POST" class="headerlink" title="GET VS POST"></a>GET VS POST</h2><ol>
<li><p>多数浏览器对于POST采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于GET），也就是第一步发送header数据，第二步再发送body部分。HTTP是应用层的协议，而在传输层有些情况TCP会出现两次连结的过程，HTTP协议本身不保存状态信息，一次请求一次响应。对于TCP而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用GET请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。</p>
</li>
<li><p>GET请求能够被cache，GET请求能够被保存在浏览器的浏览历史里面（密码等重要数据GET提交，别人查看历史记录，就可以直接看到这些私密数据）POST不进行缓存。</p>
</li>
<li><p>GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同。POST请求无长度限制（目前理论上是这样的）。</p>
</li>
<li><p>GET提交的数据大小，不同浏览器的限制不同，一般在2k-8K之间，POST提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。</p>
</li>
<li><p>全部用POST不是十分合理，最好先把请求按功能和场景分下类，对数据请求频繁，数据不敏感且数据量在普通浏览器最小限定的2k范围内，这样的情况使用GET。其他地方使用POST。</p>
</li>
<li><p>GET 的本质是「得」，而 POST 的本质是「给」。而且，GET 是「幂等」的，在这一点上，GET 被认为是「安全的」。但实际上 server 端也可以用作资源更新，但是这种用法违反了约定，容易造成 CSRF（跨站请求伪造）。</p>
</li>
</ol>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>以上是这次遇到问题后学到的一点知识，可能并不全面，后续如果遇到了类似的问题会继续丰富这篇文章。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端问题</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>get</tag>
      </tags>
  </entry>
  <entry>
    <title>给博客添加基于github-issue的评论系统</title>
    <url>/2017/10/12/us-gitment/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章介绍了<a href="https://lixuguang.github.io/2017/10/11/use-GitHub-Hexo-Next-make-blog/">如何利用github+hexo+next制作一个博客系统</a>，但是由于这个博客系统是基于静态页面的，所以无法完成评论功能，博客怎么可以没有评论功能呢，当然next主题提供了几个选项，但是国内你知道的，提供的几个评论功能都不是太好用，于是就上网找了好多资料，功夫不负有心人，让我找到了一个名曰gitment的基于github-issue的评论插件，下面就介绍大家如何使用这个插件。</p>
<a id="more"></a>
<h2 id="第一步-注册一个小程序（OAuth-Application）"><a href="#第一步-注册一个小程序（OAuth-Application）" class="headerlink" title="第一步 注册一个小程序（OAuth Application）"></a>第一步 注册一个小程序（OAuth Application）</h2><p>点击<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a>注册</p>
<ul>
<li>Application name 应用名称 这里随便写，我写的就是gitment</li>
<li>Homepage URL 主页地址，你可以写你的博客地址，我写的是<a href="https://lixuguang.github.io/">https://lixuguang.github.io/</a></li>
<li>Application description 应用描述，这里随便写点什么，反正是自己用。</li>
<li>Authorization callback URL 这个比较重要，请填写你的博客地址，我的是<a href="https://lixuguang.github.io/">https://lixuguang.github.io/</a></li>
</ul>
<p>点击确定以后你会获得两个关键信息，下一步配置时会用到</p>
<ul>
<li>Client ID</li>
<li>Client Secret</li>
</ul>
<h2 id="第二步-修改主题配置文件，添加gitment评论功能"><a href="#第二步-修改主题配置文件，添加gitment评论功能" class="headerlink" title="第二步 修改主题配置文件，添加gitment评论功能"></a>第二步 修改主题配置文件，添加gitment评论功能</h2><p>因为用的是next主题，所以配置文件地址如下：<br><strong>themes/next/_config.yml</strong></p>
<h3 id="1、在其中添加"><a href="#1、在其中添加" class="headerlink" title="1、在其中添加:"></a>1、在其中添加:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https:&#x2F;&#x2F;imsun.net&#x2F;posts&#x2F;gitment-introduction&#x2F;</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: yourid &#x2F;&#x2F; 我的是lixuguang</span><br><span class="line">  repo: yourrepo &#x2F;&#x2F; 我的是lixuguang.github.io 必须跟githubID保持一致的用户名</span><br><span class="line">  ClientID: yourid &#x2F;&#x2F; 上面开通程序获得的ClientID</span><br><span class="line">  ClientSecret: yoursecret &#x2F;&#x2F; 上面开通程序获得的Client Secret</span><br><span class="line">  lazy: false &#x2F;&#x2F;是否需要点击展开评论才能可见评论，一般设置为false</span><br></pre></td></tr></table></figure>
<p><strong>一定要注意空格，不然会报错的，别问我咋知道的</strong></p>
<h3 id="2、然后在主题的配置语言环境的文件添加一句话"><a href="#2、然后在主题的配置语言环境的文件添加一句话" class="headerlink" title="2、然后在主题的配置语言环境的文件添加一句话"></a>2、然后在主题的配置语言环境的文件添加一句话</h3><p><code>en.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: Show comments from Gitment</span><br></pre></td></tr></table></figure>

<p><code>zh-Hans.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: 显示 Gitment 评论</span><br></pre></td></tr></table></figure>
<p>如果是中文网站英文配置也可以不用写。</p>
<h3 id="3、添加新的Dom结构"><a href="#3、添加新的Dom结构" class="headerlink" title="3、添加新的Dom结构"></a>3、添加新的Dom结构</h3><p><strong>修改主题layout/_partials/comments.swig</strong><br>在最后一个elseif分支后添加一个elseif分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">       &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">         &lt;div onclick&#x3D;&quot;ShowGitment()&quot; id&#x3D;&quot;gitment-display-button&quot;&gt;&#123;&#123;  __(&#39;gitmentbutton&#39;) &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">         &lt;div id&#x3D;&quot;gitment-container&quot; style&#x3D;&quot;display:none&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">       &#123;% else %&#125;</span><br><span class="line">         &lt;div id&#x3D;&quot;gitment-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">       &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、-在主题下layout-third-party-comments-目录下中添加文件gitment-swig"><a href="#4、-在主题下layout-third-party-comments-目录下中添加文件gitment-swig" class="headerlink" title="4、 在主题下layout/_third-party/comments/目录下中添加文件gitment.swig"></a>4、 在主题下layout/_third-party/comments/目录下中添加文件gitment.swig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% set owner &#x3D; theme.gitment.githubID %&#125;</span><br><span class="line">   &#123;% set repo &#x3D; theme.gitment.repo %&#125;</span><br><span class="line">   &#123;% set cid &#x3D; theme.gitment.ClientID %&#125;</span><br><span class="line">   &#123;% set cs &#x3D; theme.gitment.ClientSecret %&#125;</span><br><span class="line">   &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;imsun.github.io&#x2F;gitment&#x2F;style&#x2F;default.css&quot;&gt;</span><br><span class="line">   &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;imsun.github.io&#x2F;gitment&#x2F;dist&#x2F;gitment.browser.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">       &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">           var gitment &#x3D; new Gitment(&#123;</span><br><span class="line">               id: window.location.pathname, </span><br><span class="line">               owner: &#39;&#123;&#123;owner&#125;&#125;&#39;,</span><br><span class="line">               repo: &#39;&#123;&#123;repo&#125;&#125;&#39;,</span><br><span class="line">               oauth: &#123;</span><br><span class="line">                   client_id: &#39;&#123;&#123;cid&#125;&#125;&#39;,</span><br><span class="line">                   client_secret: &#39;&#123;&#123;cs&#125;&#125;&#39;,</span><br><span class="line">               &#125;&#125;);</span><br><span class="line">           gitment.render(&#39;gitment-container&#39;);</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">       &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">           function ShowGitment()&#123;</span><br><span class="line">               document.getElementById(&quot;gitment-display-button&quot;).style.display &#x3D; &quot;none&quot;;</span><br><span class="line">               document.getElementById(&quot;gitment-container&quot;).style.display &#x3D; &quot;block&quot;;</span><br><span class="line">               var gitment &#x3D; new Gitment(&#123;</span><br><span class="line">                   id: document.location.href, </span><br><span class="line">                   owner: &#39;&#123;&#123;owner&#125;&#125;&#39;,</span><br><span class="line">                   repo: &#39;&#123;&#123;repo&#125;&#125;&#39;,</span><br><span class="line">                   oauth: &#123;</span><br><span class="line">                       client_id: &#39;&#123;&#123;cid&#125;&#125;&#39;,</span><br><span class="line">                       client_secret: &#39;&#123;&#123;cs&#125;&#125;&#39;,</span><br><span class="line">                   &#125;&#125;);</span><br><span class="line">               gitment.render(&#39;gitment-container&#39;);</span><br><span class="line">           &#125;</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下layout/_third-party/comments/index.swig文件中引入gitment.swig文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;gitment.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在主题下source-css-common-components-third-party-目录下添加gitment-styl文件"><a href="#在主题下source-css-common-components-third-party-目录下添加gitment-styl文件" class="headerlink" title="在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件"></a>在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件</h3><p>此配置文件为gitment的样式文件，需要修改样式可以在这里进行书写，这里修改一下按钮样式，另外将聊天框于文章框样式统一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gitment-display-button&#123;</span><br><span class="line">     display: inline-block;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     color: #0a9caf;</span><br><span class="line">     cursor: pointer;</span><br><span class="line">     font-size: 14px;</span><br><span class="line">     border: 1px solid #0a9caf;</span><br><span class="line">     border-radius: 4px;</span><br><span class="line"> &#125;</span><br><span class="line"> #gitment-display-button:hover&#123;</span><br><span class="line">     color: #fff;</span><br><span class="line">     background: #0a9caf;</span><br><span class="line"> &#125;</span><br><span class="line">  #comments &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 40px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitment&quot;;</span><br></pre></td></tr></table></figure>
<p>经过以上操作，gitment就被引入到你的博客里了。</p>
<p>现在就可以让大家对你写的文章进行评论啦，怎么样是不是又学到啦，喜欢我的文章就请关注我的github吧。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端全栈和大前端有啥区别</title>
    <url>/2020/04/15/talk-about-full-stack-big-fd/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>知乎真是个好地方，关注好自己喜欢的话题，经常会推送一些好的话题到你面前，这不刚刚就看到了一个人提问</p>
<blockquote>
<p>前端全栈和大前端有啥区别</p>
</blockquote>
<p>以前只听说过全栈，听说过大前端，但是没听说过前端全栈，对于前两个我自己也有一些理解，但从不敢说自己理解的对，带着强烈的好奇心我打开了这个问题，也看到了一位前端大神‘狼叔’的回复，感觉还是很到位的，也让我重新验证了自己的理解，所以就将狼叔的解答与我自己的认识相结合一下，做个记录。</p>
<a id="more"></a>

<h2 id="狼叔说"><a href="#狼叔说" class="headerlink" title="狼叔说"></a>狼叔说</h2><p>狼叔在解答这个疑问之前直接上了一张图，图我贴在下面供大家看一下<br><img src="https://s1.ax1x.com/2020/04/15/JicTqe.jpg" alt="JicTqe.jpg"><br>这么一张图实际上已经胜过千言了，但是为了方便大家理解，狼叔还是在下面对图进行了解释</p>
<blockquote>
<p>前端全栈：分node全栈和其他语言全栈，比如ror搞全栈是最早的，其他php、java也有，不过纯前端的不过，在react，angular之前搞后台还是可以的。<br>所以前端全栈，我理解是等同于node全栈的。node本身是做后端的，但在前端工程化和BFF领域大放异彩，所以node全栈涵盖了前端的方方面面，是比较合理的解释。<br>大前端：更泛化的概念，移动互联网时代开启后，hybrid曾经很火，基于h5和webview做跨端，确实是很理想的做法，但复杂交互搞不定，机器性能网络等是硬伤，所以后来出现了rn和weex，整体还是前端写法，所以hybrid里前端也是占了一定的开发，结合之前前端和node的关系，综合3者：1）app里的前端，2）前端，2）node全栈，统称为大前端。这里的”大“含义是可以做的事儿的范围更广，触达前后端移动端，对前端职责有明显提升。随着技术发展，基于electron的桌面开发也日进流程，ott和iot等领域采用js也愈来愈多，所以只要和用户直接触达的端采用了前端技术开发的都涵盖在大前端范畴内。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/379563850/answer/1152553428" target="_blank" rel="noopener">原帖地址</a></p>
<h2 id="我说"><a href="#我说" class="headerlink" title="我说"></a>我说</h2><p>之前我的概念里前端扩展开来再进一步的话分两个方向，一个叫全栈另一个叫全端，‘栈’的话是纵向的，简单理解的话就是一款产品一个人能从设计到前端实现后端实现运维等一个人搞定，那么他就可以称之为全栈，狭义一点理解，就是前端后端都会，那么这里所说的前端全栈，我理解是更方便前端掌握的一些后端技能如node、php、ror等，而不是java这种后端技能，所以叫前端全栈，我想这里大部分指的都是node作为后端；</p>
<p>那么我理解的全端是什么呢</p>
<p>‘端’我理解为容器，任何跟用户直接接触的技术都是端的技术，早期的pc端，后来的手机端，手机端里又出现了h5、hybrid、native这么几种，后来又出现了小程序之类的容器，pc端也出现了如electron等客户端技术，那么随着物联网智能家居的出现，更多的端出现了，就如狼叔说的OTT和IOT领域也成了端，大前端的大是指范围广，属于用户直达所承载内容容器的都是端。</p>
<p>总的来说跟狼叔的理解一致，我个人也努力在往全栈全端发展，不过真的好难还有很长的路要走。</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用GitHub-Hexo-Next搭建一个漂亮的技术博客</title>
    <url>/2017/10/11/use-GitHub-Hexo-Next-make-blog/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>开博客貌似并不是一件难事，现在有很多的方式开博客，而且现在博客貌似也不再流行，但是作为一个开发者，维护一个技术博客对自己的发展是很有好处的，出名者如阮一峰等，所以还是想要做一个技术博客的。</p>
</blockquote>
<blockquote>
<p>开博客可以选择网上现有的博客系统如博客园以及其他各大公司提供的博客系统，也可以选择如wordpress等博客程序自行搭建博客系统，前者省事，但可自定义设置不足不符合一个爱折腾的人的性格，后者复杂些，爱折腾的可以学着搭建，但是服务器域名是个让人头疼的事，还有数据库等操作，着实麻烦，如今又有了另外一个选择，那就是利用GitHub和一些静态的博客系统搭建一个纯静态的博客系统，不花钱又能折腾，而且还是命令行下的，装B感觉棒棒的，另外搭配时下流行的MarkDown语法，做笔记正合我意。</p>
</blockquote>
<span id="more"></span>

<h2 id="技术栈选型"><a href="#技术栈选型" class="headerlink" title="技术栈选型"></a>技术栈选型</h2><blockquote>
<p>这里说是技术栈选型可能并不是很恰当，但又找不到合适的描述，就是把需要的技术介绍一下，如果还不会的，可以自行学习，或者看看我的其他文章。</p>
</blockquote>
<ul>
<li>node（npm），现在node这么火，没用过都不好意思出门，但是如果你还不回的话，就先自行学习安装一下吧。</li>
<li>Hexo 静态博客程序，其实还有很多，只不过这个比较新，而且搭配Next非常漂亮，就选了它。</li>
<li>Next 可以说是Hexo的定制系统，不仅仅是做了个皮肤，简洁美观的配置项和官网说明深得我心。</li>
</ul>
<h2 id="搭建步骤（安装步骤）"><a href="#搭建步骤（安装步骤）" class="headerlink" title="搭建步骤（安装步骤）"></a>搭建步骤（安装步骤）</h2><h3 id="安装Hexo-Hexo官网"><a href="#安装Hexo-Hexo官网" class="headerlink" title="安装Hexo Hexo官网"></a>安装Hexo <a href="https://hexo.io/">Hexo官网</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g &#x2F;&#x2F; 安装hexo的脚手架工具</span><br><span class="line">$ hexo init blog &#x2F;&#x2F; 初始化博客</span><br><span class="line">$ cd blog &#x2F;&#x2F; 返回博客目录</span><br><span class="line">$ npm install &#x2F;&#x2F; 安装依赖</span><br><span class="line">$ hexo server &#x2F;&#x2F; 启动博客</span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么样五行代码就生成并运行了一个博客是不是超简单。<br>下面我们看一下生成的博客的目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code>这是博客的配置文件，比如博客名称，副标题，作者等信息都在这个文件里设置。</p>
<p><code>package.json</code>这是博客的依赖文件可以忽略</p>
<p><code>scaffolds</code>这是博客的模板目录，当你要写一篇文章时，这里会有文章的默认类型。</p>
<p><code>source</code>这是博客的网站资源，包括发布的文章（<code>_posts</code>）、关于、分类还有上传文件等。</p>
<p><code>themes</code>这是博客的皮肤。</p>
<p>更多配置信息请查阅官网手册</p>
<h3 id="安装Next主题-Next官网"><a href="#安装Next主题-Next官网" class="headerlink" title="安装Next主题 Next官网"></a>安装Next主题 <a href="http://theme-next.iissnan.com/">Next官网</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>然后到<code>_config.yml</code>配置文件将主题配置改成next就可以使用next的皮肤了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>皮肤也有配置文件，为跟Hexo进行区分Hexo的配置文件称为<code>站点配置文件</code>， 皮肤配置文件称为<code>主题配置文件</code>。</p>
<p>对两个配置文件进行简单配置后，符合需求的博客就搭建而成了，这里有个友好的建议，配置文件如果配置不正确将不能正确运行博客，所以在配置前务必保留好原始配置文件，注意配置时不要缺了空格，不要问我为什么知道这个。</p>
<h3 id="更新博客主题"><a href="#更新博客主题" class="headerlink" title="更新博客主题"></a>更新博客主题</h3><p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md</a></p>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>博客已经搭建好了，接下来就是写博客了，那么如何开始写博客呢，超级简单一行命令足以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;  </span><br><span class="line">&#x2F;&#x2F; layout 为模板类型可以省略，title为文章标题，通常可以简写为如下</span><br><span class="line">hexo new title</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新建命令执行后在<code>_posts</code>的目录下就会生成一个你刚才命名的md后缀的文件，这就是一个MarkDown语法的文件，（如果不了解MarkDown语法的可以去学一下，很简单的符号语言，或者像我一样用支持MarkDown语法的编辑器来写文章。新建的文章打开内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: new-post</span><br><span class="line">date: 2017-10-11 15:01:09</span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非常好理解，title就是标题，date为创建时间，tags是标签方便分类，但是这些并不全，还有些常用的分类没有写上，下面我将常用的进行补充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: new-post</span><br><span class="line">date: 2017-10-11 15:01:09</span><br><span class="line">categories: </span><br><span class="line">	- NodeJS</span><br><span class="line">	- npm</span><br><span class="line">tags:</span><br><span class="line">	- npm</span><br><span class="line">	- NodeJS</span><br><span class="line">	- rnpm</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样补充后就有了常见博客的分类和标签的功能，是不是很简单。</p>
<p>写完文章以后还要执行下面命令，生成静态页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate &#x2F;&#x2F; 将md后缀文件生成成静态html文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样我们就完成了博客的搭建和博客的书写，到现在我们就已经有了一个本地的博客，那么如何将博客上传到GitHub上呢？</p>
<h2 id="将Blog上传至GitHub"><a href="#将Blog上传至GitHub" class="headerlink" title="将Blog上传至GitHub"></a>将Blog上传至GitHub</h2><p>github是一个代码托管的平台，为了方便描述代码功能，它提供了README.md文件进行说明，但是为了更好的展现，也提供了gitpage的功能，博客是基于这个功能进行的扩展，那么如何用gitpage的功能来实现博客系统呢？</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个以你的GitHub账号为开头命名的仓库，格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitHub账号名称.github.io</span><br><span class="line">&#x2F;&#x2F; 如</span><br><span class="line">lixuguang.github.io</span><br></pre></td></tr></table></figure>
<p>然后到blog系统的配置文件<code>_config.yml</code>里配置一下上传路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 我的实例</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lixuguang&#x2F;lixuguang.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置好就可以进行部署了，部署也很简单，只需要执行一下下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save &#x2F;&#x2F; 安装上传工具</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>稍等一会，如果没有出现什么错误信息，那么你的部署就成功了。之后你就可以访问你的博客了，博客地址如下：<br>https://你的github账号.github.io/<br>我的如下：<br><a href="https://lixuguang.github.io/">https://lixuguang.github.io/</a></p>
<p>现在你是不是已经学会如何利用github搭建一个静态的博客系统了呢，如果你还没有一个自己的技术博客，快来试试吧。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>是不是觉得命令行还是挺麻烦的，要敲那么一大串字母，哈哈实际上这些常用命令是有缩写方式的，下面给大家介绍一下缩写方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo s</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo d</span><br><span class="line"></span><br><span class="line">$ hexo new</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo n</span><br></pre></td></tr></table></figure>

<p>另外每次发布之前最好执行以下命令，清理当前内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以防出现冲突的情况，具体动作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d &#x2F;&#x2F; 文件生成后立即部署网站</span><br><span class="line">$ hexo d -g &#x2F;&#x2F; 部署之前预先生成静态文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>SSH问题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;lixuguang316@gmail.com&quot;</span><br><span class="line">&#x2F;&#x2F; 填写你自己的github邮箱</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>敲三下回车，之后会在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\.ssh &#x2F;&#x2F; windows下</span><br><span class="line">open ~&#x2F;.ssh &#x2F;&#x2F; Mac下打开ssh文件  </span><br></pre></td></tr></table></figure>
<p>文件夹下生成两个文件<code>id_rsa</code>（私钥）、<code>id_rsa.pub</code>（公钥），在github上的SSH处添加新的ssh，然后将<code>公钥</code>内容贴到上面起个名字可以叫hexo，保存，然后在git bash下敲击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh git@github.com</span><br></pre></td></tr></table></figure>
<p>然后敲<code>yes</code>就可以上传blog代码了<br>怎么样会了么？更多高阶玩法请阅读官方说明文档，文章如有谬误之处请各位指出，如果觉得文章对你有所帮助我将十分开心，如果你喜欢我的文章可以到我的github上点个<code>fork</code>，谢谢你的阅读。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>博客技巧</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>React 源码剖析系列 － 不可思议的 react diff【转载】</title>
    <url>/2020/04/03/source-code-react-diff/</url>
    <content><![CDATA[<p>目前，前端领域中 React 势头正盛，使用者众多却少有能够深入剖析内部实现机制和原理。本系列文章希望通过剖析 React 源码，理解其内部的实现原理，知其然更要知其所以然。</p>
<p>React diff 作为 Virtual DOM 的加速器，其算法上的改进优化是 React 整个界面渲染的基础，以及性能提高的保障，同时也是 React 源码中最神秘、最不可思议的部分，本文从源码入手，深入剖析 React diff 的不可思议之处。</p>
<p>阅读本文需要对 React 有一定的了解，如果你不知何为 React，请详读 <a href="http://facebook.github.io/react/docs/getting-started.html">React 官方文档</a>。<br>如果你对 React diff 存在些许疑惑，或者你对算法优化感兴趣，那么本文值得阅读和讨论。</p>
<span id="more"></span>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。</p>
<p><em><strong>行文至此，可能会有读者质疑：React 无非就是引入 diff 这一概念，且 diff 算法也并非其首创，何必吹嘘的如此天花乱坠呢？</strong></em></p>
<p>其实，正是因为 diff 算法的普识度高，就更应该认可 React 针对 diff 算法优化所做的努力与贡献，更能体现 React 开发者们的魅力与智慧！</p>
<h2 id="传统-diff-算法"><a href="#传统-diff-算法" class="headerlink" title="传统 diff 算法"></a>传统 diff 算法</h2><p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。<a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">传统 diff 算法</a>通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！现今的 CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p>
<p>如果 React 只是单纯的引入 diff 算法而没有任何的优化改进，那么其效率是远远无法满足前端渲染所要求的性能。</p>
<p>因此，想要将 diff 思想引入 Virtual DOM，就需要设计一种稳定高效的 diff 算法，而 React 做到了！</p>
<p>那么，React diff 到底是如何实现的呢？</p>
<h2 id="详解-React-diff"><a href="#详解-React-diff" class="headerlink" title="详解 React diff"></a>详解 React diff</h2><p>传统 diff 算法的复杂度为 O(n^3)，显然这是无法满足性能要求的。<em><strong>React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。</strong></em></p>
<h3 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h3><ol>
<li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li>
<li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li>
</ol>
<p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。</p>
<ul>
<li>tree diff</li>
<li>component diff</li>
<li>element diff</li>
</ul>
<blockquote>
<p>本文中源码 <a href="https://github.com/facebook/react/blob/master/src/renderers/shared/reconciler/ReactMultiChild.js">ReactMultiChild.js</a></p>
</blockquote>
<h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。</p>
<p>既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p>
<p><img src="https://pic1.zhimg.com/0c08dbb6b1e0745780de4d208ad51d34_r.jpg" alt="https://pic1.zhimg.com/0c08dbb6b1e0745780de4d208ad51d34_r.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateChildren: <span class="function"><span class="keyword">function</span>(<span class="params">nextNestedChildrenElements, transaction, context</span>) </span>&#123;</span><br><span class="line">  updateDepth++;</span><br><span class="line">  <span class="keyword">var</span> errorThrown = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._updateChildren(nextNestedChildrenElements, transaction, context);</span><br><span class="line">    errorThrown = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    updateDepth--;</span><br><span class="line">    <span class="keyword">if</span> (!updateDepth) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">        clearQueue();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processQueue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析至此，<em><strong>大部分人可能都存在这样的疑问：如果出现了 DOM 节点跨层级的移动操作，React diff 会有怎样的表现呢？</strong></em>是的，对此我也好奇不已，不如试验一番。</p>
<p>如下图，A 节点（包括其子节点）整个被移动到 D 节点下，由于 React 只会简单的考虑同层级节点的位置变换，而对于不同层级的节点，只有创建和删除操作。当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：<em><strong>create A -&gt; create B -&gt; create C -&gt; delete A</strong></em>。</p>
<p>由此可发现，当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，<em><strong>因此 React 官方建议不要进行 DOM 节点跨层级的操作</strong></em>。</p>
<blockquote>
<p>注意：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/d712a73769688afe1ef1a055391d99ed_r.jpg" alt="https://pic2.zhimg.com/d712a73769688afe1ef1a055391d99ed_r.jpg"></p>
<h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>React 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。</p>
<ul>
<li>如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</li>
<li>如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。</li>
<li>对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。</li>
</ul>
<p>如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。</p>
<p><img src="https://pic1.zhimg.com/52654992aba15fc90e2dac8b2387d0c4_r.jpg" alt="https://pic1.zhimg.com/52654992aba15fc90e2dac8b2387d0c4_r.jpg"></p>
<h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别为：<em><strong>INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）</strong></em>。</p>
<ul>
<li><p><em><strong>INSERT_MARKUP</strong></em> ，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</p>
</li>
<li><p><em><strong>MOVE_EXISTING</strong></em> ，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。</p>
</li>
<li><p><em><strong>REMOVE_NODE</strong></em> ，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueInsertMarkup</span>(<span class="params">parentInst, markup, toIndex</span>) </span>&#123;</span><br><span class="line">  updateQueue.push(&#123;</span><br><span class="line">    parentInst: parentInst,</span><br><span class="line">    parentNode: <span class="literal">null</span>,</span><br><span class="line">    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,</span><br><span class="line">    markupIndex: markupQueue.push(markup) - <span class="number">1</span>,</span><br><span class="line">    content: <span class="literal">null</span>,</span><br><span class="line">    fromIndex: <span class="literal">null</span>,</span><br><span class="line">    toIndex: toIndex,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueMove</span>(<span class="params">parentInst, fromIndex, toIndex</span>) </span>&#123;</span><br><span class="line">  updateQueue.push(&#123;</span><br><span class="line">    parentInst: parentInst,</span><br><span class="line">    parentNode: <span class="literal">null</span>,</span><br><span class="line">    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,</span><br><span class="line">    markupIndex: <span class="literal">null</span>,</span><br><span class="line">    content: <span class="literal">null</span>,</span><br><span class="line">    fromIndex: fromIndex,</span><br><span class="line">    toIndex: toIndex,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueRemove</span>(<span class="params">parentInst, fromIndex</span>) </span>&#123;</span><br><span class="line">  updateQueue.push(&#123;</span><br><span class="line">    parentInst: parentInst,</span><br><span class="line">    parentNode: <span class="literal">null</span>,</span><br><span class="line">    type: ReactMultiChildUpdateTypes.REMOVE_NODE,</span><br><span class="line">    markupIndex: <span class="literal">null</span>,</span><br><span class="line">    content: <span class="literal">null</span>,</span><br><span class="line">    fromIndex: fromIndex,</span><br><span class="line">    toIndex: <span class="literal">null</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C，此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。</p>
<p><img src="https://pic2.zhimg.com/7541670c089b84c59b84e9438e92a8e9_r.jpg" alt="https://pic2.zhimg.com/7541670c089b84c59b84e9438e92a8e9_r.jpg"></p>
<p>React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。</p>
<p>针对这一现象，React 提出优化策略：允许开发者对同一层级的同组子节点，添加唯一 key 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化！</p>
<p>新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。</p>
<p><img src="https://pic4.zhimg.com/c0aa97d996de5e7f1069e97ca3accfeb_r.jpg" alt="https://pic4.zhimg.com/c0aa97d996de5e7f1069e97ca3accfeb_r.jpg"></p>
<p>那么，如此高效的 diff 到底是如何运作的呢？让我们通过源码进行详细分析。</p>
<p>首先对新集合的节点进行循环遍历，for (name in nextChildren)，通过唯一 key 可以判断新老集合中是否存在相同的节点，if (prevChild === nextChild)，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与 lastIndex 进行比较，if (child._mountIndex &lt; lastIndex)，则进行节点移动操作，否则不执行该操作。这是一种顺序优化手段，lastIndex 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置），如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点比 lastIndex 小时，才需要进行移动操作。</p>
<p>以上图为例，可以更为清晰直观的描述 diff 的差异对比过程：</p>
<ul>
<li><p>从新集合中取得 B，判断老集合中存在相同节点 B，通过对比节点位置判断是否进行移动操作，B 在老集合中的位置 B._mountIndex = 1，此时 lastIndex = 0，不满足 child._mountIndex &lt; lastIndex 的条件，因此不对 B 进行移动操作；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，其中 prevChild._mountIndex 表示 B 在老集合中的位置，则 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置prevChild._mountIndex = nextIndex，此时新集合中 B._mountIndex = 0，nextIndex++ 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 A，判断老集合中存在相同节点 A，通过对比节点位置判断是否进行移动操作，A 在老集合中的位置 A._mountIndex = 0，此时 lastIndex = 1，满足 child._mountIndex &lt; lastIndex的条件，因此对 A 进行移动操作enqueueMove(this, child._mountIndex, toIndex)，其中 toIndex 其实就是 nextIndex，表示 A 需要移动到的位置；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 1，并将 A 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中A._mountIndex = 1，nextIndex++ 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 D，判断老集合中存在相同节点 D，通过对比节点位置判断是否进行移动操作，D 在老集合中的位置 D._mountIndex = 3，此时 lastIndex = 1，不满足 child._mountIndex &lt; lastIndex的条件，因此不对 D 进行移动操作；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 3，并将 D 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中D._mountIndex = 2，nextIndex++ 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 C，判断老集合中存在相同节点 C，通过对比节点位置判断是否进行移动操作，C 在老集合中的位置 C._mountIndex = 2，此时 lastIndex = 3，满足 child._mountIndex &lt; lastIndex 的条件，因此对 C 进行移动操作 enqueueMove(this, child._mountIndex, toIndex)；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 3，并将 C 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中 C._mountIndex = 3，nextIndex++ 进入下一个节点的判断，由于 C 已经是最后一个节点，因此 diff 到此完成。</p>
</li>
</ul>
<p>以上主要分析新老集合中存在相同节点但位置不同时，对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？</p>
<p>以下图为例：</p>
<ul>
<li><p>从新集合中取得 B，判断老集合中存在相同节点 B，由于 B 在老集合中的位置 B._mountIndex = 1，此时lastIndex = 0，因此不对 B 进行移动操作；更新 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置B._mountIndex = 0，nextIndex++进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 E，判断老集合中不存在相同节点 E，则创建新节点 E；更新 lastIndex ＝ 1，并将 E 的位置更新为新集合中的位置，nextIndex++进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 C，判断老集合中存在相同节点 C，由于 C 在老集合中的位置C._mountIndex = 2，lastIndex = 1，此时 C._mountIndex &gt; lastIndex，因此不对 C 进行移动操作；更新 lastIndex ＝ 2，并将 C 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。</p>
</li>
<li><p>从新集合中取得 A，判断老集合中存在相同节点 A，由于 A 在老集合中的位置A._mountIndex = 0，lastIndex = 2，此时 A._mountIndex &lt; lastIndex，因此对 A 进行移动操作；更新 lastIndex ＝ 2，并将 A 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。</p>
</li>
<li><p>当完成新集合中所有节点 diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 D，因此删除节点 D，到此 diff 全部完成。</p>
</li>
</ul>
<p><img src="https://pic1.zhimg.com/7b9beae0cf0a5bc8c2e82d00c43d1c90_r.jpg" alt="https://pic1.zhimg.com/7b9beae0cf0a5bc8c2e82d00c43d1c90_r.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_updateChildren: <span class="function"><span class="keyword">function</span>(<span class="params">nextNestedChildrenElements, transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevChildren = <span class="built_in">this</span>._renderedChildren;</span><br><span class="line">  <span class="keyword">var</span> nextChildren = <span class="built_in">this</span>._reconcilerUpdateChildren(</span><br><span class="line">    prevChildren, nextNestedChildrenElements, transaction, context</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">var</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">    <span class="keyword">var</span> nextChild = nextChildren[name];</span><br><span class="line">    <span class="keyword">if</span> (prevChild === nextChild) &#123;</span><br><span class="line">      <span class="comment">// 移动节点</span></span><br><span class="line">      <span class="built_in">this</span>.moveChild(prevChild, nextIndex, lastIndex);</span><br><span class="line">      lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">      prevChild._mountIndex = nextIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">        lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="built_in">this</span>._unmountChild(prevChild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 初始化并创建节点</span></span><br><span class="line">      <span class="built_in">this</span>._mountChildAtIndex(</span><br><span class="line">        nextChild, nextIndex, transaction, context</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    nextIndex++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevChildren.hasOwnProperty(name) &amp;&amp;</span><br><span class="line">        !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123;</span><br><span class="line">      <span class="built_in">this</span>._unmountChild(prevChildren[name]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._renderedChildren = nextChildren;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 移动节点</span></span><br><span class="line">moveChild: <span class="function"><span class="keyword">function</span>(<span class="params">child, toIndex, lastIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child._mountIndex &lt; lastIndex) &#123;</span><br><span class="line">    <span class="built_in">this</span>.prepareToManageChildren();</span><br><span class="line">    enqueueMove(<span class="built_in">this</span>, child._mountIndex, toIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">createChild: <span class="function"><span class="keyword">function</span>(<span class="params">child, mountImage</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.prepareToManageChildren();</span><br><span class="line">  enqueueInsertMarkup(<span class="built_in">this</span>, mountImage, child._mountIndex);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line">removeChild: <span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.prepareToManageChildren();</span><br><span class="line">  enqueueRemove(<span class="built_in">this</span>, child._mountIndex);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_unmountChild: <span class="function"><span class="keyword">function</span>(<span class="params">child</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.removeChild(child);</span><br><span class="line">  child._mountIndex = <span class="literal">null</span>;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_mountChildAtIndex: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  child,</span></span></span><br><span class="line"><span class="function"><span class="params">  index,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mountImage = ReactReconciler.mountComponent(</span><br><span class="line">    child,</span><br><span class="line">    transaction,</span><br><span class="line">    <span class="built_in">this</span>,</span><br><span class="line">    <span class="built_in">this</span>._nativeContainerInfo,</span><br><span class="line">    context</span><br><span class="line">  );</span><br><span class="line">  child._mountIndex = index;</span><br><span class="line">  <span class="built_in">this</span>.createChild(child, mountImage);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>当然，React diff 还是存在些许不足与待优化的地方，如下图所示，若新集合的节点更新为：D、A、B、C，与老集合对比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 执行移动操作，然而由于 D 在老集合的位置是最大的，导致其他节点的 _mountIndex &lt; lastIndex，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面的现象。</p>
<p><em><strong>在此，读者们可以讨论思考：如何优化上述问题？</strong></em></p>
<blockquote>
<p>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/1b8dac5b9b3e4452dec8d5447d7717ad_r.jpg" alt="https://pic2.zhimg.com/1b8dac5b9b3e4452dec8d5447d7717ad_r.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li>
<li>React 通过<em><strong>分层求异</strong></em>的策略，对 <em><strong>tree diff</strong></em> 进行算法优化；</li>
<li>React 通过<em><strong>相同类生成相似树形结构，不同类生成不同树形结构</strong></em>的策略，对 <em><strong>component diff</strong></em> 进行算法优化；</li>
<li>React 通过<em><strong>设置唯一 key</strong></em>的策略，对 <em><strong>element diff</strong></em> 进行算法优化；</li>
<li>建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升；</li>
<li>建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">A Survey on Tree Edit Distance and Related Problems</a><br><a href="http://facebook.github.io/react/docs/reconciliation.html">Reconciliation</a></p>
<p>如果本文能够为你解决些许关于 React diff 算法的疑惑，请点个赞吧！</p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>源码解析</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Could not proxy request XXX from localhost:8080 to localhost:8081</title>
    <url>/2020/02/12/vue-proxyTable-problem/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<p>最近又有小伙伴问我，为啥我在写vue项目做代理转发时候报找不到代理服务的问题？<br>我看了一下他发给我的配置截图，仅一眼我就发现了问题所在，因为这个坑我曾经也踩过，而且好多小伙伴也都踩过，<em><strong>在写转发服务器的时候没写协议头</strong></em>，也就是在 <code>target</code> 那没写 <code>http://</code> 这个部分，添加上以后重启一下，这个问题就解决了，小伙伴说就这个问题他解决了一天也没解决了，而且我说完了以后他想起来以前好像也遇到过这个问题，所以说在平时工作中遇到问题要常做笔记才对，所以为了避免以后自己也犯这种错误，暂且留一篇文章记录一下这个问题。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>前端问题</category>
      </categories>
      <tags>
        <tag>奇怪问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack 打包时利用 UglifyJsPlugin 去掉comments 、console 、和 debugger</title>
    <url>/2020/04/07/webpack-uglifyjsplugin/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在检查公司前端代码质量时，经常会在sonar检查到有漏洞级别的问题特别多，但是打开查看详情的时候发现又特别低级，都是些console没去掉啊，debugger没去掉啊，之前都是看到了就提醒一下，但是屡禁不止，那么有没有什么好的办法能够从源头上避免这个问题呢，果然这个问题不止我一个人遇到，网上还是有大神给出了解决方案，那就是 webpack 打包时可以引入 UglifyJsPlugin 来解决这个扰人的问题，而且屏蔽了人为的因素，使用感觉是极好的，所以，写个帖子把网上学来的资料整理一下。</p>
<span id="more"></span>

<h2 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h2><p>关于 UglifyJsPlugin 的介绍，在 webpack 的官网上有这样一段描述 </p>
<blockquote>
<p>ℹ️ webpack =&lt; v3.0.0 currently contains v0.4.6 of this plugin under webpack.optimize.UglifyJsPlugin as an alias. For usage of the latest version (v1.0.0), please follow the instructions below. Aliasing v1.0.0 as webpack.optimize.UglifyJsPlugin is scheduled for webpack v4.0.0</p>
</blockquote>
<p>简单来说就是在 webpack3.0 之前，引入了这个插件的0.4.6版本，并用 webpack.optimize.UglifyJsPlugin 作为它的别名， 在 webpack4.0 中引入了插件的 1.0.0 版本，用了同样的名称作为别名，用的时候请注意。</p>
<p>那么“这个插件”是什么呢， webpack 的官网也告诉我们了，那就是<img src="https://github.com/mishoo/UglifyJS2/tree/harmony" alt="UglifyJS"></p>
<blockquote>
<p>A JavaScript parser, mangler/compressor and beautifier toolkit for ES6+.</p>
</blockquote>
<p>翻译过来就是“一个用于ES6+的JavaScript解析器、（榨汁机：翻译的挺有意思）/压缩机和美化工具。”</p>
<p>再简单点说 uglifyJsPlugin 用来对js文件进行压缩，减小js文件的大小。<em><strong>其会拖慢webpack的编译速度，建议开发环境时关闭，生产环境再将其打开。</strong></em></p>
<p>要用它的的话记得先安装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>安装完成就可以用了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然他有很多的选项，具体想了解可以去 webpack 官网，或者去插件官网都可以找到<img src="https://www.webpackjs.com/plugins/uglifyjs-webpack-plugin/" alt="uglifyjs-webpack-plugin"></p>
<p>当然知道你们懒的去看了，心里肯定也在说“直接给我个现成的配置他不香么？”，别急嘛，这就给你们</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    <span class="comment">//删除注释</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        comments:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//删除console 和 debugger  删除警告</span></span><br><span class="line">    compress:&#123;</span><br><span class="line">        warnings:<span class="literal">false</span>,</span><br><span class="line">        drop_debugger:<span class="literal">true</span>,</span><br><span class="line">        drop_console:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然版本间可能会有些差别，但是option是不变的，有调整的话各位自行调整一下。<br>公司用的 vue-cli3 所以这里再给出个 vue-cli3 默认配置文件下的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"></span><br><span class="line">configureWebpack:&#123;</span><br><span class="line">    optimization: &#123;</span><br><span class="line">        minimizer: [</span><br><span class="line">            <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">                uglifyOptions: &#123;</span><br><span class="line">                    <span class="comment">// 删除注释</span></span><br><span class="line">                    output:&#123;</span><br><span class="line">                      comments:<span class="literal">false</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 删除console debugger 删除警告</span></span><br><span class="line">                    compress: &#123;</span><br><span class="line">                      warnings: <span class="literal">false</span>,</span><br><span class="line">                      drop_console: <span class="literal">true</span>,<span class="comment">//console</span></span><br><span class="line">                      drop_debugger: <span class="literal">false</span>,</span><br><span class="line">                      pure_funcs: [<span class="string">&#x27;console.log&#x27;</span>]<span class="comment">//移除console</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题收集"><a href="#问题收集" class="headerlink" title="问题收集"></a>问题收集</h2><ol>
<li>运行出现报错 UglifyJs</li>
</ol>
<blockquote>
<p>Q: DefaultsError: warnings is not a supported option</p>
</blockquote>
<blockquote>
<p>A: 降低版本(使用 “uglifyjs-webpack-plugin”: “^1.1.1”)，打包正常，效果达到</p>
</blockquote>
]]></content>
      <categories>
        <category>前端工程化</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>UglifyJsPlugin</tag>
      </tags>
  </entry>
  <entry>
    <title>《Web全栈工程师的自我修养》读书笔记</title>
    <url>/2017/10/12/web-quanzhan/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近日工作不是那么忙，所以有时间看看书，这本书之前就已经读过一遍，隔了一段时间已经有所忘记，所以再次拾起，重新回顾一下。.</p>
<span id="more"></span>

<h2 id="什么是全栈"><a href="#什么是全栈" class="headerlink" title="什么是全栈"></a>什么是全栈</h2><p>“全栈”是个外来词，翻译自英文full-stack，此处的栈指的是为了完成项目而使用的一系列技术的合集，不是堆栈概念中的栈。</p>
<p>“全端”工程师是指能够完成pc端、移动端等多终端设备适配的情况</p>
<h2 id="什么是全栈工程师"><a href="#什么是全栈工程师" class="headerlink" title="什么是全栈工程师"></a>什么是全栈工程师</h2><blockquote>
<p>全栈工程师是指一个能够处理数据库、服务器、系统工程、客户端等所有工作的的工程师，根据项目不同，可能是移动栈、Web栈，或者原生应用程序栈。</p>
</blockquote>
<p>简单来说全栈工程师就是一个人能搞定一个项目，全能大神一样的人物。</p>
<h2 id="一个Web产品典型的技术栈"><a href="#一个Web产品典型的技术栈" class="headerlink" title="一个Web产品典型的技术栈"></a>一个Web产品典型的技术栈</h2><blockquote>
<p>服务器+数据库+服务器端编程语言+前端编程语言</p>
</blockquote>
<blockquote>
<p>全栈工程师技术的兴起有两个重要原因：技术的发展和PaaS（Platform as a Service，平台即服务）服务的平台越来越多。</p>
</blockquote>
<h3 id="全栈框架———MEAN"><a href="#全栈框架———MEAN" class="headerlink" title="全栈框架———MEAN"></a>全栈框架———MEAN</h3><blockquote>
<p>MongoDB-Express-AngularJs-Node.js<br>前后端采用一种编程语言JavaScript</p>
</blockquote>
<h2 id="全栈工程师的要求"><a href="#全栈工程师的要求" class="headerlink" title="全栈工程师的要求"></a>全栈工程师的要求</h2><h3 id="一专多长"><a href="#一专多长" class="headerlink" title="一专多长"></a>一专多长</h3><p>在一个领域里至少达到高级的级别，然后再去向上游或者下游延伸</p>
<h3 id="关注商业目标"><a href="#关注商业目标" class="headerlink" title="关注商业目标"></a>关注商业目标</h3><p>公司聘请你是为了让你产生利润，并不关心你会什么，所以选择技术栈时要考虑的是如何降低公司的成本或者提高收入。</p>
<h3 id="关注用户体验"><a href="#关注用户体验" class="headerlink" title="关注用户体验"></a>关注用户体验</h3><p>产品的最终目标是满足客户的需求，所以作为全栈工程师必须要关注用户体验。</p>
<hr>
<p>这是一些作为全栈工程师我整理出来的干货，这本书本身并不是一本技术性很强的书，倒像是一位过来人介绍些经验，适合刚入职场或者进入职场不久的人，在前端领域比较迷茫时看一看，书中介绍了作者读过的一些书，很有参考性，推荐大家阅读。</p>
]]></content>
      <categories>
        <category>自我提升</category>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>2020年了,再不会webpack敲得代码就不香了(近万字实战)【转载】</title>
    <url>/2020/03/24/webpack-learning-1/</url>
    <content><![CDATA[<h1 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h1><p>这里是我自己写的，看了这篇文章把我零碎的 <code>webpack</code> 知识系统的整理了一下，感觉受益匪浅，推荐更多小伙伴看一看这篇文章，好文共享，建议稍微对 <code>webpack</code> 了解服用更佳。<br><a href="https://zhuanlan.zhihu.com/p/99959392">2020年了,再不会webpack敲得代码就不香了(近万字实战)</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2020年即将到来,在众多前端的招聘要求里, <code>webpack</code> 、工程化这些字眼频率越来越高。日常开发者中，我们常常在用诸如 <code>vue-cli</code> 、 <code>create-react-app</code>  的脚手架来构建我们的项目。但是如果你想在团队脱颖而出(鹤立鸡群)、拿到更好的 <code>offer</code> (还房贷)，那么你必须去深刻的认识下我们经常打交道的 <code>webpack</code></p>
<h2 id="入门-一起来用这些小例子让你熟悉webpack的配置"><a href="#入门-一起来用这些小例子让你熟悉webpack的配置" class="headerlink" title="入门(一起来用这些小例子让你熟悉webpack的配置)"></a>入门(一起来用这些小例子让你熟悉webpack的配置)</h2><h3 id="webpack-是什么？"><a href="#webpack-是什么？" class="headerlink" title="webpack 是什么？"></a>webpack 是什么？</h3><p><code>webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块打包器，当 <code>webpack</code> 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code> 。</p>
<h3 id="webpack-的核心概念"><a href="#webpack-的核心概念" class="headerlink" title="webpack 的核心概念"></a>webpack 的核心概念</h3><ul>
<li><code>entry</code>: 入口</li>
<li><code>output</code>: 输出</li>
<li><code>loader</code>: 模块转换器，用于把模块原内容按照需求转换成新内容</li>
<li><code>plugins</code>: 扩展插件，在 <code>webpack</code> 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</li>
</ul>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>新建一个目录，初始化 <code>npm</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>

<p><code>webpack</code> 是运行在 <code>node</code> 环境中的,我们需要安装以下两个 <code>npm</code> 包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>npm i -D</code> 为 <code>npm install --save-dev</code> 的缩写</li>
<li><code>npm i -S</code> 为 <code>npm install --save</code> 的缩写</li>
</ul>
</blockquote>
<p>新建一个文件夹 <code>src</code> ,然后新建一个文件 <code>main.js</code> ,写一点代码测试一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;call me 老yuan&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>配置 <code>package.json</code> 命令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">  &quot;build&quot;:&quot;webpack src/main.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>此时如果生成了一个 <code>dist</code> 文件夹，并且内部含有 <code>main.js</code> 说明已经打包成功了</p>
<h3 id="开始我们自己的配置"><a href="#开始我们自己的配置" class="headerlink" title="开始我们自己的配置"></a>开始我们自己的配置</h3><p>上面一个简单的例子只是 <code>webpack</code> 自己默认的配置，下面我们要实现更加丰富的自定义配置</p>
<p>新建一个 <code>build</code> 文件夹,里面新建一个 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: path.resolve(__dirname,<span class="string">&#x27;../src/main.js&#x27;</span>),    <span class="comment">// 入口文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;output.js&#x27;</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">        path: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改我们的打包命令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">  &quot;build&quot;:&quot;webpack build/webpack.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm run build</code><br>会发现生成了以下目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">project</span><br><span class="line">  dist</span><br><span class="line">  build</span><br><span class="line">  src</span><br></pre></td></tr></table></figure>
<p>其中 <code>dist</code> 文件夹中的 <code>main.js</code> 就是我们需要在浏览器中实际运行的文件<br>当然实际运用中不会仅仅如此,下面让我们通过实际案例带你快速入手 <code>webpack</code></p>
<h3 id="配置html模板"><a href="#配置html模板" class="headerlink" title="配置html模板"></a>配置html模板</h3><p><code>js</code> 文件打包好了,但是我们不可能每次在html文件中手动引入打包好的js</p>
<blockquote>
<p>这里可能有的朋友会认为我们打包 <code>js</code> 文件名称不是一直是固定的嘛( <code>output.js</code> )？这样每次就不用改动引入文件名称了呀？实际上我们日常开发中往往会这样配置:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略其他配置</span></span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候生成的 <code>dist</code> 目录文件如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dist/</span><br><span class="line">  app.fsafasf.js</span><br></pre></td></tr></table></figure>
<p>为了缓存，你会发现打包好的 <code>js</code> 文件的名称每次都不一样。 <code>webpack</code> 打包出来的js文件我们需要引入到 <code>html</code> 中，但是每次我们都手动修改 <code>js</code> 文件名显得很麻烦，因此我们需要一个插件来帮我们完成这件事情，那就是 <code>html-webpack-plugin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>新建一个 <code>build</code> 同级的文件夹 <code>public</code> ,里面新建一个 <code>index.html</code><br>具体配置文件如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>) <span class="comment">// **此插件用来解决html模板引入js文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: path.resolve(__dirname,<span class="string">&#x27;../src/main.js&#x27;</span>),    <span class="comment">// 入口文件</span></span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">&#x27;../public/index.html&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现打包生成的js文件已经被自动引入 <code>html</code> 文件中</p>
<h4 id="多入口文件如何开发"><a href="#多入口文件如何开发" class="headerlink" title="多入口文件如何开发"></a>多入口文件如何开发</h4><blockquote>
<p>生成多个 <code>html-webpack-plugin</code> 实例来解决这个问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">      main:path.resolve(__dirname,<span class="string">&#x27;../src/main.js&#x27;</span>),</span><br><span class="line">      header:path.resolve(__dirname,<span class="string">&#x27;../src/header.js&#x27;</span>)</span><br><span class="line">    &#125;, </span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">        filename:<span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">        chunks:[<span class="string">&#x27;main&#x27;</span>] <span class="comment">// 与入口文件对应的模块名</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">&#x27;../public/header.html&#x27;</span>),</span><br><span class="line">        filename:<span class="string">&#x27;header.html&#x27;</span>,</span><br><span class="line">        chunks:[<span class="string">&#x27;header&#x27;</span>] <span class="comment">// 与入口文件对应的模块名</span></span><br><span class="line">      &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h4><blockquote>
<p>每次执行 <code>npm run build</code> 会发现 <code>dist</code> 文件夹里会残留上次打包的文件，这里我们推荐一个 <code>plugin</code> 来帮我们在打包输出前清空文件夹 <code>clean-webpack-plugin</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...省略其他配置</span></span><br><span class="line">    plugins:[<span class="keyword">new</span> CleanWebpackPlugin()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="希望dist目录下某个文件夹不被清空"><a href="#希望dist目录下某个文件夹不被清空" class="headerlink" title="希望dist目录下某个文件夹不被清空"></a>希望dist目录下某个文件夹不被清空</h5><p>不过呢，有些时候，我们并不希望整个 dist 目录都被清空，比如，我们不希望，每次打包的时候，都删除 <code>dll</code> 目录，以及 <code>dll</code> 目录下的文件或子目录，该怎么办呢？</p>
<p><code>clean-webpack-plugin</code> 为我们提供了参数 <code>cleanOnceBeforeBuildPatterns</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">            cleanOnceBeforeBuildPatterns:[<span class="string">&#x27;**/*&#x27;</span>, <span class="string">&#x27;!dll&#x27;</span>, <span class="string">&#x27;!dll/**&#x27;</span>] <span class="comment">//不删除dll目录下的文件</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用CSS"><a href="#引用CSS" class="headerlink" title="引用CSS"></a>引用CSS</h3><p>我们的入口文件是 <code>js</code> ，所以我们在入口 <code>js</code> 中引入我们的 <code>css</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;asset/style.css&#x27;</span></span><br></pre></td></tr></table></figure>
<p>同时我们也需要一些 <code>loader</code> 来解析我们的 <code>css</code> 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D style-loader css-loader</span><br></pre></td></tr></table></figure>
<p>如果我们使用 <code>less</code> 来构建样式，则需要多安装两个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D less less-loader</span><br></pre></td></tr></table></figure>
<p>配置文件如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// ...省略其他配置</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">          use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">          use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们简单说一下上面的配置：</p>
<ul>
<li><code>style-loader</code> 动态创建 <code>style</code> 标签，将 <code>css</code> 插入到 <code>head</code> 中.</li>
<li><code>css-loader</code> 负责处理 <code>@import</code> 等语句。</li>
<li><code>postcss-loader</code> 和 <code>autoprefixer</code> ，自动生成浏览器兼容性前缀 —— 2020了，应该没人去自己徒手去写浏览器前缀了吧</li>
<li><code>less-loader</code> 负责处理编译 <code>.less</code> 文件,将其转为 <code>css</code></li>
</ul>
<blockquote>
<p>注意：<br><code>loader</code> 的执行顺序是<em><strong>从右向左</strong></em>执行的，也就是后面的 <code>loader</code> 先执行，上面 <code>loader</code> 的执行顺序为: <code>less-loader</code> —&gt; <code>postcss-loader</code> —&gt; <code>css-loader</code> —&gt; <code>style-loader</code><br>当然，<code>loader</code> 其实还有一个参数，可以修改优先级，<code>enforce</code> 参数，其值可以为: <code>pre</code>(优先执行) 或 <code>post</code> (滞后执行)。<br>现在，我们已经可以处理 <code>.less</code> 文件啦，<code>.css</code> 文件只需要修改匹配规则，删除 <code>less-loader</code> 即可。</p>
</blockquote>
<h4 id="为css添加浏览器前缀"><a href="#为css添加浏览器前缀" class="headerlink" title="为css添加浏览器前缀"></a>为css添加浏览器前缀</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D postcss-loader autoprefixer</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            test/\.less$/,</span><br><span class="line">            use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;postcss-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们还需要引入 <code>autoprefixer</code> 使其生效,这里有两种方式</p>
<h5 id="在项目根目录下创建一个postcss-config-js文件，配置如下："><a href="#在项目根目录下创建一个postcss-config-js文件，配置如下：" class="headerlink" title="在项目根目录下创建一个postcss.config.js文件，配置如下："></a>在项目根目录下创建一个postcss.config.js文件，配置如下：</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]  <span class="comment">// 引用该插件即可了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="直接在webpack-config-js里配置"><a href="#直接在webpack-config-js里配置" class="headerlink" title="直接在webpack.config.js里配置"></a>直接在webpack.config.js里配置</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...省略其他配置</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:[<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,&#123;</span><br><span class="line">                loader:<span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    plugins:[<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&#x27;less-loader&#x27;</span>] <span class="comment">// 从右向左解析原则</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们发现 <code>css</code> 通过 <code>style</code> 标签的方式添加到了 <code>html</code> 文件中，但是如果样式文件很多，全部添加到 <code>html</code> 中，难免显得混乱。这时候我们想用把 <code>css</code> 拆分出来用外链的形式引入 <code>css</code> 文件怎么做呢？这时候我们就需要借助插件来帮助我们</p>
<h4 id="拆分css"><a href="#拆分css" class="headerlink" title="拆分css"></a>拆分css</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D mini-css-extract-plugin</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>webpack 4.0</code> 以前，我们通过 <code>extract-text-webpack-plugin</code> 插件，把 <code>css</code> 样式从 <code>js</code> 文件中提取到单独的 <code>css</code> 文件中。 <code>webpack4.0</code> 以后，官方推荐使用 <code>mini-css-extract-plugin</code> 插件来打包 <code>css</code> 文件</p>
</blockquote>
<p>配置文件如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...省略其他配置</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">           MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">&quot;[name].[hash].css&quot;</span>,</span><br><span class="line">        chunkFilename: <span class="string">&quot;[id].css&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拆分多个css"><a href="#拆分多个css" class="headerlink" title="拆分多个css"></a>拆分多个css</h4><blockquote>
<p>这里需要说的细一点,上面我们所用到的 <code>mini-css-extract-plugin</code> 将所有的 <code>css</code> 样式合并为一个 <code>css</code> 文件。如果你想拆分为一一对应的多个 <code>css</code> 文件,我们需要使用到 <code>extract-text-webpack-plugin</code> ，而目前 <code>mini-css-extract-plugin</code> 还不支持此功能。我们需要安装 <code>@next</code> 版本的 <code>extract-text-webpack-plugin</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D extract-text-webpack-plugin@next</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> indexLess = <span class="keyword">new</span> ExtractTextWebpackPlugin(<span class="string">&#x27;index.less&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> indexCss = <span class="keyword">new</span> ExtractTextWebpackPlugin(<span class="string">&#x27;index.css&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: indexCss.extract(&#123;</span><br><span class="line">            use: [<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: indexLess.extract(&#123;</span><br><span class="line">            use: [<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      indexLess,</span><br><span class="line">      indexCss</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打包-图片、字体、媒体、等文件"><a href="#打包-图片、字体、媒体、等文件" class="headerlink" title="打包 图片、字体、媒体、等文件"></a>打包 图片、字体、媒体、等文件</h3><p><code>file-loader</code> 就是将文件在进行一些处理后（主要是处理文件名和路径、解析文件 <code>url</code> ），并将文件移动到输出的目录中<br><code>url-loader</code> 一般与 <code>file-loader</code> 搭配使用，功能与 <code>file-loader</code> 类似，如果文件小于限制的大小。则会返回 <code>base64</code> 编码，否则使用 <code>file-loader</code> 将文件移动到输出的目录中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 省略其它配置 ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif)$/i</span>, <span class="comment">//图片文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>,</span><br><span class="line">              fallback: &#123;</span><br><span class="line">                loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    name: <span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>, <span class="comment">//媒体文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>,</span><br><span class="line">              fallback: &#123;</span><br><span class="line">                loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  name: <span class="string">&#x27;media/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>, <span class="comment">// 字体</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">10240</span>,</span><br><span class="line">              fallback: &#123;</span><br><span class="line">                loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  name: <span class="string">&#x27;fonts/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用babel转义js文件"><a href="#用babel转义js文件" class="headerlink" title="用babel转义js文件"></a>用babel转义js文件</h3><p>为了使我们的 <code>js</code> 代码兼容更多的环境我们需要安装依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i babel-loader @babel/preset-env @babel/core</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>babel-loader</code> 与 <code>babel-core</code> 的版本对应关系</p>
</blockquote>
<ul>
<li><code>babel-loader 8.x</code> 对应 <code>babel-core 7.x</code></li>
<li><code>babel-loader 7.x</code> 对应 <code>babel-core 6.x</code></li>
</ul>
<p>配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略其它配置 ...</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">          &#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            use:&#123;</span><br><span class="line">              loader:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                presets:[<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">          &#125;,</span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>babel-loader</code> 只会将 <code>ES6/7/8</code> 语法转换为 <code>ES5</code> 语法，但是对新 <code>api</code> 并不会转换 例如( <code>promise</code> 、 <code>Generator</code> 、 <code>Set</code> 、 <code>Maps</code> 、 <code>Proxy</code> 等)<br>此时我们需要借助 <code>babel-polyfill</code> 来帮助我们转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i @babel/polyfill</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [<span class="string">&quot;@babel/polyfill,path.resolve(__dirname,&#x27;../src/index.js&#x27;)&quot;</span>],    <span class="comment">// 入口文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手动把上面的 <code>demo</code> 敲一遍对阅读下面的文章更有益，建议入门的同学敲三遍以上</p>
</blockquote>
<p>上面的实践是我们对 <code>webpack</code> 的功能有了一个初步的了解，但是要想熟练应用于开发中，我们需要一个系统的实战。让我们一起摆脱脚手架尝试自己搭建一个 <code>vue</code> 开发环境</p>
<h2 id="搭建vue开发环境"><a href="#搭建vue开发环境" class="headerlink" title="搭建vue开发环境"></a>搭建vue开发环境</h2><p>上面的小例子已经帮助而我们实现了打包 <code>css</code> 、图片、 <code>js</code> 、 <code>html</code> 等文件。<br>但是我们还需要以下几种配置</p>
<h3 id="解析-vue文件"><a href="#解析-vue文件" class="headerlink" title="解析.vue文件"></a>解析.vue文件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D vue-loader vue-template-compiler vue-style-loader</span><br><span class="line">npm i -S vue</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vue-loader</code> 用于解析 <code>.vue</code> 文件</li>
<li><code>vue-template-compiler</code> 用于编译模板</li>
</ul>
<p>配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">            use:[<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">        &#125;,]</span><br><span class="line">     &#125;,</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        alias:&#123;</span><br><span class="line">          <span class="string">&#x27;vue$&#x27;</span>:<span class="string">&#x27;vue/dist/vue.runtime.esm.js&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27; @&#x27;</span>:path.resolve(__dirname,<span class="string">&#x27;../src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        extensions:[<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">   &#125;,</span><br><span class="line">   plugins:[</span><br><span class="line">        <span class="keyword">new</span> vueLoaderPlugin()</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置webpack-dev-server进行热更新"><a href="#配置webpack-dev-server进行热更新" class="headerlink" title="配置webpack-dev-server进行热更新"></a>配置webpack-dev-server进行热更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...省略其他配置</span></span><br><span class="line">  devServer:&#123;</span><br><span class="line">    port:<span class="number">3000</span>,</span><br><span class="line">    hot:<span class="literal">true</span>,</span><br><span class="line">    contentBase:<span class="string">&#x27;../dist&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> Webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整配置如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;extract-text-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> vueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">    entry: &#123;</span><br><span class="line">      main:path.resolve(__dirname,<span class="string">&#x27;../src/main.js&#x27;</span>),</span><br><span class="line">    &#125;, </span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">&#x27;[name].[hash:8].js&#x27;</span>,      <span class="comment">// 打包后的文件名称</span></span><br><span class="line">      path: path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>)  <span class="comment">// 打包后的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">      rules:[</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">          use:[<span class="string">&#x27;vue-loader&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">          use:&#123;</span><br><span class="line">            loader:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              presets:[</span><br><span class="line">                [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [<span class="string">&#x27;vue-style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,&#123;</span><br><span class="line">            loader:<span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              plugins:[<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: [<span class="string">&#x27;vue-style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>,&#123;</span><br><span class="line">            loader:<span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              plugins:[<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,<span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve:&#123;</span><br><span class="line">      alias:&#123;</span><br><span class="line">        <span class="string">&#x27;vue$&#x27;</span>:<span class="string">&#x27;vue/dist/vue.runtime.esm.js&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; @&#x27;</span>:path.resolve(__dirname,<span class="string">&#x27;../src&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      extensions:[<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">      port:<span class="number">3000</span>,</span><br><span class="line">      hot:<span class="literal">true</span>,</span><br><span class="line">      contentBase:<span class="string">&#x27;../dist&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">      <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:path.resolve(__dirname,<span class="string">&#x27;../public/index.html&#x27;</span>),</span><br><span class="line">        filename:<span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> vueLoaderPlugin(),</span><br><span class="line">      <span class="keyword">new</span> Webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置打包命令"><a href="#配置打包命令" class="headerlink" title="配置打包命令"></a>配置打包命令</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;script&quot;:&#123;</span><br><span class="line">  &quot;dev&quot;:&quot;webpack-dev-server --config build/webpack.config.js --open&quot;,</span><br><span class="line">  &quot;build&quot;:&quot;webpack --config build/webpack.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包文件已经配置完毕，接下来让我们测试一下<br>首先在 <code>src</code> 新建一个 <code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./app&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render:<span class="function"><span class="params">h</span>=&gt;</span>h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>新建一个 <code>App.vue</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&#x27;container&#x27;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      initData:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">#container&#123;</span><br><span class="line">  width:<span class="number">100</span>%;</span><br><span class="line">  height:<span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>新建一个 <code>public</code> 文件夹，里面新建一个 <code>index.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&#x27;en&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&#x27;X-UA-Compatible&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;ie=edge&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>lao li<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>npm run dev</code> 这时候如果浏览器出现 <code>Vue</code> 开发环境运行成功，那么恭喜你，已经成功迈出了第一步</p>
<h3 id="区分开发环境与生产环境"><a href="#区分开发环境与生产环境" class="headerlink" title="区分开发环境与生产环境"></a>区分开发环境与生产环境</h3><p>实际应用到项目中，我们需要区分开发环境与生产环境，我们在原来 <code>webpack.config.js</code> 的基础上再新增两个文件</p>
<p><em><strong><code>webpack.dev.js</code> 开发环境配置文件</strong></em><br>开发环境主要实现的是热更新,不要压缩代码，完整的 <code>sourceMap</code><br><em><strong><code>webpack.prod.js</code>生产环境配置文件</strong></em><br>生产环境主要实现的是压缩代码、提取 <code>css</code> 文件、合理的 <code>sourceMap</code> 、分割代码<br>需要安装以下模块:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D  webpack-merge copy-webpack-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin</span><br></pre></td></tr></table></figure>
<ul>
<li><code>webpack-merge</code> 合并配置</li>
<li><code>copy-webpack-plugin</code> 拷贝静态资源</li>
<li><code>optimize-css-assets-webpack-plugin</code> 压缩 <code>css</code></li>
<li><code>uglifyjs-webpack-plugin</code> 压缩js</li>
</ul>
<blockquote>
<p><code>webpack</code> <code>mode</code> 设置 <code>production</code> 的时候会自动压缩 <code>js</code> 代码。<br>原则上不需要引入 <code>uglifyjs-webpack-plugin</code> 进行重复工作。<br>但是 <code>optimize-css-assets-webpack-plugin </code>压缩 <code>css</code> 的同时会破坏原有的 <code>js</code> 压缩，所以这里我们引入 <code>uglifyjs</code> 进行压缩</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> vueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> devMode = process.argv.indexOf(<span class="string">&#x27;--mode=production&#x27;</span>) === -<span class="number">1</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry:&#123;</span><br><span class="line">    main:path.resolve(__dirname,<span class="string">&#x27;../src/main.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output:&#123;</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">    filename:<span class="string">&#x27;js/[name].[hash:8].js&#x27;</span>,</span><br><span class="line">    chunkFilename:<span class="string">&#x27;js/[name].[hash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            presets:[<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use:[<span class="string">&#x27;cache-loader&#x27;</span>,<span class="string">&#x27;thread-loader&#x27;</span>,&#123;</span><br><span class="line">          loader:<span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            compilerOptions:&#123;</span><br><span class="line">              preserveWhitespace:<span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">        use:[&#123;</span><br><span class="line">          loader: devMode ? <span class="string">&#x27;vue-style-loader&#x27;</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">          options:&#123;</span><br><span class="line">            publicPath:<span class="string">&quot;../dist/css/&quot;</span>,</span><br><span class="line">            hmr:devMode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,<span class="string">&#x27;css-loader&#x27;</span>,&#123;</span><br><span class="line">          loader:<span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            plugins:[<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use:[&#123;</span><br><span class="line">          loader:devMode ? <span class="string">&#x27;vue-style-loader&#x27;</span> : MiniCssExtractPlugin.loader,</span><br><span class="line">          options:&#123;</span><br><span class="line">            publicPath:<span class="string">&quot;../dist/css/&quot;</span>,</span><br><span class="line">            hmr:devMode</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;less-loader&#x27;</span>,&#123;</span><br><span class="line">          loader:<span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            plugins:[<span class="built_in">require</span>(<span class="string">&#x27;autoprefixer&#x27;</span>)]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.(jep?g|png|gif)$/</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            limit:<span class="number">10240</span>,</span><br><span class="line">            fallback:&#123;</span><br><span class="line">              loader:<span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                name:<span class="string">&#x27;img/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            limit:<span class="number">10240</span>,</span><br><span class="line">            fallback:&#123;</span><br><span class="line">              loader:<span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                name:<span class="string">&#x27;media/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>,</span><br><span class="line">        use:&#123;</span><br><span class="line">          loader:<span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">            limit:<span class="number">10240</span>,</span><br><span class="line">            fallback:&#123;</span><br><span class="line">              loader:<span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">              options:&#123;</span><br><span class="line">                name:<span class="string">&#x27;media/[name].[hash:8].[ext]&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve:&#123;</span><br><span class="line">    alias:&#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>:<span class="string">&#x27;vue/dist/vue.runtime.esm.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27; @&#x27;</span>:path.resolve(__dirname,<span class="string">&#x27;../src&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions:[<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;.js&#x27;</span>,<span class="string">&#x27;.json&#x27;</span>,<span class="string">&#x27;.vue&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template:path.resolve(__dirname,<span class="string">&#x27;../public/index.html&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> vueLoaderPlugin(),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: devMode ? <span class="string">&#x27;[name].css&#x27;</span> : <span class="string">&#x27;[name].[hash].css&#x27;</span>,</span><br><span class="line">      chunkFilename: devMode ? <span class="string">&#x27;[id].css&#x27;</span> : <span class="string">&#x27;[id].[hash].css&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(webpackConfig,&#123;</span><br><span class="line">  mode:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  devtool:<span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line">  devServer:&#123;</span><br><span class="line">    port:<span class="number">3000</span>,</span><br><span class="line">    hot:<span class="literal">true</span>,</span><br><span class="line">    contentBase:<span class="string">&#x27;../dist&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> Webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> WebpackMerge = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;copy-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackMerge(webpackConfig,&#123;</span><br><span class="line">  mode:<span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  devtool:<span class="string">&#x27;cheap-module-source-map&#x27;</span>,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([&#123;</span><br><span class="line">      <span class="keyword">from</span>:path.resolve(__dirname,<span class="string">&#x27;../public&#x27;</span>),</span><br><span class="line">      to:path.resolve(__dirname,<span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">    &#125;]),</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    minimizer:[</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;<span class="comment">//压缩js</span></span><br><span class="line">        cache:<span class="literal">true</span>,</span><br><span class="line">        parallel:<span class="literal">true</span>,</span><br><span class="line">        sourceMap:<span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ],</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      cacheGroups:&#123;</span><br><span class="line">        libs: &#123;</span><br><span class="line">          name: <span class="string">&quot;chunk-libs&quot;</span>,</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">10</span>,</span><br><span class="line">          chunks: <span class="string">&quot;initial&quot;</span> <span class="comment">// 只打包初始时依赖的第三方</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="优化webpack配置"><a href="#优化webpack配置" class="headerlink" title="优化webpack配置"></a>优化webpack配置</h2><p>看到这里你或许有些累了，但是要想获取更好的offer,更高的薪水，下面必须继续深入</p>
<p>优化配置对我们来说非常有实际意义，这实际关系到你打包出来文件的大小，打包的速度等。<br>具体优化可以分为以下几点：</p>
<h3 id="优化打包速度"><a href="#优化打包速度" class="headerlink" title="优化打包速度"></a>优化打包速度</h3><blockquote>
<p>构建速度指的是我们每次修改代码后热更新的速度以及发布前打包文件的速度。</p>
</blockquote>
<h4 id="合理的配置-mode-参数与-devtool-参数"><a href="#合理的配置-mode-参数与-devtool-参数" class="headerlink" title="合理的配置 mode 参数与 devtool 参数"></a>合理的配置 mode 参数与 devtool 参数</h4><p><a href="https://www.webpackjs.com/configuration/devtool/">devtool 可设置的值</a><br><code>mode</code> 可设置 <code>development</code> <code>production</code> 两个参数</p>
<p>如果没有设置， <code>webpack4</code> 会将 <code>mode</code> 的默认值设置为 <code>production</code></p>
<ul>
<li><code>production</code> ：将 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code> ，启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>,会进行 <code>tree shaking</code> (去除无用代码)和 <code>uglifyjs</code> (代码压缩混淆)</li>
<li><code>development</code> ：将 <code>process.env.NODE_ENV</code> 的值设置为 <code>development</code> ，启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></li>
</ul>
<h4 id="缩小文件的搜索范围-配置include-exclude-alias-noParse-extensions"><a href="#缩小文件的搜索范围-配置include-exclude-alias-noParse-extensions" class="headerlink" title="缩小文件的搜索范围(配置include exclude alias noParse extensions)"></a>缩小文件的搜索范围(配置include exclude alias noParse extensions)</h4><ul>
<li><code>alias</code>  当我们代码中出现 import ‘vue’时， webpack会采用向上递归搜索的方式去node_modules 目录下找。为了减少搜索范围我们可以直接告诉webpack去哪个路径下查找。也就是别名(alias)的配置。</li>
<li><code>include</code> <code>exclude</code>  同样配置include exclude也可以减少webpack loader的搜索转换时间。</li>
<li><code>noParse</code>  当我们代码中使用到 <code>import jq from &#39;jquery&#39;</code> 时， <code>webpack</code> 会去解析 <code>jq</code> 这个库是否有依赖其他的包。但是我们对类似 <code>jquery</code> 这类依赖库，一般会认为不会引用其他的包(特殊除外,自行判断)。增加 <code>noParse</code> 属性,告诉 <code>webpack</code> 不必解析，以此增加打包速度。</li>
<li><code>extensions</code>  <code>webpack</code> 会根据 <code>extensions</code> 定义的后缀查找文件(频率较高的文件类型优先写在前面)</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-6fd8b21b8e9d9b18a596bd9dc6025a18_720w.jpg" alt="配图"></p>
<h4 id="使用HappyPack开启多进程Loader转换"><a href="#使用HappyPack开启多进程Loader转换" class="headerlink" title="使用HappyPack开启多进程Loader转换"></a>使用HappyPack开启多进程Loader转换</h4><blockquote>
<p>在 <code>webpack</code> 构建过程中，实际上耗费时间大多数用在 <code>loader</code> 解析转换以及代码的压缩中。日常开发中我们需要使用 <code>Loader</code> 对 <code>js</code> ， <code>css</code> ，图片，字体等文件做转换操作，并且转换的文件数据量也是非常大。由于js单线程的特性使得这些转换操作不能并发处理文件，而是需要一个个文件进行处理。 <code>HappyPack</code> 的基本原理是将这部分任务分解到多个子进程中去并行处理，子进程处理完成后把结果发送到主进程中，从而减少总的构建时间</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D happypack</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/v2-ebcaa0bea4e7ec24c3e3e65439998fe5_r.jpg" alt="happypack"></p>
<h4 id="使用-webpack-parallel-uglify-plugin-增强代码压缩"><a href="#使用-webpack-parallel-uglify-plugin-增强代码压缩" class="headerlink" title="使用 webpack-parallel-uglify-plugin 增强代码压缩"></a>使用 webpack-parallel-uglify-plugin 增强代码压缩</h4><p>上面对于 <code>loader</code> 转换已经做优化，那么下面还有另一个难点就是优化代码的压缩时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-parallel-uglify-plugin</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-38bc4d4b3120096478a411f374457a1d_720w.jpg" alt="webpack-parallel-uglify-plugin"></p>
<h4 id="抽离第三方模块"><a href="#抽离第三方模块" class="headerlink" title="抽离第三方模块"></a>抽离第三方模块</h4><blockquote>
<p>对于开发项目中不经常会变更的静态依赖文件。类似于我们的 <code>elementUi</code> 、 <code>vue</code> 全家桶等等。因为很少会变更，所以我们不希望这些依赖要被集成到每一次的构建逻辑中去。 这样做的好处是每次更改我本地代码的文件的时候， <code>webpack</code> 只需要打包我项目本身的文件代码，而不会再去编译第三方库。以后只要我们不升级第三方包的时候，那么 <code>webpack</code> 就不会对这些库去打包，这样可以快速的提高打包的速度。</p>
</blockquote>
<p>这里我们使用 <code>webpack</code> 内置的 <code>DllPlugin</code> <code>DllReferencePlugin</code> 进行抽离</p>
<p>在与 <code>webpack</code> 配置文件同级目录下新建 <code>webpack.dll.config.js</code><br>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 你想要打包的模块的数组</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">&#x27;vue&#x27;</span>,<span class="string">&#x27;element-ui&#x27;</span>] </span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;static/js&#x27;</span>), <span class="comment">// 打包后文件输出的位置</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    library: <span class="string">&#x27;[name]_library&#x27;</span> </span><br><span class="line">     <span class="comment">// 这里需要和webpack.DllPlugin中的`name: &#x27;[name]_library&#x27;,`保持一致。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">&#x27;[name]-manifest.json&#x27;</span>),</span><br><span class="line">      name: <span class="string">&#x27;[name]_library&#x27;</span>, </span><br><span class="line">      context: __dirname</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>package.json</code> 中配置如下命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dll&quot;</span>: <span class="string">&quot;webpack --config build/webpack.dll.config.js&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来在我们的 <code>webpack.config.js</code> 中增加以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">&#x27;./vendor-manifest.json&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([ <span class="comment">// 拷贝生成的文件到dist目录 这样每次不必手动去cv</span></span><br><span class="line">      &#123;<span class="attr">from</span>: <span class="string">&#x27;static&#x27;</span>, <span class="attr">to</span>:<span class="string">&#x27;static&#x27;</span>&#125;</span><br><span class="line">    ]),</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dll</span><br></pre></td></tr></table></figure>

<p>会发现生成了我们需要的集合第三地方<br>代码的 <code>vendor.dll.js</code><br>我们需要在html文件中手动引入这个js文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>老yuan<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;static/js/vendor.dll.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样如果我们没有更新第三方依赖包，就不必 <code>npm run dll</code> 。直接执行 <code>npm run dev</code>  <code>npm run build</code> 的时候会发现我们的打包速度明显有所提升。因为我们已经通过 <code>dllPlugin</code> 将第三方依赖包抽离出来了。</p>
<h4 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h4><blockquote>
<p>我们每次执行构建都会把所有的文件都重复编译一遍，这样的重复工作是否可以被缓存下来呢，答案是可以的，目前大部分 <code>loader</code> 都提供了 <code>cache</code> 配置项。比如在 <code>babel-loader</code> <code>中，可以通过设置cacheDirectory</code> 来开启缓存，<code>babel-loader?cacheDirectory=true</code> 就会将每次的编译结果写进硬盘文件（默认是在项目根目录下的 <code>node_modules/.cache/babel-loader</code> 目录内，当然你也可以自定义）<br>但如果 <code>loader</code> 不支持缓存呢？我们也有方法,我们可以通过 <code>cache-loader</code> ，它所做的事情很简单，就是 <code>babel-loader</code> 开启 <code>cache</code> 后做的事情，将 <code>loader</code> 的编译结果写入硬盘缓存。再次构建会先比较一下，如果文件较之前的没有发生变化则会直接使用缓存。使用方法如官方 <code>demo</code> 所示，在一些性能开销较大的 <code>loader</code> 之前添加此 <code>loader</code> 即可</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D cache-loader</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-e00ab48297af32f344070b5637ba88ca_720w.jpg" alt="cache-loader"></p>
<h3 id="优化打包文件体积"><a href="#优化打包文件体积" class="headerlink" title="优化打包文件体积"></a>优化打包文件体积</h3><p>打包的速度我们是进行了优化，但是打包后的文件体积却是十分大，造成了页面加载缓慢，浪费流量等，接下来让我们从文件体积上继续优化</p>
<h4 id="引入webpack-bundle-analyzer分析打包后的文件"><a href="#引入webpack-bundle-analyzer分析打包后的文件" class="headerlink" title="引入webpack-bundle-analyzer分析打包后的文件"></a>引入webpack-bundle-analyzer分析打包后的文件</h4><p><code>webpack-bundle-analyzer</code> 将打包后的内容束展示为方便交互的直观树状图，让我们知道我们所构建包中真正引入的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/v2-b23299204561718ba4636aeff9f71d6e_r.jpg" alt="webpack-bundle-analyzer"></p>
<p>接下来在 <code>package.json</code> 里配置启动命令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run build&quot;</span><br></pre></td></tr></table></figure>
<p><code>windows</code> 请安装 <code>npm i -D cross-env</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;analyz&quot;: &quot;cross-env NODE_ENV=production npm_config_report=true npm run build&quot;</span><br></pre></td></tr></table></figure>
<p>接下来 <code>npm run analyz</code> 浏览器会自动打开文件依赖图的网页</p>
<h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><blockquote>
<p>按照官方文档的解释，如果我们想引用一个库，但是又不想让 <code>webpack</code> 打包，并且又不影响我们在程序中以 <code>CMD</code> 、 <code>AMD</code> 或者 <code>window</code>/<code>global</code> 全局等方式进行使用，那就可以通过配置 <code>Externals</code> 。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用<code>Externals</code> 的方式，我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 <code>CDN</code>的方式，去引用它们。<br>有时我们希望我们通过 <code>script</code> 引入的库，如用 <code>CDN</code> 的方式引入的 <code>jquery</code> ，我们在使用时，依旧用 <code>require</code> 的方式来使用，但是却不希望 <code>webpack</code> 将它又编译进文件中。这里官网案例已经足够清晰明了，大家有兴趣可以点击了解<br><a href="https://link.zhihu.com/?target=https://webpack.js.org/configuration/externals/%23root">webpack</a><br>官网案例如下</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  src=<span class="string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span></span><br><span class="line">  integrity=<span class="string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span><br><span class="line">  crossorigin=<span class="string">&quot;anonymous&quot;</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">&#x27;jQuery&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line">$(<span class="string">&#x27;.my-element&#x27;</span>).animate(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a>Tree-shaking</h4><blockquote>
<p>这里单独提一下 <code>tree-shaking</code> ,是因为这里有个坑。 <code>tree-shaking</code> 的主要作用是用来清除代码中无用的部分。目前在 <code>webpack4</code> 我们设置 <code>mode</code> 为 <code>production</code> 的时候已经自动开启了<code>tree-shaking</code> 。但是要想使其生效，生成的代码必须是<code>ES6</code>模块。不能使用其它类型的模块如 <code>CommonJS</code> 之流。如果使用 <code>Babel</code> 的话，这里有一个小问题，因为 <code>Babel</code> 的预案（ <code>preset</code> ）默认会将任何模块类型都转译成 <code>CommonJS</code> 类型。修正这个问题也很简单，在 <code>.babelrc</code> 文件或在 <code>webpack.config.js</code> 文件中设置 <code>modules:false</code> 就好了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123; <span class="attr">modules</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;，</span><br><span class="line">      exclude: <span class="regexp">/(node_modules)/</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经历过上面两个系列的洗礼，到现在我们成为了一名合格的 <code>webpack</code> 配置工程师。但是光拧螺丝，自身的可替代性还是很高，下面我们将深入 <code>webpack</code> 的原理中去</p>
<h2 id="手写webpack系列"><a href="#手写webpack系列" class="headerlink" title="手写webpack系列"></a>手写webpack系列</h2><p>经历过上面两个部分，我们已经可以熟练的运用相关的 <code>loader</code> 和 <code>plugin</code> 对我们的代码进行转换、解析。接下来我们自己手动实现 <code>loader</code> 与 <code>plugin</code> ，使其在平时的开发中获得更多的乐趣。</p>
<h3 id="手写-webpack-loader"><a href="#手写-webpack-loader" class="headerlink" title="手写 webpack loader"></a>手写 webpack loader</h3><blockquote>
<p><code>loader</code> 从本质上来说其实就是一个 <code>node</code> 模块。相当于一台榨汁机( <code>loader</code> )将相关类型的文件代码( <code>code</code> )给它。根据我们设置的规则，经过它的一系列加工后还给我们加工好的果汁( <code>code</code> )。</p>
</blockquote>
<h4 id="loader-编写原则"><a href="#loader-编写原则" class="headerlink" title="loader 编写原则"></a><code>loader</code> 编写原则</h4><ul>
<li>单一原则: 每个 <code>Loader</code> 只做一件事；</li>
<li>链式调用: <code>Webpack</code> 会按顺序链式调用每个 <code>Loader</code> ；</li>
<li>统一原则: 遵循 <code>Webpack</code> 制定的设计规则和结构，输入与输出均为字符串，各个 <code>Loader</code> 完全独立，即插即用；</li>
</ul>
<p>在日常开发环境中，为了方便调试我们往往会加入许多 <code>console</code> 打印。但是我们不希望在生产环境中存在打印的值。那么这里我们自己实现一个 <code>loader</code> 去除代码中的 <code>console</code></p>
<blockquote>
<p>知识点普及之 <code>AST</code> 。 <code>AST</code> 通俗的来说，假设我们有一个文件 <code>a.js</code> ,我们对 <code>a.js</code> 里面的1000行进行一些操作处理,比如为所有的 <code>await</code> 增加 <code>try catch</code> ,以及其他操作，但是 <code>a.js</code> 里面的代码本质上来说就是一堆字符串。那我们怎么办呢，那就是转换为带标记信息的对象(抽象语法树)我们方便进行增删改查。这个带标记的对象(抽象语法树)就是AST。这里推荐一篇不错的AST文章 <a href="https://link.zhihu.com/?target=https://segmentfault.com/a/1190000016231512">AST快速入门</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i -D @babel/parser @babel/traverse @babel/generator @babel/types</span><br></pre></td></tr></table></figure>
<ul>
<li>@babel/parser 将源代码解析成 <code>AST</code></li>
<li>@babel/traverse 对 <code>AST</code> 节点进行递归遍历，生成一个便于操作、转换的 <code>path</code> 对象</li>
<li>@babel/generator 将 <code>AST</code> 解码生成 <code>js</code> 代码</li>
<li>@babel/types 通过该模块对具体的 <code>AST</code> 节点进行进行增、删、改、查</li>
</ul>
<p>新建 <code>drop-console.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> t = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=<span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(source,&#123; <span class="attr">sourceType</span>: <span class="string">&#x27;module&#x27;</span>&#125;)</span><br><span class="line">  traverse(ast,&#123;</span><br><span class="line">    <span class="function"><span class="title">CallExpression</span>(<span class="params">path</span>)</span>&#123; </span><br><span class="line">      <span class="keyword">if</span>(t.isMemberExpression(path.node.callee) &amp;&amp; t.isIdentifier(path.node.callee.object, &#123;<span class="attr">name</span>: <span class="string">&quot;console&quot;</span>&#125;))&#123;</span><br><span class="line">        path.remove()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> output = generator(ast, &#123;&#125;, source);</span><br><span class="line">  <span class="keyword">return</span> output.code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  entry:path.resolve(__dirname,<span class="string">&#x27;index.js&#x27;</span>),</span><br><span class="line">  output:&#123;</span><br><span class="line">    filename:<span class="string">&#x27;[name].[contenthash].js&#x27;</span>,</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      use:path.resolve(__dirname,<span class="string">&#x27;drop-console.js&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上在 <code>webpack4</code> 中已经集成了去除 <code>console</code> 功能，在 <code>minimizer</code> 中可配置 <a href="https://link.zhihu.com/?target=https://webpack.js.org/plugins/terser-webpack-plugin/%23root">去除console</a><br>附上官网 <a href="https://link.zhihu.com/?target=https://webpack.docschina.org/contribute/writing-a-loader/">如何编写一个loader</a></p>
</blockquote>
<h3 id="手写webpack-plugin"><a href="#手写webpack-plugin" class="headerlink" title="手写webpack plugin"></a>手写webpack plugin</h3><blockquote>
<p>在 <code>Webpack</code> 运行的生命周期中会广播出许多事件， <code>Plugin</code> 可以监听这些事件，在合适的时机通过 <code>Webpack</code> 提供的 <code>API</code> 改变输出结果。<br>通俗来说：一盘美味的 盐豆炒鸡蛋 需要经历烧油 炒制 调味到最后的装盘等过程，而 <code>plugin</code> 相当于可以监控每个环节并进行操作，比如可以写一个少放胡椒粉 <code>plugin</code> ,监控 <code>webpack</code> 暴露出的生命周期事件(调味)，在调味的时候执行少放胡椒粉操作。<br>那么它与 <code>loader</code> 的区别是什么呢？上面我们也提到了 <code>loader</code> 的单一原则, <code>loader</code> 只能一件事，比如说 <code>less-loader</code> ,只能解析 <code>less</code> 文件， <code>plugin</code> 则是针对整个流程执行广泛的任务。</p>
</blockquote>
<p>一个基本的 <code>plugin</code> 插件结构如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstPlugin</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;firstPlugin options&#x27;</span>, options)</span><br><span class="line">  &#125;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">&#x27;done&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;firstPlugin&#x27;</span>)</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = firstPlugin</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>compiler</code> 、 <code>compilation</code> 是什么？</p>
</blockquote>
<ul>
<li><code>compiler</code> 对象包含了 <code>Webpack</code> 环境所有的的配置信息。这个对象在启动 <code>webpack</code> 时被一次性建立，并配置好所有可操作的设置，包括 <code>options</code> ， <code>loader</code> 和 <code>plugin</code> 。当在 <code>webpack</code> 环境中应用一个插件时，插件将收到此 <code>compiler</code> 对象的引用。可以使用它来访问 <code>webpack</code> 的主环境。</li>
<li><code>compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。当运行 <code>webpack</code> 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code> ，从而生成一组新的编译资源。 <code>compilation</code> 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</li>
</ul>
<p><em><strong><code>compiler</code> 和 <code>compilation</code> 的区别在于</strong></em></p>
<ul>
<li><code>compiler</code> 代表了整个 <code>webpack</code> 从启动到关闭的生命周期，而 <code>compilation</code> 只是代表了一次新的编译过程</li>
<li><code>compiler</code> 和 <code>compilation</code> 暴露出许多钩子，我们可以根据实际需求的场景进行自定义处理</li>
</ul>
<p><a href="hhttps://www.webpackjs.com/api/compiler-hooks/">compiler钩子文档</a><br><a href="https://www.webpackjs.com/api/compilation-hooks/">compilation钩子文档</a></p>
<p>下面我们手动开发一个简单的需求,在生成打包文件之前自动生成一个关于打包出文件的大小信息<br>新建一个 <code>webpack-firstPlugin.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">firstPlugin</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line">    compiler.plugin(<span class="string">&#x27;emit&#x27;</span>,<span class="function">(<span class="params">compilation,callback</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> filename <span class="keyword">in</span> compilation.assets)&#123;</span><br><span class="line">        str += <span class="string">`文件:<span class="subst">$&#123;filename&#125;</span>  大小<span class="subst">$&#123;compilation.assets[filename][<span class="string">&#x27;size&#x27;</span>]()&#125;</span>\n`</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过compilation.assets可以获取打包后静态资源信息，同样也可以写入资源</span></span><br><span class="line">      compilation.assets[<span class="string">&#x27;fileSize.md&#x27;</span>] = &#123;</span><br><span class="line">        source:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> str</span><br><span class="line">        &#125;,</span><br><span class="line">        size:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> str.length</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      callback()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = firstPlugin</span><br></pre></td></tr></table></figure>
<p>如何使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> firstPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack-firstPlugin.js&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> firstPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm run build</code> 即可看到在 <code>dist</code> 文件夹中生成了一个包含打包文件信息的 <code>fileSize.md</code></p>
<blockquote>
<p>上面两个 <code>loader</code> 与 <code>plugin</code> 案例只是一个引导，实际开发需求中的 <code>loader</code> 与 <code>plugin</code> 要考虑的方面很多，建议大家自己多动手尝试一下。</p>
</blockquote>
<p>附上官网 <a href="https://www.webpackjs.com/contribute/writing-a-plugin/">如何编写一个plugin</a></p>
<h2 id="webpack5-0的时代"><a href="#webpack5-0的时代" class="headerlink" title="webpack5.0的时代"></a>webpack5.0的时代</h2><p>无论是前端框架还是构建工具的更新速度远远超乎了我们的想象,前几年的 <code>jquery</code> 一把梭的时代一去不复返。我们要拥抱的是不断更新迭代的 <code>vue</code> 、 <code>react</code> 、 <code>node</code> 、 <code>serverless</code> 、 <code>docker</code> 、 <code>k8s</code> ….<br>不甘落后的 <code>webpack</code> 也已经在近日发布了 <code>webpack 5.0.0 beta 10</code> 版本。在之前作者也曾提过 <code>webpack5.0</code> 旨在减少配置的复杂度，使其更容易上手( <code>webpack4</code> 的时候也说了这句话)，以及一些性能上的提升</p>
<ul>
<li>使用持久化缓存提高构建性能；</li>
<li>使用更好的算法和默认值改进长期缓存（long-term caching）；</li>
<li>清理内部结构而不引入任何破坏性的变化；</li>
<li>引入一些breaking changes，以便尽可能长的使用v5版本。</li>
</ul>
<p>目前来看，维护者的更新很频繁，相信用不了多久webpack5.0将会拥抱大众。感兴趣的同学可以先安装beta版本尝尝鲜。不过在此之前建议大家先对webpack4进行一番掌握,这样后面的路才会越来越好走。</p>
<h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p><a href="https://webpack.docschina.org/">webpack中文</a><br><a href="https://www.webpackjs.com/configuration/">webpackjs</a><br><a href="https://mp.weixin.qq.com/s/OBUcxEFXKQQubP08LO2Uhg">4W字长文带你深度解锁Webpack系列(上)</a></p>
]]></content>
      <categories>
        <category>前端工程化</category>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>微信的H5兼容方案</title>
    <url>/2019/12/31/weichat-h5-compatibility/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近被公司新来的前端问到了一些微信页面的兼容性问题，因为我做微信开发的经验比较少，被问到了真是感到很尴尬，所以在搜到了解决方案告诉了他之后，我又深入的再网上找了一些微信开发中遇到的兼容问题，特此整理，以留后用。</p>
<span id="more"></span>

<h2 id="1、ios端兼容input光标的高度"><a href="#1、ios端兼容input光标的高度" class="headerlink" title="1、ios端兼容input光标的高度"></a>1、ios端兼容input光标的高度</h2><p><em><strong>bug描述：</strong></em><br>这个问题只出现在苹果手机上，在安卓手机上显示没有问题，可以说是非常诡异，简单描述一下就是在input输入框聚焦时，光标大小应该跟字号一直，但是在苹果手机上当点击输入的时候，光标的高度和父盒子的高度一样。<br><em><strong>分析：</strong></em><br>说来主要是习惯导致的问题，通常我们习惯将height和line-height设置成一样的值，这个时候input光标就会整个变得很大。<br><em><strong>解决：</strong></em><br>实际上解决方案也很简单，就是不设置行高，通过padding来控制输入内容与外框的距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; less代码</span><br><span class="line">.input-x&#123;</span><br><span class="line">	height:40px;</span><br><span class="line">	&#x2F;&#x2F; line-height:40px; &#x2F;&#x2F; 此行注释掉</span><br><span class="line">	.input-inline&#123;</span><br><span class="line">		padding: 10px 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做问题就解决了。</p>
<h2 id="2、ios端微信h5页面上下滑动会卡顿，页面会有缺失"><a href="#2、ios端微信h5页面上下滑动会卡顿，页面会有缺失" class="headerlink" title="2、ios端微信h5页面上下滑动会卡顿，页面会有缺失"></a>2、ios端微信h5页面上下滑动会卡顿，页面会有缺失</h2><p><em><strong>bug描述：</strong></em><br>没错又是ios端，当页面高度超过一屏，那么上下滑动时就会出现页面卡顿的情况，而且时有伴随内容不能全部显示的情况。<br><em><strong>分析：</strong></em><br>这里实际上是浏览器内核解析不同导致的问题，在Andriod设备上，微信调用的是Webkit内核，而ios中是使用了Safari的内核，Safari对于滚动事件（overflow-scrolling）会使用原生的控件。而webkit内核则会创建一个UIScrollView来提供给子layer用以渲染。<br><em><strong>解决：</strong></em><br>在做样式重置时，加上下面这句话就能解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css代码</span><br><span class="line">*&#123;</span><br><span class="line">	-webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个方案也有缺陷，就是页面中不能有使用absolute定位的元素，不然布局就错乱了。<br><em><strong>延伸：</strong></em><br>-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.</p>
<ul>
<li>auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。</li>
<li>touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</li>
</ul>
<h2 id="3、ios键盘唤起再收起，页面不会恢复原位"><a href="#3、ios键盘唤起再收起，页面不会恢复原位" class="headerlink" title="3、ios键盘唤起再收起，页面不会恢复原位"></a>3、ios键盘唤起再收起，页面不会恢复原位</h2><p><em><strong>bug描述：</strong></em><br>哎，对的还是ios，问题标题描述的比较清晰了，就是键盘弹出时，页面内容会整体上移，但是收起键盘时本应回归原位的不回去了。—_—|||<br><em><strong>分析：</strong></em><br>固定定位的元素，如果元素内input框聚焦的时候会弹出软键盘，软键盘会占用屏幕面积，失去焦点时软键盘消失，但是仍会占用，页面就会不能恢复原状，也就导致input框不能再次输入了。<br><em><strong>解决：</strong></em><br>在input失去焦点键盘收起时，写一个监听事件，事例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue代码</span><br><span class="line">&lt;input @blur&#x3D;&quot;changeBlur()&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">changeBlur()&#123;</span><br><span class="line">	let ua &#x3D; navigator.userAgent; &#x2F;&#x2F; 获取用户代理</span><br><span class="line">	let app &#x3D; navigator.appVersion; &#x2F;&#x2F; 获取客户端版本信息</span><br><span class="line">	let isIos &#x3D; ua.match(&#x2F;i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F; 判断是否是Ios设备</span><br><span class="line">	if(isIos)&#123;</span><br><span class="line">		setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">			const scrollHeight &#x3D; document.documentElement.scrollTop || document.body.scrollTop || 0</span><br><span class="line">			window.scrollTop(0,Math.max(scrollHeight - 1), 0)</span><br><span class="line">		&#125;,100)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>延伸：</strong></em><br>在iso的微信开发中，页面元素如果用到了position: fixed进行定位，那么键盘收起时，就会被顶上去，第三方输入法也不例外。</p>
<h2 id="4、Android弹出键盘遮挡文本输入框"><a href="#4、Android弹出键盘遮挡文本输入框" class="headerlink" title="4、Android弹出键盘遮挡文本输入框"></a>4、Android弹出键盘遮挡文本输入框</h2><p><em><strong>bug描述：</strong></em><br>刚才说的问题都是Ios端的，实际上Android上也有挺多坑，上面讲到Ios上输入框弹出键盘的问题后，Android中实际也有，只是现象不同；Andriod中弹出键盘后页面不会向上滑动，但是如果输入框在底部的话会直接被挡住。。。<br><em><strong>分析：</strong></em><br>很坑，因为Andriod中输入框focus后，并不会向上滑动，如果靠下就会被挡住。。<br><em><strong>解决：</strong></em><br>实际上跟Ios上处理差不多的方案，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue代码</span><br><span class="line">&lt;input @blur&#x3D;&quot;changeBlur()&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">changeFocus()&#123;</span><br><span class="line">   let ua &#x3D; navigator.userAgent;</span><br><span class="line">	 let app &#x3D; navigator.appVersion;</span><br><span class="line">   let isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1;</span><br><span class="line">   if(isAndroid)&#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">      document.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">      document.activeElement.scrollIntoView();</span><br><span class="line">      &#125;, 500);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>扩展</strong></em><br>Element.scrollIntoView()方法让当前的元素滚动到浏览器窗口的可视区域内。而Element.scrollIntoViewIfNeeded()方法也是用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动</p>
<h2 id="5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败"><a href="#5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败" class="headerlink" title="5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败"></a>5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败</h2><p><em><strong>bug描述：</strong></em><br>Ios的问题真的挺多的。。。</p>
<ul>
<li>在分享页面给A时，没问题，A把链接分享给B的时候就跳转到首页了；</li>
<li>使用Vue-router跳转到第二个页面在分享时候，分享失败；<br>以上两个问题在Android上均没有问题。</li>
</ul>
<p><em><strong>分析：</strong></em><br>jssdk是后端进行签署，前端校验，但是有时跨域，ios是分享以后会自动带上 from=singlemessage&amp;isappinstalled=0 以及其他参数，分享朋友圈参数还不一样，貌似系统不一样参数也不一样，但是每次获取url并不能获取后面这些参数<br><em><strong>解决：</strong></em></p>
<ul>
<li>可以使用改页面this.$router.push跳转，为window.location.href去跳转，而不使用路由跳转，这样可以使地址栏的地址与当前页的地址一样，可以分享成功</li>
<li>把入口地址保存在本地，等需要获取签名的时候再取出来，注意：sessionStorage.setItem(‘href’,href); 只在刚进入单应用的时候保存！（还没测试，有点low）</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>虽然微信H5方式开发想对来说成本比较低，但是有时候坑开始挺多的，但是微信原生开发又增加了成本，很矛盾，目前能做的就是尽量把踩过的坑都记下来，下次别再跳进去了。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>微信</category>
      </categories>
      <tags>
        <tag>兼容性问题</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>npx是什么</title>
    <url>/2020/04/16/what-is-npx/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在阅读一些文章时，经常看到介绍命令的时候用到了 npx 关键字，之前知道有 node 有 npm 但是很少用到 npx ，npx是个啥呢？好奇上网上找了些资料学习了一下，写篇学习笔记记录一下。</p>
<span id="more"></span>
<h2 id="npx-起源"><a href="#npx-起源" class="headerlink" title="npx 起源"></a>npx 起源</h2><p>我从阮一峰的博客中看到介绍 npx 的文章，开头的一句话说明了他诞生的日子。</p>
<blockquote>
<p>npm 从5.2版开始，增加了 npx 命令。</p>
</blockquote>
<p>为了验证阮一峰这里介绍的正确性我特意下了对应的npm版本验证了一下确实如此，而且在网上找到了另一位大佬司徒正美（大佬走好）博客中也对 npx 做了介绍</p>
<blockquote>
<p>最近我在更新 npm 5.2.0 的时候发现会买一送一，自动安装了 npx。</p>
</blockquote>
<p>由此，我可以肯定的告诉大家，npx是npm在5.2.0之后版本推出的一个工具，那么他是干嘛用的呢？</p>
<h2 id="npx-作用"><a href="#npx-作用" class="headerlink" title="npx 作用"></a>npx 作用</h2><p>想要了解一个技术，最好的途经是他的官网，于是我到网上找到了 npx 在 github 上的仓库，地址如下<br><a href="https://github.com/npm/npx#readme">npx仓库</a>，其中对 npx 有这样一段介绍</p>
<blockquote>
<p>DESCRIPTION<br>Executes <command> either from a local node_modules/.bin, or from a central cache, installing any packages needed in order for <command> to run.<br>By default, npx will check whether <command> exists in $PATH, or in the local project binaries, and execute that. If <command> is not found, it will be installed prior to execution.<br>Unless a –package option is specified, npx will try to guess the name of the binary to invoke depending on the specifier provided. All package specifiers understood by npm may be used with npx, including git specifiers, remote tarballs, local directories, or scoped packages.<br>If a full specifier is included, or if –package is used, npx will always use a freshly-installed, temporary version of the package. This can also be forced with the –ignore-existing flag.</p>
</blockquote>
<p>上面这一大段英文我想大家一定看了就头疼，所以为了大家不那么头疼，可以看一下下面我翻译的内容，如果有翻译不对的地方，还请指正。</p>
<blockquote>
<p>解释<br>执行 command 命令，无论从本地（我理解为项目目录）node_modules/.bin 或者从全局缓存中， 安装所需执行的任何包。<br>默认情况下，npx将检查 command 是否存在于 $PATH 中，或者在本地项目二进制文件中，并执行该命令。<br>如果没有找到 command ，它将在执行之前安装。<br>除非指定了 —package 选项，否则npx将根据提供的说明符猜测要调用的二进制文件的名称。<br>npm可以理解的所有包说明符都可以与npx一起使用，包括git说明符、远程tarball、本地目录或作用域包。<br>如果包含完整的说明符，或者使用 ——package 选项，npx将始终使用新安装的包的临时版本。<br>这也可以用 ——ignore-existing 标记强制执行。</p>
</blockquote>
<p>上面这段机翻简直让人无法理解，所以我又去大佬博客下看了下他们的解释</p>
<blockquote>
<p>npx 想要解决的主要问题，就是调用项目内部安装的模块。 – 阮一峰<br>根据 zkat/npx 的描述，npx 会帮你执行依赖包里的二进制文件。 – 司徒正美</p>
</blockquote>
<p>司徒大大文章写的太简洁了，不过他还是举了例子，我进行了一下精简，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">./node_modules/.bin/webpack -v <span class="comment">// =&gt; npx webpack -v</span></span><br></pre></td></tr></table></figure>
<p>简单来说就是找包执行命令的时候不再关注他在哪了，直接就可以用了。</p>
<p>阮一峰老师的文章更像是官网的翻译加理解</p>
<blockquote>
<p>npx 的原理很简单，就是运行的时候，会到node_modules/.bin路径和环境变量$PATH里面，检查命令是否存在。<br>由于 npx 会检查环境变量$PATH，所以系统命令也可以调用。</p>
</blockquote>
<p>另外阮一峰老师还介绍了一个临时安装命令使用的场景，我理解为对上面英语介绍倒数第二句的理解</p>
<h3 id="避免全局安装模块"><a href="#避免全局安装模块" class="headerlink" title="避免全局安装模块"></a>避免全局安装模块</h3><p>除了调用项目内部模块，npx 还能避免全局安装的模块。比如，create-react-app这个模块是全局安装，npx 可以运行它，而且不进行全局安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx create-react-app my-react-app</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码运行时，npx 将create-react-app下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载create-react-app。</p>
<p>下载全局模块时，npx 允许指定版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx uglify-js@3.1.0 main.js -o ./dist/main.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码指定使用 3.1.0 版本的uglify-js压缩脚本。</p>
<p>注意，只要 npx 后面的模块无法在本地发现，就会下载同名模块。比如，本地没有安装http-server模块，下面的命令会自动下载该模块，在当前目录启动一个 Web 服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx http-server</span><br></pre></td></tr></table></figure>

<p>然后阮老师还对官网最后一句话做了解释</p>
<h3 id="–no-install-参数和–ignore-existing-参数"><a href="#–no-install-参数和–ignore-existing-参数" class="headerlink" title="–no-install 参数和–ignore-existing 参数"></a>–no-install 参数和–ignore-existing 参数</h3><p>如果想让 npx 强制使用本地模块，不下载远程模块，可以使用–no-install参数。如果本地不存在该模块，就会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx --no-install http-server</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用–ignore-existing参数。比如，本地已经全局安装了create-react-app，但还是想使用远程模块，就用这个参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx --ignore-existing create-react-app my-react-app</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后对于官网上的 example 阮老师也挑了重点的做了介绍，如选择指定的 node 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx node@0.12.8 -v</span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure>
<p>上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。<br>某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。</p>
<h2 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h2><h3 id="p-参数"><a href="#p-参数" class="headerlink" title="-p 参数"></a>-p 参数</h3><p>-p参数用于指定 npx 所要安装的模块，所以上一节的命令可以写成下面这样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p node@0.12.8 node -v </span><br><span class="line">v0.12.8</span><br></pre></td></tr></table></figure>
<p>上面命令先指定安装<a href="mailto:&#x6e;&#x6f;&#100;&#x65;&#x40;&#x30;&#46;&#49;&#50;&#x2e;&#56;">&#x6e;&#x6f;&#100;&#x65;&#x40;&#x30;&#46;&#49;&#50;&#x2e;&#56;</a>，然后再执行node -v命令。<br>-p参数对于需要安装多个模块的场景很有用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>
<h3 id="c-参数"><a href="#c-参数" class="headerlink" title="-c 参数"></a>-c 参数</h3><p>如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell 解释。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay <span class="string">&#x27;cowsay hello | lolcatjs&#x27;</span></span><br><span class="line"><span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，cowsay hello | lolcatjs 执行时会报错，原因是第一项 cowsay 由 npx 解释，而第二项命令localcatjs由 Shell 解释，但是lolcatjs并没有全局安装，所以报错。</p>
<p>-c参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -p lolcatjs -p cowsay -c <span class="string">&#x27;cowsay hello | lolcatjs&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-c参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run env | grep npm_</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-c参数可以把这些 npm 的环境变量带入 npx 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npx -c <span class="string">&#x27;echo &quot;$npm_package_name&quot;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码会输出当前项目的项目名。</p>
<h2 id="执行-GitHub-源码"><a href="#执行-GitHub-源码" class="headerlink" title="执行 GitHub 源码"></a>执行 GitHub 源码</h2><p>npx 还可以执行 GitHub 上面的模块源码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行 Gist 代码</span></span><br><span class="line">$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行仓库代码</span></span><br><span class="line">$ npx github:piuccio/cowsay hello</span><br></pre></td></tr></table></figure>
<p>注意，远程代码必须是一个模块，即必须包含package.json和入口脚本。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>因为还没有实际使用过的经验，所以更多的内容从其他大佬哪里白嫖来的知识，做个笔记以观后效。</p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>npx</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 0.1 + 0.2 != 0.3</title>
    <url>/2020/01/03/why-0.1-plus-0.2-not-equals-0.3/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。</p>
<p>我们都知道计算机表示十进制是采用二进制表示的，所以 0.1 在二进制表示为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (0011) 表示循环</span><br><span class="line">0.1 &#x3D; 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure>
<p>那么如何得到这个二进制的呢，我们可以来演算下</p>
<p>小数算二进制和整数不同。乘法计算时，只计算小数位，整数位用作每一位的二进制，并且得到的第一位为最高位。所以我们得出 <code>0.1 = 2^-4 * 1.10011(0011)</code>，那么 <code>0.2</code> 的演算也基本如上所示，只需要去掉第一步乘法，所以得出 <code>0.2 = 2^-3 * 1.10011(0011)</code>。</p>
<p>回来继续说 <code>IEEE 754</code> 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为 <code>0.1</code> 和 <code>0.2</code> 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。</p>
<p>所以 <code>2^-4 * 1.10011...001</code> 进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code> 。那么把这两个二进制加起来会得出 <code>2^-2 * 1.0011(0011 * 11次)0100</code> , 这个值算成十进制就是 <code>0.30000000000000004</code></p>
<p>下面说一下原生解决办法，如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">parseFloat((0.1 + 0.2).toFixed(10))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>巧妙利用Acitons进行博客的自动构建</title>
    <url>/2019/12/27/Actions/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙活了很久很久，终于不那么忙了，也终于想起来我还有个博客没有运行，哎，虽然用Hexo可以享受Github提供的免费的空间和域名，但是命令行敲代码的方式实现博客编写还是有些不方便，尤其是需要编程环境的时候，最近公司在用CICD的方式对代码进行构建，我就在想有没有一种方式让博客也可以变成这样，于是我就在网上搜<code>Github</code> <code>Hexo</code> <code>自动构建</code> 这些个词，还真让我搜到了一种方法而且还是Github自己提供的，下面隆重请出 <code>GitHub Actions</code>。</p>
<span id="more"></span>

<h2 id="GitHub-Actions-是什么"><a href="#GitHub-Actions-是什么" class="headerlink" title="GitHub Actions 是什么"></a>GitHub Actions 是什么</h2><p>GitHub Actions 由 GitHub 官方推出的工作流工具。典型的应用场景应该是 CI/CD，类似 Travis 的用法。如果不知道 CI/CD&amp;Travis 感兴趣的建议去了解一下，下面不展开说明，直接说怎么用就好。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在使用 <code>GitHub Actions</code> 之前我们先来看看我们有什么；<br>首先我们有一个放博客程序的地方，我这里是叫做 <code>blog-source</code> ，另外呢有一个通过 hexo g 创建出来的静态网站，为了存放它而建的另一个仓库，我这里是叫做<code>lixuguang.github.io</code>,也就是说我们现在是有这样两个仓库。<br>|仓库|作用|<br>|-|-|<br>|blog-source|放博客源代码|<br>|lixuguang.github.io|放博客生成代码|</p>
<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>因为 <code>GitHub Actions</code> 它需要访问我的 <code>blog-source</code> 仓库的代码所以必须要有密钥，密钥大家应该熟悉了，创建博客的时候也是创建了一个公钥和私钥用来在本地往 <code>lixuguang.github.io</code> 这个仓库提交代码<br>这里呢我们用下面的命令生成密钥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -f ~&#x2F;.ssh&#x2F;github-actions-deploy # 连按三次回车即刻</span><br></pre></td></tr></table></figure>
<p>命令执行完成后，我们会得到两个文件 <code>github-actions-deploy</code> 和 <code>github-actions-deploy.pub</code> 两个文件，第一个是私钥，第二个是公钥。<br>|名称|解释|<br>|-|-|<br>|github-actions-deploy|私钥|<br>|github-actions-deploy.pub|公钥|</p>
<p>接下来的步骤一定要好好看，因为我在这个地方被卡住好多次，就是因为有的文章说的并不正确，或者至少是讲的不够仔细，这里我会仔细地说明一下。</p>
<h2 id="配置-GitHub-仓库"><a href="#配置-GitHub-仓库" class="headerlink" title="配置 GitHub 仓库"></a>配置 GitHub 仓库</h2><h3 id="配置博客源代码仓库"><a href="#配置博客源代码仓库" class="headerlink" title="配置博客源代码仓库"></a>配置博客源代码仓库</h3><p>我这里的源代码是放在 <code>blog-source</code> 中，所以我现在要给源代码仓库配置<code>私钥</code>，配置过程如下：<br>打开 <code>blog-source</code> 仓库，选择 <code>settings</code>，然后选中 <code>secrets</code> ， 再点击 <code>Add new secrets</code>，照着下面填写内容<br>|字段|值|<br>|-|-|<br>|Name|HEXO_DEPLOY_PRI（名称自动构建时有用）|<br>|Value|github-actions-deploy|</p>
<h3 id="配置博客源代码仓库-1"><a href="#配置博客源代码仓库-1" class="headerlink" title="配置博客源代码仓库"></a>配置博客源代码仓库</h3><p>我这里生成的博客静态代码是放在 <code>lixuguang.github.io</code> 中，所以我现在要给静态代码仓库配置<code>公钥</code>，配置过程如下：<br>打开 <code>lixuguang.github.io</code>，选择 <code>settings</code>，然后选中 <code>keys</code>，再点击 <code>Add deploy key</code>，照着下面填写内容<br>|字段|值|<br>|-|-|<br>|Title|HEXO_DEPLOY_PUB|<br>|Key|github-actions-deploy.pub|</p>
<h2 id="编写-Actions-脚本"><a href="#编写-Actions-脚本" class="headerlink" title="编写 Actions 脚本"></a>编写 Actions 脚本</h2><p>经过上面一系列的准备操作，终于来到了编写自动构建脚本的环节，构建脚本如下，如果按照上面我做的操作一步步来的话，那么这一步你可以直接copy啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Deploy Blog</span><br><span class="line"></span><br><span class="line">on: [push] # 当有新push时运行</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build: # 一项叫做build的任务</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest # 在最新版的Ubuntu系统下运行</span><br><span class="line">    </span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout # 将仓库内master分支的内容下载到工作目录</span><br><span class="line">      uses: actions&#x2F;checkout@v1 # 脚本来自 https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;checkout</span><br><span class="line">      </span><br><span class="line">    - name: Use Node.js 10.x # 配置Node环境</span><br><span class="line">      uses: actions&#x2F;setup-node@v1 # 配置脚本来自 https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;setup-node</span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;10.x&quot;</span><br><span class="line">    </span><br><span class="line">    - name: Setup Hexo env</span><br><span class="line">      env:</span><br><span class="line">        HEXO_DEPLOY_PRI: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125; # 这里是上面配置的私钥名称</span><br><span class="line">      run: |</span><br><span class="line">        # set up private key for deploy</span><br><span class="line">        mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class="line">        echo &quot;$HEXO_DEPLOY_PRI&quot; | tr -d &#39;\r&#39; &gt; ~&#x2F;.ssh&#x2F;id_rsa # 配置秘钥</span><br><span class="line">        chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</span><br><span class="line">        # set git infomation</span><br><span class="line">        git config --global user.name &#39;lixuguang&#39; # 换成你自己的名字</span><br><span class="line">        git config --global user.email &#39;lixuguang@gmail.com&#39; # 换成你自己的邮箱</span><br><span class="line">        # install dependencies</span><br><span class="line">        npm i -g hexo-cli # 安装hexo</span><br><span class="line">        npm i</span><br><span class="line">  </span><br><span class="line">    - name: Deploy</span><br><span class="line">      run: |</span><br><span class="line">        # publish</span><br><span class="line">        rm -rf .deploy_git # 如果上次构建失败这句命令会清除上次失败的代码</span><br><span class="line">        hexo generate &amp;&amp; hexo deploy # 执行部署程序</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>通过以上这些步骤的操作，如果没什么意外的话，博客的自动构建就完成了，之后只要你提交新的文章到博客源代码仓库，它将自动帮你生成并发送到博客的静态代码仓库，再也不用执行hexo g -d啦，如果这篇文章对你有用，欢迎follow我或打赏一下这篇文章，感谢阅读。</p>
<p>ps：这里有个小坑需要注意一下，因为博客的皮肤也是另外一个git仓库，如果你在本地构建好用但是线上构建博客不显示了，需要注意下是不是皮肤没有上传到博客源码仓库，这里我遇到了，希望你不会因此困扰，拜拜~</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
        <category>博客技巧</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始：学习Cordova（一）</title>
    <url>/2020/11/10/learn-cordova-1/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很长时间没有写博客了，因为最近换了工作，原来的技术栈基本上都换了，现在接触了很多新的技术栈，<code>Cordova</code> 就是其中之一。</p>
<p>接下来这篇文章就是我的学习笔记，以供回顾，写的不好请勿拍砖。</p>
<span id="more"></span>
<h2 id="一、What-is-Cordova？-Cordova是个啥？"><a href="#一、What-is-Cordova？-Cordova是个啥？" class="headerlink" title="一、What is Cordova？ Cordova是个啥？"></a>一、What is Cordova？ Cordova是个啥？</h2><p><img src="https://ftp.bmp.ovh/imgs/2020/11/b06130e60ab12a42.png" alt="Logo"><br>移动端开发和 <code>Web</code> 开发有一些不一样，<code>Web</code> 端开发面向的是浏览器，而移动端开发面向的是各种移动设备，那么针对各种移动设备提供的 <code>SDK</code> 进行开发的话，我们通常称之为***<code>原生开发</code>***，原生开发虽然通常调用底层 <code>Api</code> ，性能更好，但是因为不同移动终端底层技术不一样，所以每种设备都要单独开发，这样开发成本和能力要求都比较高，所以通常都会有一些框架来兼容各种平台，就好比 <code>Java</code> 虚拟机可以运行在 <code>Mac/Windows/Linux</code> 一样，为了能够写一套移动端代码可以在各种设备中使用，于是乎就有了 <code>Cordova</code> 。</p>
<p>上面说了这么一堆废话，其实简言之，***<code>Cordova</code> 就是提供了跨设备调用底层Api的移动端开发框架（这种开发方式又叫做Hybird 模式）***</p>
<p>知道这一点应该就够了，当然这是我认为的。</p>
<p><code>Cordova</code> 的官网地址如下</p>
<blockquote>
<p><a href="https://cordova.apache.org/">https://cordova.apache.org/</a></p>
</blockquote>
<p>其实从这里就可以看出， <code>Cordova</code> 是 <code>Apache</code> 基金下的一个项目，其官网是这样介绍它的</p>
<blockquote>
<p>Mobile apps with HTML, CSS &amp; JS<br>Target multiple platforms with one code base<br>Free and open source</p>
</blockquote>
<p>翻译成中文的话就是</p>
<blockquote>
<p>使用 <code>Html</code> ，<code>CSS</code> 和 <code>JS</code> 进行移动端应用开发<br>一份代码多平台使用<br>免费并且开源</p>
</blockquote>
<p>三句话解释了 <code>Cordova</code> 的三个方面，</p>
<ul>
<li>使用前端技术开发-对前端开发友好</li>
<li>跨平台-节省开发工时，降低开发难度-从图标看支持 <code>Android/IOS/WP</code>三大平台</li>
<li>免费不用解释开源的话意味着会有很多人贡献代码</li>
</ul>
<p>以上奠定了 <code>Cordova</code> 强大及流行的基础。</p>
<h2 id="二、快速上手"><a href="#二、快速上手" class="headerlink" title="二、快速上手"></a>二、快速上手</h2><p>在使用 <code>Cordova</code> 做移动端开发之前需要做一些环境准备工作，首先要安装 <code>Node</code> 以及它携带的 <code>Npm</code> 包管理器，这个现代的前端开发应该都知道，我这里就不多说了，装它就完了。</p>
<p>装好之后我们就要用 <code>Npm</code> 全局安装一下 <code>Cordova</code> 项目的依赖，命令很简单；</p>
<p>方便的话还要装一下 <code>Git</code> ，因为一些命令要在 <code>git-cmd</code> 上执行，当然管理代码也是需要它的，所以装吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g cordova</span><br></pre></td></tr></table></figure>
<p>就这么简单就可以开发 <code>Cordova</code> 应用了，接下来我们要创建一个项目，创建项目的命令也十分简单。在命令行工具中输入下面的命令你就创建了一个 <code>Cordova</code> 的应用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova create &lt;path&gt; <span class="comment">// 这里的path是项目的路径</span></span><br></pre></td></tr></table></figure>
<p>如果要查看创建项目时还能设置什么参数你可以执行下面的命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova help create</span><br></pre></td></tr></table></figure>
<p>怎么样是不是超级简单。<br>做了上面的工作你就创建了一个具备基本功能的 <code>Cordova</code> 项目，接下来我们要给项目配置一些东西。</p>
<p>首先刚才讲到了， <code>Cordova</code> 是一个跨平台的框架，那么你的项目要适配什么平台你需要进行一些配置， <code>cd</code> 到项目目录下执行下面的命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova platform add &lt;platform name&gt; <span class="comment">// platform name 为适配平台的名称</span></span><br></pre></td></tr></table></figure>
<p>如果不知道名称是什么命令行工具也贴心的给了查询用的命令，通过此命令你可以看到你安装了什么平台的适配，有哪些可以用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova platform</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行了这个命令你将看到下面这样的 <code>list</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">Installed platforms:</span></span><br><span class="line"><span class="comment">Available platforms:</span></span><br><span class="line"><span class="comment">  android ^9.0.0</span></span><br><span class="line"><span class="comment">  browser ^6.0.0</span></span><br><span class="line"><span class="comment">  electron ^1.0.0</span></span><br><span class="line"><span class="comment">  windows ^7.0.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>项目也创建了，简单的配置工作也完成了，我们可以启动项目看一下效果了，那么我们就该执行运行项目的命令了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova run &lt;platform name&gt; <span class="comment">// platform name 适配平台的名称</span></span><br></pre></td></tr></table></figure>
<p>到这我们就快速的创建并运行起了一个 <code>Cordova</code> 的工程。</p>
<h3 id="小Tip"><a href="#小Tip" class="headerlink" title="小Tip"></a>小Tip</h3><p>如上执行启动命令后，默认会启动<em><strong>8000</strong></em>端口，如果被占用的话可以通过增加命令行参数的形式改变端口号，参数如下设置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova run browser --target=chrome --port=<span class="number">9090</span></span><br></pre></td></tr></table></figure>
<p>以上就可以自定义端口及浏览器启动应用了。</p>
<h2 id="三、详细了解"><a href="#三、详细了解" class="headerlink" title="三、详细了解"></a>三、详细了解</h2><h3 id="1、概览"><a href="#1、概览" class="headerlink" title="1、概览"></a>1、概览</h3><p>官网开头介绍了 <code>Cordova</code> 的身世和适用范围，前面开头已经讲过了不想再讲，直接看看 <code>Cordova</code> 的架构设计图。<br><img src="https://cordova.apache.org/static/img/guide/cordovaapparchitecture.png" alt="此处是个架构图"></p>
<center>Cordova 架构图</center>

<p>这个图理解起来不难，大的方面是两个部分，底层是 <code>MobileOS</code> ，也就是手机的操作系统本身，上层是由 <code>Cordova</code> 构建的框架；</p>
<p><code>Cordova</code> 内部的话是两层结构：</p>
<ul>
<li>上层的话是由前端代码构成的 <code>WebApp</code> 部分；</li>
<li>下层是 <code>Cordova</code> 的视图渲染引擎，它为 <code>WebApp</code> 提供了 <code>HtmlApi</code> 和 <code>CordovaApi</code> ；</li>
</ul>
<p>也就是说我们可以调用 <code>html</code> 的原生 <code>Api</code> 也可以使用 <code>Cordova</code> 提供的 <code>jsApi</code> ；</p>
<p><code>Cordova</code> 还提供了丰富的插件系统；通过 <code>Cordova</code> 的视图引擎调用 <code>Cordova</code> 的 <code>NativeApi</code> 来调用一些 <code>Cordova</code> 提供好的调用设备的信息的 <code>Api</code> ，另外也可以调用一些用户自定义的 <code>Api</code> ；</p>
<p><code>Cordova</code> 视图引擎和插件系统再将上层的需求通过 <code>MobileOS</code> 开放的 <code>Api</code> 能力实现具体功能，由此完成了整个 <code>Cordova</code> 框架的使用；</p>
<p>总的来说这个原理跟大多数跨平台的框架原理都类似，由框架提供统一的 <code>Api</code> 能力，再由框架处理不同平台的兼容，这里特别之处在于渲染引擎可以允许使用前端原生的 <code>Api</code> ，这将大大降低开发的难度。</p>
<h4 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h4><p>说到移动端开发，不知道 <code>WebView</code> 应该是不可能的，在原生移动应用中，<code>WebView</code> 就是移动应用内部嵌入的一个‘浏览器’，它可以允许你使用前端技术展示内容。</p>
<h4 id="WebApp"><a href="#WebApp" class="headerlink" title="WebApp"></a>WebApp</h4><p><code>WebApp</code> 跟 <code>WebView</code> 两个词有些像，事实上它们也确实有些关系，<code>WebApp</code> 从名字就可以看出是使用 <code>Web</code> 技术开发的 <code>App</code> ，那么它跟 <code>WebView</code> 是什么关系呢，打个比方，<code>WebView</code> 就是个快递盒子， <code>WebApp</code> 就是你买的商品，一个是<em><strong>容器</strong></em>，一个是<em><strong>内容</strong></em>；这样说应该就明白了吧，通过前端技术开发的 <code>App</code> 通过 <code>WebView</code> 嵌入到 <code>App</code> 中，就可以带给用户原生应用的体验，忘了说 <code>WebApp</code> 是只能用浏览器访问的 <code>App</code> ；</p>
<p>和纯 <code>WebApp</code> 不同，嵌入到 <code>WebView</code> 中的 <code>WebApp</code> 需要有一个配置文件，***<code>config.xml</code>*** ，它在项目的根目录下，说明了应用的一些信息，这个文件必不可少！！！</p>
<h4 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h4><p>刚刚在上面的架构图中我们介绍了 <code>Cordova</code> 的插件系统，它提供了我们通过 <code>js</code> 调用 <code>MobileApi</code> 的能力，如电源/相机/联系人等等；<br>官方维护了核心的功能，当然如果你愿意也可以调用一些第三方提供的插件，你可以方便的通过 <code>npm</code> 包管理器安装；</p>
<p><em><strong>但是有一点必须要说</strong></em>：项目创建后默认是不带任何插件的，即使是官方的核心插件也是需要你自己导入进去，第三方的更不用说了，另外<code>Cordova</code> 只提供了功能 <code>Api</code> 并不包含任何的 <code>UI</code> 部件和 <code>MV</code> 框架（你可以根据自己喜欢使用 <code>Angular</code> 或者 <code>Vue</code> 或者其他什么都可以），这一点要牢记。</p>
<h4 id="开发工作流"><a href="#开发工作流" class="headerlink" title="开发工作流"></a>开发工作流</h4><p>使用 <code>Cordova</code> 开发 <code>MobileApp</code> 的时候即可以开发<strong>多个</strong>平台的 <code>App</code> （一次开发多平台可用，降低开发成本），也可以专注开发<strong>某一</strong>平台的<code>App</code> （使用前端技术开发，降低开发难度），因此开发工作流也分为两种：</p>
<h5 id="跨平台-CLI-的工作流"><a href="#跨平台-CLI-的工作流" class="headerlink" title="跨平台(CLI)的工作流"></a>跨平台(CLI)的工作流</h5><p>官网上说了很多，也不难理解，这里用我自己的话说就是， <code>Cordova</code> 提供了一个牛叉的 <code>CLI</code> 工具，它可以自动的完成一次编码多平台构建的事，你只需要按照它说的方式开发就行。：）</p>
<h5 id="平台为中心的工作流"><a href="#平台为中心的工作流" class="headerlink" title="平台为中心的工作流"></a>平台为中心的工作流</h5><p>这里不得不说我没有看很明白，但是结合下面的注意事项我是这样理解的，因为只为某一平台服务，所以有一些针对此平台的特殊的功能或者插件你就可以使用了（虽然不太清楚为什么这么做，如果你知道告诉我，谢谢），<strong>但是一旦使用了这种开发方式，那么就回不到跨平台开发了</strong>，因为你使用了针对某一平台才能调用的代码，这也不难理解，从字里行间感觉就是不建议使用这种开发工作流（好的好的，知道了）。</p>
<p>好的，接下来开发 <code>App</code> 啦；</p>
<h3 id="2、开发应用"><a href="#2、开发应用" class="headerlink" title="2、开发应用"></a>2、开发应用</h3><p>快速上手中已经介绍了如何准备、创建和启动应用，如何添加平台，这里就不多说了。说些没讲过的。</p>
<p>上面说过检查目前平台安装情况的话可以使用下面的命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova platforms</span><br></pre></td></tr></table></figure>
<p>我们也可以使用另一个命令来看，我试验了一下，效果是一样的。。。（问号脸，一样的为什么搞两个命令）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova platform ls</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事后我发现，无论我使用的命令是 <code>platform</code> 还是 <code>platforms</code> 加不加 <code>ls</code> 都可以查到当前安装的平台。。。 啊~兼容性好强。</p>
</blockquote>
<p>每执行一次 <code>add</code> 命令，你就会发现工程目录下的 <code>platforms</code> 目录下就对应生成了一个对应平台的文件夹，切勿手贱删除，你虽然删除了文件夹，但是各处设置的 <code>platform</code> 并没有去掉，会导致报错，如果要删除请使用 <code>remove</code> 命令。 想知道还有哪些命令的话就看下面的链接吧。⇒ <a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-platform-command">命令大全</a></p>
<h3 id="安装构建的先决条件"><a href="#安装构建的先决条件" class="headerlink" title="安装构建的先决条件"></a>安装构建的先决条件</h3><p>因为 <code>Cordova</code> 的底层还是要调用 <code>MobileOS</code> 的接口，所以各平台的 <code>SDK</code> 是必须要装的，当然这里指的是你要进行构建的平台，比如你要构建 <code>Android</code> 应用，那么你就要装 <code>Android</code> 的 <code>SDK</code> ，<code>IOS</code> 同理。<strong>这里有一个例外</strong><code>broswer</code>平台是不需要依赖其他 <code>SDK</code> 的（明明是开发 <code>APP</code> ，这里只是为了验证画面比较方便）<br>要看你是否满足了构建需要的依赖，可以执行下面的命令查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova requirements</span><br></pre></td></tr></table></figure>
<p>执行完后你会得到如下结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Requirements check results <span class="keyword">for</span> android:</span><br><span class="line">Java JDK: installed .</span><br><span class="line">Android SDK: installed</span><br><span class="line">Android target: installed android-<span class="number">19</span>,android-<span class="number">21</span>,android-<span class="number">22</span>,android-<span class="number">23</span>,Google Inc.:Google Apis:<span class="number">19</span>,Google Inc.:Google Apis (x86 System Image):<span class="number">19</span>,Google Inc.:Google Apis:<span class="number">23</span></span><br><span class="line">Gradle: installed</span><br><span class="line"></span><br><span class="line">Requirements check results <span class="keyword">for</span> ios:</span><br><span class="line">Apple OS X: not installed</span><br><span class="line">Cordova tooling <span class="keyword">for</span> iOS requires Apple OS X</span><br><span class="line"><span class="built_in">Error</span>: Some <span class="keyword">of</span> requirements check failed</span><br></pre></td></tr></table></figure>
<p>这样你就可以清楚的知道自己需要安装哪些依赖才能完成对应平台的构建，简直方便的不要不要的。<br>具体想知道不同的平台都依赖些什么，你可以参见下面的链接；</p>
<ul>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#requirements-and-support">Android平台的要求</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/ios/index.html#requirements-and-support">iOS平台的要求</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/win8/index.html#requirements-and-support">Windows平台的要求</a></li>
</ul>
<h3 id="构建-App"><a href="#构建-App" class="headerlink" title="构建 App"></a>构建 <code>App</code></h3><p>在 <code>create</code> 项目之后，项目的根目录下会生成一个 <code>www</code> 目录，这个目录包含了 <code>webapp</code> 的入口页面 <code>index.html</code> ，入口文件的话是 <code>www/js/index.js</code> 文件的 <code>deviceready</code> 事件中。</p>
<p>如果要构建代码的话，执行下面的命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova build</span><br></pre></td></tr></table></figure>
<p>这个命令会构建你安装的所有平台，如果只想构建某一平台的话，可以把平台的名字加在命令后面，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova build ios</span><br></pre></td></tr></table></figure>
<p>如果想了解更多的参数的话，可以看一下后面的链接。⇒ <a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-build-command">更多参数</a></p>
<h3 id="测试-App"><a href="#测试-App" class="headerlink" title="测试 App"></a>测试 <code>App</code></h3><p>构建完 <code>App</code> 之后我们就可以测试了，通常各平台的 <code>SDK</code> 中会提供模拟器，我们只需要执行下面的命令就可以启动模拟器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova emulate android</span><br></pre></td></tr></table></figure>
<p>当然如果你觉得用实机查看更自然一些的话，也可以把手机插上数据线与电脑建立连接，然后执行下面的命令就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova run android</span><br></pre></td></tr></table></figure>
<p>上面演示的是 <code>Android</code> 的 <code>App</code> 测试过程，每个平台虽然基本类似，但还是有出入，所以，下面提供了不同平台的调试方法，供你预览。</p>
<ul>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/platforms/android/index.html#setting-up-an-emulator">设置Android模拟器</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-run-command">Cordova run 命令参考文档</a></li>
<li><a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-emulate-command">Cordova emulate 命令参考文档</a></li>
</ul>
<h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><p>如果只是开发一个 <code>Cordova</code> 框架的 <code>WebApp</code> ，那么你不需要装任何插件，直接用前端技术开发就好了，但是应该没人会这么做吧，毕竟开发这个的目的就是为了跨平台开发原生级移动 <code>App</code> ，因此要调用移动设备的各种功能就必须安装插件。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p><code>Cordova</code> 插件是一些使用 <code>Javascript</code> 调用原生 <code>SDK</code> 功能的包；<br>你可以使用两种方式找到你想要的插件</p>
<ol>
<li>通过 <code>Cordova</code> 提供的包管理平台 ⇒ <a href="http://cordova.axuer.com/plugins/">插件搜索页</a></li>
<li>通过命令行搜索 <em><strong><code>cordova plugin search camera</code></strong></em></li>
</ol>
<p>选好你要安装的插件之后你需要执行下面的命令来安装它</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova plugin add &lt;plugin name&gt; <span class="comment">// 如 cordova plugin add cordova-plugin-chrome-apps-proxy</span></span><br></pre></td></tr></table></figure>
<p>如果你的包没有发布在 <code>Cordova</code> 的平台上，也可以使用 <code>git</code> 地址来安装。<br>另外 <code>Cordova</code> 还非常贴心的提供了一个工具 <code>Plugman</code> 来帮助开发者更好的管理 <code>Cordova</code> 插件。⇒ <a href="http://cordova.axuer.com/docs/zh-cn/latest/plugin_ref/plugman.html">Plugman参考</a></p>
<p>如果要查看你安装了哪些插件可以使用下面任意一种命令都可以。（咱也不知道为啥提供这么多方式，反正好用无脑）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugin ls</span><br><span class="line">plugin list</span><br><span class="line">plugin</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">$ cordova plugin ls</span></span><br><span class="line"><span class="comment">cordova-plugin-whitelist 1.2.1 &quot;Whitelist&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>如果想知道更多关于 <code>plugin</code> 的命令参数，可以看右边的链接 ⇒ <a href="http://cordova.axuer.com/docs/zh-cn/latest/reference/cordova-cli/index.html#cordova-plugin-command">plugin参数</a></p>
<h4 id="使用-merges-自定义每个平台"><a href="#使用-merges-自定义每个平台" class="headerlink" title="使用 merges 自定义每个平台"></a>使用 <code>merges</code> 自定义每个平台</h4><p>虽然可以用一套代码来构建多个平台，但一些平台会有自己的特点，就好像 <code>Chrome</code> 浏览器默认的字体大小与 <code>IE</code> 的不同， <code>Android</code> 与 <code>IOS</code> 也有不一样的地方，这种情况下去改 <code>www</code> 目录下的文件显然是不合适的，所以 <code>Cordova</code> 提供了 <code>merges</code> 方式来适配不同平台各自的特别处理，你要做的就是在项目的根目录下创建一个 <code>merges</code> 目录，比如你要适配 <code>Android</code> ，你就可以在 <code>merges</code> 下创建一个 <code>android</code> 目录，然后在下面或覆盖或添加新的资源。（这里官网没有说 <code>merges</code> 在哪里创建，试验后发现是在根目录下）</p>
<h4 id="更新-Cordova-和你的项目"><a href="#更新-Cordova-和你的项目" class="headerlink" title="更新 Cordova 和你的项目"></a>更新 <code>Cordova</code> 和你的项目</h4><p>如果你要更新你的 <code>Cordova</code> （通常不建议这么干，当然你知道后果并想要使用新的特性或者修正 <code>bug</code> 除外），那么你需要执行一下 <code>update</code> 命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo npm update -g cordova</span><br></pre></td></tr></table></figure>
<p>当然你也可以指定更新到什么版本（这都是 <code>npm</code> 的知识了）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo npm install -g cordova@<span class="number">3.1</span><span class="number">.0</span>-<span class="number">0.2</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>你也可以使用下面的命令查看当前的版本（还是 <code>npm</code> 的知识）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm info cordova version</span><br></pre></td></tr></table></figure>
<p>你是不是以为这样就可以了，不好意思还不行，你还需要把各个平台进行一下升级</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cordova platform update android --save</span><br><span class="line">cordova platform update ios --save</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其实这也好理解，你都已经轿车换 <code>SUV</code> 了，总不能还用原来的车轱辘吧，只是我希望能不能在换车的时候一块儿把车轱辘换了（这里的意思是希望直接自动化处理了）</p>
<p>到这里你的第一个 <code>App</code> 就已经开发好了，是不是还有点成就感。</p>
<h3 id="一些参考资料"><a href="#一些参考资料" class="headerlink" title="一些参考资料"></a>一些参考资料</h3><p>到这里一个简单的基于 <code>Cordova</code> 搭建的 <code>App</code> 就实现了，当然一个 <code>App</code> 绝不这么简单，各平台的 <code>SDK</code> 安装也没那么简单，但这不是本篇文章要说的事了，下一篇文章我会说说如何应对各种不同的开发平台，在这之前还请你看一下 <code>Cordova</code> 都支持哪些平台，具体看一下下面的链接。</p>
<p>好了，今天就先写到这里，下篇文章我们再见。</p>
<p><a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/support/index.html">平台支持</a></p>
<p>（待续…）</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始：学习Ionic（一）</title>
    <url>/2020/11/11/learn-ionic-1/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在移动 <code>App</code> 开发领域，有一个框架非常知名，每每面试都会被问起，“你用过 <code>Ionic</code> 么？”，是的，就是 <code>Ionic</code> 框架。</p>
<p>之前已经学习过了 <code>Cordova</code> ，它和 <code>Ionic</code> 可以说是一对黄金搭档，一个面向 <code>MobileOS</code> ，一个面向 <code>UI</code> ，很多人搞不清楚它们之间的区别，没关系，回头我再抽时间讲一下，今天我们主要来认识一下 <code>Ionic</code>。</p>
<p>好戏开始：）</p>
<span id="more"></span>
<h2 id="Ionic-简介"><a href="#Ionic-简介" class="headerlink" title="Ionic 简介"></a>Ionic 简介</h2><p>学一门技术，我们首先要知道它是谁，能干啥，有啥好处。要了解一门新技术最好的方式就是去它的官网看看。<br>（一言不合丢给你一个官网 ⇒ <a href="https://ionicframework.com/">官网</a>）</p>
<blockquote>
<p>One codebase.<br>Any platform.<br>Now in Vue.</p>
</blockquote>
<p>翻译过来是这样的</p>
<blockquote>
<p>一份代码<br>任何平台<br>现在支持Vue</p>
</blockquote>
<p>看着是不是眼熟，嗯，跟 <code>Cordova</code> 的口号何其相似，目标都是跨平台，只是 <code>Cordova</code> 跨的是 <code>MobileOS</code> 而 <code>Ionic</code> 跨的是前端框架。<br>最下面一句 <code>Now in Vue</code> 像是在说，“嗯，我也支持Vue了（Vue发展太快了，不能掉队）”，要知道，最开始的 <code>Ionic</code> 是妥妥的 <code>Angular</code> 派，不过无所谓，管他黑猫白猫，能完成任务就是好猫。</p>
<p>再往下看你会看到，巴拉巴拉说了一堆好处，比如开发迅速啊，组件优美且丰富啊，社区强大啊，还有跨平台（支持原生 <code>js</code> ，<code>Angular</code> ，<code>Vue</code> ，nice~），另外还提供了 <code>native</code> 的组件来直接调用移动设备的功能，可以说是相当强大了。</p>
<p>好了，看完了介绍，我们赶紧快速上手吧。</p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>在使用<code>Ionic</code>做开发还是要做一些准备工作，<code>node</code>，<code>git</code>都是必不可少的，所以请先行准备好。</p>
<p>目前，<code>Ionic</code>提供了两种创建工程的方式:</p>
<ul>
<li>一种用官方的话说叫<code>StepByStep</code>，看过之后我理解就是通过命令的方式，一步步来；</li>
<li>另一种的话是官方提供了一个向导工具，就跟安装软件一样填一些必要的信息，然后一路下一步就生成了一个工程；</li>
</ul>
<p>接下来我将使用这两种方式分别创建工程，首先是第一种。</p>
<h3 id="StepByStep-创建工程"><a href="#StepByStep-创建工程" class="headerlink" title="StepByStep 创建工程"></a>StepByStep 创建工程</h3><ol>
<li>全局安装<code>Ionic</code>的脚手架工具<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g @ionic/cli</span><br></pre></td></tr></table></figure></li>
<li>创建工程<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ionic start myApp tabs <span class="comment">// myApp 是项目目录名称也是工程名称 tabs是模板名称</span></span><br></pre></td></tr></table></figure></li>
<li>启动工程<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd myApp</span><br><span class="line">ionic serve</span><br></pre></td></tr></table></figure></li>
</ol>
<p>嗯，上面三个步骤之后，你的Ionic项目就启动起来了。（What ！？ 这么简单？！ 嗯，是的。）</p>
<h3 id="向导式（App-Wizard）创建工程"><a href="#向导式（App-Wizard）创建工程" class="headerlink" title="向导式（App Wizard）创建工程"></a>向导式（App Wizard）创建工程</h3><p>这是一个在线创建工程的手段（感觉对于开发人员来说貌似还是命令行来的方便，这种可视化方案应该是给小白用户准备的吧），地址如下</p>
<blockquote>
<p><a href="https://ionicframework.com/start">https://ionicframework.com/start</a></p>
</blockquote>
<p><img src="" alt="此处是个图"></p>
<p>点开上面的地址，你会看到如图所示的一个界面，我们可以看到它要求你输入的一些信息</p>
<ol>
<li>App Name</li>
<li>Icon</li>
<li>Theme Color</li>
<li>Template</li>
<li>Framework</li>
</ol>
<p>可以看到这比命令行要多出几个信息，上面的命令行只要求了 <code>App Name</code> 和 <code>Template</code> 难道强大的命令行不支持设置这些么？答案是否定的，当然可以设置这些信息，只是以参数的形式而已，先不说这个，填写好上面的信息以后我们点击<code>[create App]</code>按钮，这时我们进入了下一步，选择代码仓库（Choose a git host），你会看到下面有一个<code>[Skip]</code>按钮说明这步不是必须的，我们先选择一个<code>git</code>仓库，这里我选择<code>github</code>，其他的感兴趣的同学可以自己试试。点击<code>[connect]</code>，这时会弹出一个窗口，申请对应git仓库的鉴权认证，认证通过后我们点击<code>[choose]</code>，等待程序运行一会儿后工程就会被上传到git仓库中，并且会跳转到一个<code>DashBoard</code>，提供了可视化管理工程的页面（也太高大上了吧），右侧我们看到如何把代码下载到本地，并运行它，真的是很方便。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g @ionic/cli cordova-res <span class="comment">// cordova-res 指的是安装 cordova 的开发依赖，因为除 cordova 之外还可以选择如 phonegap 之类的MobileOS 框架</span></span><br><span class="line">git clone https:<span class="comment">//github.com/lixuguang/li-app.git li-app</span></span><br><span class="line">cd li-app &amp;&amp; npm install &amp;&amp; ionic serve</span><br></pre></td></tr></table></figure>

<p>执行完上面的命令以后，我们的工程也就运行起来了，也是十分方便，即使不会写代码的人，跟着指南也可以很方便的搭建一个Ionic工程。</p>
<h2 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h2><p>Ionic 的体系当中，最重要的莫过于 Ionic CLI 和 UI Component 两个了，接下来我将分辨将这两部分中最重要的内容拿出来说说。</p>
<h3 id="Ionic-CLI"><a href="#Ionic-CLI" class="headerlink" title="Ionic CLI"></a>Ionic CLI</h3><p>在上面的快速上手中，我们已经使用了几个命令，但这些还不够，Ionic CLI 提供了强大的命令，请与我一起看一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install -g @ionic/cli <span class="comment">// 全局安装 Ionic CLI</span></span><br><span class="line">ionic start myApp tabs <span class="comment">// 用模板创建工程</span></span><br><span class="line">ionic start --list <span class="comment">// 查看可用模板</span></span><br><span class="line">ionic serve <span class="comment">// 启动工程</span></span><br><span class="line">ionic serve --lab <span class="comment">// 以android或ios方式打开</span></span><br><span class="line">ionic lib update <span class="comment">// 更新包</span></span><br><span class="line">ionic serve --address <span class="number">192.168</span><span class="number">.89</span><span class="number">.1</span> <span class="comment">// 指定Ip，给外部用户访问</span></span><br><span class="line">ionic platform add ios/android <span class="comment">// 添加平台</span></span><br><span class="line">ionic build ios/android <span class="comment">// 构建平台</span></span><br><span class="line">ionic emulate ios [options]  <span class="comment">// ionic run ios [options] 模拟器运行</span></span><br><span class="line"></span><br><span class="line">ionic generate <span class="comment">// 创建新特性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">options</span><br><span class="line">  -l <span class="comment">//livereload， 实时刷新变化。</span></span><br><span class="line">  -c  <span class="comment">//打印app里的console</span></span><br><span class="line">  -s  <span class="comment">//打印设备的console</span></span><br><span class="line">  -p  <span class="comment">//指定设备的端口</span></span><br><span class="line">  -i  <span class="comment">//指定livereload的重刷端口</span></span><br><span class="line">  --debug <span class="comment">//debug</span></span><br><span class="line">  --release <span class="comment">//release</span></span><br><span class="line">  --host=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="comment">// IP</span></span><br><span class="line">  --port=<span class="number">8100</span> <span class="comment">// 端口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ionic resources [--splash] [--icon] <span class="comment">// 上传代码到官方平台</span></span><br><span class="line">ionic upload <span class="comment">// 登录</span></span><br><span class="line">ionic info <span class="comment">// 查看系统信息</span></span><br><span class="line">ionic browser add crosswalk <span class="comment">// 加壳预览（手机浏览器性能问题解决）</span></span><br><span class="line">ionic browser list <span class="comment">// 查看可用的browser</span></span><br><span class="line">ionic browser revert android/ios <span class="comment">// 删除安装的browser</span></span><br><span class="line">ionic state reset <span class="comment">// 先删除平台和插件，再安装package.json文件中的平台和插件。重置</span></span><br><span class="line">ionic state save <span class="comment">// 保存当前状态信息</span></span><br><span class="line">ionic state clear <span class="comment">// 先删除平台和插件，然后按照package.json文件中包含的平台和插件重新安装。</span></span><br><span class="line"></span><br><span class="line">npm install @ionic/angular@latest --save <span class="comment">// Ionic + Angular</span></span><br><span class="line">ng add @ionic/angular <span class="comment">// 使用Angular CLI 增加Ionic的组件库，可用于Angular项目改造Ionic</span></span><br><span class="line"></span><br><span class="line">npm install @ionic/react <span class="comment">// Ionic + React</span></span><br><span class="line">npm install @ionic/react-router <span class="comment">// 在既存的react项目中引入ionic特性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加CSS文件为组件服务，加在根组件下</span></span><br><span class="line"><span class="comment">/* Core CSS required for Ionic components to work properly */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/core.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Basic CSS for apps built with Ionic */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/normalize.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/structure.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/typography.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional CSS utils that can be commented out */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/padding.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/float-elements.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/text-alignment.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/text-transformation.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/flex-utils.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/react/css/display.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">npm install @ionic/vue @ionic/vue-router <span class="comment">// Ionic + Vue ，在既存的Vue项目中引入ionic特性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 文件中加入引入</span></span><br><span class="line"><span class="keyword">import</span> &#123; IonicVue &#125; <span class="keyword">from</span> <span class="string">&#x27;@ionic/vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line">  .use(IonicVue)</span><br><span class="line">  .use(router);</span><br><span class="line"></span><br><span class="line">router.isReady().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  app.mount(<span class="string">&#x27;#app&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// router/index.js 用Ionic提供的vue-router替换原本的vue-router</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;@ionic/vue-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// routes go here</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  history: createWebHistory(process.env.BASE_URL),</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加CSS文件为组件服务 main.js</span></span><br><span class="line"><span class="comment">/* Core CSS required for Ionic components to work properly */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/core.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Basic CSS for apps built with Ionic */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/normalize.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/structure.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/typography.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional CSS utils that can be commented out */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/padding.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/float-elements.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/text-alignment.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/text-transformation.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/flex-utils.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/display.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line">From here, you can learn about how to develop <span class="keyword">with</span> Ionic Framework <span class="keyword">in</span> our [Ionic Vue Quickstart Guide](https:<span class="comment">//ionicframework.com/docs/vue/quickstart).</span></span><br><span class="line"></span><br><span class="line">## Ionicons CDN</span><br><span class="line"></span><br><span class="line">Ionicons is packaged by <span class="keyword">default</span> <span class="keyword">with</span> the Ionic Framework, so no installation is necessary <span class="keyword">if</span> you<span class="string">&#x27;re using Ionic. To use Ionicons without Ionic Framework, place the following `&lt;script&gt;` near the end of your page, right before the closing `&lt;/body&gt;` tag.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script type=&quot;module&quot; src=&quot;https://cdn.jsdelivr.net/npm/ionicons@4.7.4/dist/ionicons/ionicons.esm.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script nomodule src=&quot;https://cdn.jsdelivr.net/npm/ionicons@4.7.4/dist/ionicons/ionicons.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>


<p>（待续…）</p>
]]></content>
      <categories>
        <category>大前端</category>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3新属性-pointer-events</title>
    <url>/2020/05/14/css3-pointer-events/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在看一个叫做Avue的框架组件时看到了一个叫做“全局水印”的组件，功能呢就是给当前页面加上一个水印遮罩，就像下图这样：<br><img src="https://s1.ax1x.com/2020/05/14/Y08cbd.png" alt="Y08cbd.png"><br>因为工作中有这样的场景，所以我很好奇看了一下他的代码，他的水印设置为了fixed定位，并且z-index设置的很高，但是它具有穿透性，最终我发现其中起作用的是一个叫做“pointer-events”的css3新属性，于是为了搞清楚它的作用，我在网上做了一番搜索，并把自己的认识整理一下。</p>
<span id="more"></span>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MDN上是这样介绍这个属性的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/pointer-events">传送门</a>。</p>
<blockquote>
<p>pointer-events CSS 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。</p>
</blockquote>
<p>它有如下这些个属性值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: auto;</span><br><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line"><span class="attribute">pointer-events</span>: visiblePainted; <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: visibleFill;    <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: visibleStroke;  <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: visible;        <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: painted;        <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: fill;           <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: stroke;         <span class="comment">/* SVG only */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: all;            <span class="comment">/* SVG only */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">pointer-events</span>: inherit;</span><br><span class="line"><span class="attribute">pointer-events</span>: initial;</span><br><span class="line"><span class="attribute">pointer-events</span>: unset;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有一个特别的值，它进行了专门的介绍，也正是因为这个原因，水印的功能才得以实现。</p>
<blockquote>
<p>除了指示该元素不是鼠标事件的目标之外，值none表示鼠标事件“穿透”该元素并且指定该元素“下面”的任何东西。</p>
</blockquote>
<p>由上可知，当我们将pointer-events值设置为none时，它就有了穿透的特性，也就是说你“看得见它，却摸不到它”，而且也不具备鼠标指针的特性，这不正是水印想要的效果嘛，完美~;</p>
<p>接着往下看我们可以知道它的初始值是auto，并且可以继承<br><img src="https://s1.ax1x.com/2020/05/14/Y0J0XD.png" alt="Y0J0XD.png"></p>
<p>水印功能就这样实现了是不是简单实用，那么是不是就没有缺点呢，当然要硬说有的话那就是兼容性的问题吧。</p>
<p>因为这个css3的属性是新出的，自然ie9及以下自然就不支持了，而且ie不支持的范围要到ie11以下，所以ie你为啥不去死呢。。。</p>
<p><img src="https://s1.ax1x.com/2020/05/14/Y0YEjO.png" alt="Y0YEjO.png"></p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>Prettier格式化配置</title>
    <url>/2020/05/28/Prettier-Setting/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做代码风格统一，用到了Prettier，暂时先记录一下现在的配置信息，回头抽时间写篇总结文。</p>
<span id="more"></span>
<h2 id="一、技术栈"><a href="#一、技术栈" class="headerlink" title="一、技术栈"></a>一、技术栈</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使能每一种语言默认格式化规则</span></span><br><span class="line">    <span class="attr">&quot;[html]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;[css]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;[less]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;[javascript]&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  prettier的配置 */</span></span><br><span class="line">    <span class="attr">&quot;prettier.printWidth&quot;</span>: <span class="number">100</span>, <span class="comment">// 超过最大值换行</span></span><br><span class="line">    <span class="attr">&quot;prettier.tabWidth&quot;</span>: <span class="number">4</span>, <span class="comment">// 缩进字节数</span></span><br><span class="line">    <span class="attr">&quot;prettier.useTabs&quot;</span>: <span class="literal">false</span>, <span class="comment">// 缩进不使用tab，使用空格</span></span><br><span class="line">    <span class="attr">&quot;prettier.semi&quot;</span>: <span class="literal">true</span>, <span class="comment">// 句尾添加分号</span></span><br><span class="line">    <span class="attr">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 使用单引号代替双引号</span></span><br><span class="line">    <span class="attr">&quot;prettier.proseWrap&quot;</span>: <span class="string">&quot;preserve&quot;</span>, <span class="comment">// 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行</span></span><br><span class="line">    <span class="attr">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>, <span class="comment">//  (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号</span></span><br><span class="line">    <span class="attr">&quot;prettier.bracketSpacing&quot;</span>: <span class="literal">true</span>, <span class="comment">// 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;</span></span><br><span class="line">    <span class="attr">&quot;prettier.disableLanguages&quot;</span>: [<span class="string">&quot;vue&quot;</span>], <span class="comment">// 不格式化vue文件，vue文件的格式化单独设置</span></span><br><span class="line">    <span class="attr">&quot;prettier.endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span>, <span class="comment">// 结尾是 \n \r \n\r auto</span></span><br><span class="line">    <span class="attr">&quot;prettier.eslintIntegration&quot;</span>: <span class="literal">false</span>, <span class="comment">//不让prettier使用eslint的代码格式进行校验</span></span><br><span class="line">    <span class="attr">&quot;prettier.htmlWhitespaceSensitivity&quot;</span>: <span class="string">&quot;ignore&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;prettier.ignorePath&quot;</span>: <span class="string">&quot;.prettierignore&quot;</span>, <span class="comment">// 不使用prettier格式化的文件填写在项目的.prettierignore文件中</span></span><br><span class="line">    <span class="attr">&quot;prettier.jsxBracketSameLine&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在jsx中把&#x27;&gt;&#x27; 是否单独放一行</span></span><br><span class="line">    <span class="attr">&quot;prettier.jsxSingleQuote&quot;</span>: <span class="literal">false</span>, <span class="comment">// 在jsx中使用单引号代替双引号</span></span><br><span class="line">    <span class="attr">&quot;prettier.parser&quot;</span>: <span class="string">&quot;babylon&quot;</span>, <span class="comment">// 格式化的解析器，默认是babylon</span></span><br><span class="line">    <span class="attr">&quot;prettier.requireConfig&quot;</span>: <span class="literal">false</span>, <span class="comment">// Require a &#x27;prettierconfig&#x27; to format prettier</span></span><br><span class="line">    <span class="attr">&quot;prettier.stylelintIntegration&quot;</span>: <span class="literal">false</span>, <span class="comment">//不让prettier使用stylelint的代码格式进行校验</span></span><br><span class="line">    <span class="attr">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;es5&quot;</span>, <span class="comment">// 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）</span></span><br><span class="line">    <span class="attr">&quot;prettier.tslintIntegration&quot;</span>: <span class="literal">false</span> <span class="comment">// 不让prettier使用tslint的代码格式进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>效率工具</category>
        <category>VSCode插件</category>
      </categories>
      <tags>
        <tag>Prettier</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试Vue篇：Vue组件通信的几种方式</title>
    <url>/2019/12/27/Vue-Component-Communication/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司这两年兴起了前后端分离的热潮，在选用三大技术框架时，vue凭借其学习曲线低深受公司程序员的喜爱，因此我们也就走上了vue学习的不归路，在招聘招揽小伙伴时有那么一些问题经常被问起，vue组件间通信就是其中之一，下面我们来聊一聊vue组件通信有哪些方式。</p>
<span id="more"></span>

<h2 id="props和-emit"><a href="#props和-emit" class="headerlink" title="props和$emit"></a><code>props</code>和<code>$emit</code></h2><p>啥也不了解的小伙伴应该也知道这种方式吧，这是最最基础的通信方式了，父子组件通信基本都用它。父组件向子组件传递数据的时候通过prop传参，子组件中通过$emit传递给父组件，父组件在触发子组件$emit方法时得到子组件数据。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件 parent.vue</span><br><span class="line"></span><br><span class="line">Vue.compinent(&#39;parent&#39;, &#123;</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;p&gt;父组件&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;child :message&#x3D;&quot;message&quot; @getChildrenData&#x3D;&quot;getChildrenData&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message:&#39;Hello lixuguang&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        * 执行子组件触发的事件方法 </span><br><span class="line">        *&#x2F;</span><br><span class="line">        getChildrenData(data)&#123;</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件 child.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;child&#39;, &#123;</span><br><span class="line">    props:[&#39;message&#39;], &#x2F;&#x2F; 得到父组件传过来的数据</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childMessage: this.message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;childMessage&quot; @input&#x3D;&quot;emitParentData(childMessage)&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        emitParentData(data) &#123;</span><br><span class="line">            this.$emit(&#39;getChildrenData&#39;, data) &#x2F;&#x2F; 父组件触发时给父组件传值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>解析代码：</strong></p>
<ol>
<li>父组件通过<code>message</code>属性将数据传递给子组件，并且通过<code>getChildrenData</code>事件来监听子组件出发的事件；</li>
<li>子组件通过<code>props</code>获得父组件传过来的数据，并且通过<code>this.$emit</code>触发了<code>getChildrenData</code>事件;</li>
</ol>
<h2 id="attrs和-listeners"><a href="#attrs和-listeners" class="headerlink" title="$attrs和$listeners"></a><code>$attrs</code>和<code>$listeners</code></h2><p>前一种方法我们完成了父子组件的数据通信，那你有没有想过如果有多层嵌套的数据最上层要往最下层传值怎么办，前一种方法只能一层一层的往下传，可是这样太麻烦了，那么有没有什么方法能够一次传到你想要传到的位置呢，当然是有的，那就是接下来要说到的<code>$attrs</code>和<code>$listeners</code>。<br>假设我们现在有三层包含关系的组件，分别是level1/level2/level3，level1 &gt; level2 &gt; level3, <code>&gt;</code> 表示包含关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; level3.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;level3&#39;, &#123;</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;$attrs.level3Message&quot; @input&#x3D;&quot;emitLevel3Data($attrs.level3Message)&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        emitLevel3Data(data) &#123;</span><br><span class="line">            this.$emit(&#39;getLevel3Data&#39;, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level2.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;level2&#39;, &#123;</span><br><span class="line">    props:[&#39;level2Message&#39;],</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            level2Message:this.level2Message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;level2Message&quot; @input&#x3D;&quot;emitLevel2Data(level2Message)&quot;&gt;</span><br><span class="line">    &lt;level3 v-bind&#x3D;&#39;$attrs&#39; v-on&#x3D;&#39;$listenrs&#39;&gt;&lt;&#x2F;level3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        emitLevel2Data(data) &#123;</span><br><span class="line">            this.$emit(&#39;getLevel2Data&#39;, data) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level1.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;level1&#39;, &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            level3Message:&quot;I am Level3&quot;,</span><br><span class="line">            level2Message:&quot;I am Level2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是level1中的内容&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;level2 :level2Message&#x3D;&quot;level2Message&quot; </span><br><span class="line">            :level3Message&#x3D;&quot;level3Message&quot;</span><br><span class="line">            @getLevel2Data&#x3D;&quot;getLevel2Data()&quot;</span><br><span class="line">            @getLevel3Data&#x3D;&quot;getLevel3Data()&quot;</span><br><span class="line">            &gt;&lt;&#x2F;level2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getLevel2Data(data) &#123;</span><br><span class="line">            console.log(&#39;这是来自level2的数据&#39;, data)</span><br><span class="line">        &#125;,</span><br><span class="line">        getLevel3Data(data) &#123;</span><br><span class="line">            console.log(&#39;这是来自level3的数据&#39;, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line"></span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;level1&gt;&lt;&#x2F;level1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>解析代码：</strong></p>
<ol>
<li>level3组件能直接触发<code>getLevel3Data</code>是因为level2组件在调用level3组件时使用v-on绑定了$listeners属性；</li>
<li>通过v-bind绑定了$attrs属性，level3组件可以直接获取到从level1传下来的props;</li>
</ol>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>父组件通过v-model传递值给子组件时，会自动传递一个value的props户型，在子组件中可以通过this.$emit(‘input’,val)自动修改v-model绑定的值。</p>
<p>```</p>
<p>未完待续~</p>
<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><!-- more -->
<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><!-- more -->]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript实现经典排序算法</title>
    <url>/2020/01/04/Algorithm/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。<br>没有循环语句，记作O(1)，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。<br>常见的时间复杂度有：</p>
<ul>
<li>O(1): Constant Complexity: Constant 常数复杂度</li>
<li>O(log n): Logarithmic Complexity: 对数复杂度</li>
<li>O(n): Linear Complexity: 线性时间复杂度</li>
<li>O(n^2): N square Complexity 平⽅方</li>
<li>O(n^3): N square Complexity ⽴立⽅方</li>
<li>O(2^n): Exponential Growth 指数</li>
<li>O(n!): Factorial 阶乘</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。</p>
<p>一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。</p>
<ul>
<li>稳定</li>
<li>不稳定<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><img src="https://i.loli.net/2020/01/04/TqaRjEJSnhtQ5vH.png" alt="十大经典排序.jpg"><h2 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h2>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。<br>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；<br>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序<br>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ul>
<h2 id="关于稳定性："><a href="#关于稳定性：" class="headerlink" title="关于稳定性："></a>关于稳定性：</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。<br>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ul>
<li>n：数据规模</li>
<li>k：“桶”的个数</li>
<li>In-place：占用常数内存，不占用额外内存</li>
<li>Out-place：占用额外内存</li>
<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>
</ul>
<h1 id="1-冒泡排序（Bubble-Sort）-—-前后两两比较-—-气泡"><a href="#1-冒泡排序（Bubble-Sort）-—-前后两两比较-—-气泡" class="headerlink" title="1. 冒泡排序（Bubble Sort） — 前后两两比较 — 气泡"></a>1. 冒泡排序（Bubble Sort） — 前后两两比较 — 气泡</h1><p>冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，其优点是实现简单，排序数量较小时性能较好。</p>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h2 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1. 1 算法原理"></a>1. 1 算法原理</h2><p>相邻的数据进行两两比较，小数放在前面，大数放在后面，如果前面的数据比后面的数据大，就交换这两个数的位置。也可以实现大数放在前面，小数放在后面，如果前面的数据比后面的小，就交换两个的位置。要实现上述规则需要用到两层for循环。</p>
<h2 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1. 2 算法描述"></a>1. 2 算法描述</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<h2 id="1-3-动图演示"><a href="#1-3-动图演示" class="headerlink" title="1. 3 动图演示"></a>1. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldB5VS.gif" alt="ldB5VS.gif"></p>
<h2 id="1-4-js代码实现"><a href="#1-4-js代码实现" class="headerlink" title="1. 4 js代码实现"></a>1. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len &#x3D; arr.length;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 相邻元素两两对比</span><br><span class="line">      &#x2F;&#x2F; 元素交换</span><br><span class="line">      &#x2F;** 1.使用中间变量 **&#x2F; </span><br><span class="line">        var temp &#x3D; arr[j + 1]; </span><br><span class="line">        arr[j + 1] &#x3D; arr[j]</span><br><span class="line">        arr[j] &#x3D; temp</span><br><span class="line">        &#x2F;** 2.适用纯数字的数组排序 **&#x2F;</span><br><span class="line">        arr[j] &#x3D; arr[j] +  arr[j + 1]</span><br><span class="line">        arr[j + 1] &#x3D;  arr[j] - arr[j + 1]</span><br><span class="line">        arr[j] -&#x3D; arr[j + 1]</span><br><span class="line">        &#x2F;** 3.使用es6解构赋值 **&#x2F;</span><br><span class="line">        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len &#x3D; arr.length;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    var exchange&#x3D;false; &#x2F;&#x2F; 交换标志 </span><br><span class="line">    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 相邻元素两两对比</span><br><span class="line">        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]] &#x2F;&#x2F; 元素交换</span><br><span class="line">        exchange&#x3D;true; &#x2F;&#x2F;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!exchange)&#123; &#x2F;&#x2F; 若本趟排序未发生交换，提前终止算法</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-选择排序（Selection-Sort）-—-面试挑简历，在剩下的里面挑最好的"><a href="#2-选择排序（Selection-Sort）-—-面试挑简历，在剩下的里面挑最好的" class="headerlink" title="2. 选择排序（Selection Sort） — 面试挑简历，在剩下的里面挑最好的"></a>2. 选择排序（Selection Sort） — 面试挑简历，在剩下的里面挑最好的</h1><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="2-1-算法原理"><a href="#2-1-算法原理" class="headerlink" title="2. 1 算法原理"></a>2. 1 算法原理</h2><p>先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2. 2 算法描述"></a>2. 2 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中</li>
<li> 选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li> n-1趟结束，数组有序化了。</li>
</ol>
<h2 id="2-3-动图演示"><a href="#2-3-动图演示" class="headerlink" title="2. 3 动图演示"></a>2. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldDWW9.gif" alt="ldDWW9.gif"></p>
<h2 id="2-4-js代码实现"><a href="#2-4-js代码实现" class="headerlink" title="2. 4 js代码实现"></a>2. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex &#x3D; i;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F;寻找最小的数</span><br><span class="line">                minIndex &#x3D; j;                 &#x2F;&#x2F;将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[minIndex];</span><br><span class="line">        arr[minIndex] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-插入排序（Insertion-Sort）—–-麻将-扑克"><a href="#3-插入排序（Insertion-Sort）—–-麻将-扑克" class="headerlink" title="3. 插入排序（Insertion Sort）—– 麻将/扑克"></a>3. 插入排序（Insertion Sort）—– 麻将/扑克</h1><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。</p>
<h2 id="3-1-算法原理"><a href="#3-1-算法原理" class="headerlink" title="3. 1 算法原理"></a>3. 1 算法原理</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="3-2-算法描述"><a href="#3-2-算法描述" class="headerlink" title="3. 2 算法描述"></a>3. 2 算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h2 id="3-3-动图演示"><a href="#3-3-动图演示" class="headerlink" title="3. 3 动图演示"></a>3. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldDfzR.gif" alt="ldDfzR.gif"></p>
<h2 id="3-4-js代码实现"><a href="#3-4-js代码实现" class="headerlink" title="3. 4 js代码实现"></a>3. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">  &#x2F;&#x2F; 从1位置开始遍历arr中每元素，同时声明空变量temp</span><br><span class="line">  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr[i] &lt; arr[i - 1]) &#123; &#x2F;&#x2F; 如果当前元素&lt;前一个元素</span><br><span class="line">      let temp &#x3D; arr[i] &#x2F;&#x2F; 将当前元素值临时保存在temp中</span><br><span class="line">      let p &#x3D; i - 1 &#x2F;&#x2F; 定义变量 p &#x3D; i- 1</span><br><span class="line">      &#x2F;&#x2F; 循环 条件：</span><br><span class="line">      &#x2F;&#x2F; 1. p&gt;&#x3D;0且temp小于p位置的元素</span><br><span class="line">      while (p &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[p]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环体： 将P位置的值赋值给p的后一个元素</span><br><span class="line">        arr[p + 1] &#x3D; arr[p]</span><br><span class="line">        p-- &#x2F;&#x2F; p向前移动一个</span><br><span class="line">      &#125;</span><br><span class="line">      arr[p + 1] &#x3D; temp &#x2F;&#x2F; 将temp的值赋值给p+1位置的元素</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-快速排序（Selection-Sort）"><a href="#4-快速排序（Selection-Sort）" class="headerlink" title="4. 快速排序（Selection Sort）"></a>4. 快速排序（Selection Sort）</h1><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<h2 id="4-1-算法原理"><a href="#4-1-算法原理" class="headerlink" title="4. 1 算法原理"></a>4. 1 算法原理</h2><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<h2 id="4-2-算法描述"><a href="#4-2-算法描述" class="headerlink" title="4. 2 算法描述"></a>4. 2 算法描述</h2><p>选基准：在数据结构中选择一个元素作为基准(pivot<br>划分区：参照基准元素值的大小，划分无序区，所有小于基准元素的数据放入一个区间，所有大于基准元素的数据放入另一区间，分区操作结束后，基准元素所处的位置就是最终排序后它应该所处的位置<br>递归：对初次划分出来的两个无序区间，递归调用第 1步和第 2步的算法，直到所有无序区间都只剩下一个元素为止。</p>
<p>简单理解就是，选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。</p>
<h2 id="4-3-动图演示"><a href="#4-3-动图演示" class="headerlink" title="4. 3 动图演示"></a>4. 3 动图演示</h2><p><img src="https://i.loli.net/2020/01/04/AtNahbZF9J1dTnS.gif" alt="快速排序.gif"></p>
<h2 id="4-4-js代码实现"><a href="#4-4-js代码实现" class="headerlink" title="4. 4 js代码实现"></a>4. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果arr.length&lt;&#x3D;1,则直接返回arr</span><br><span class="line">    if(arr.length&lt;&#x3D;1)&#123;return arr&#125;</span><br><span class="line">    &#x2F;&#x2F; arr的元素个数&#x2F;2，再下去整，将值保存在pivotIndex中</span><br><span class="line">    var pivotIndex&#x3D;Math.floor(arr.length&#x2F;2);</span><br><span class="line">    &#x2F;&#x2F; 将arr中pivotIndex位置的元素，保存在变量pivot中</span><br><span class="line">    var pivot&#x3D;arr[pivotIndex];</span><br><span class="line">    &#x2F;&#x2F;声明空数组left和right</span><br><span class="line">    var left&#x3D;[];</span><br><span class="line">    var right&#x3D;[];</span><br><span class="line">    for(var i&#x3D;0;i&lt;arr.length;i++)&#123;  &#x2F;&#x2F; 遍历arr中每个元素</span><br><span class="line">        if(i !&#x3D;&#x3D; pivotIndex)&#123; &#x2F;&#x2F; 如果i !&#x3D;&#x3D; pivotIndex</span><br><span class="line">            if(arr[i]&lt;&#x3D;pivot)&#123; &#x2F;&#x2F; 如果当前元素值&lt;pivot</span><br><span class="line">                left.push(arr[i]); &#x2F;&#x2F; 就将当前值压入left</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                right.push(arr[i]); &#x2F;&#x2F; 就将当前值压入right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归</span><br><span class="line">    return quickSort(left).concat(pivot, quickSort(right)); &#x2F;&#x2F; 链接多个数组到 left 从小到大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><h2 id="5-1-算法原理"><a href="#5-1-算法原理" class="headerlink" title="5. 1 算法原理"></a>5. 1 算法原理</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</li>
</ul>
<h2 id="5-2-算法描述"><a href="#5-2-算法描述" class="headerlink" title="5. 2 算法描述"></a>5. 2 算法描述</h2><ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h2 id="5-3-js代码实现"><a href="#5-3-js代码实现" class="headerlink" title="5.3 js代码实现"></a>5.3 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap &#x3D; 1;</span><br><span class="line">    while(gap &lt; len&#x2F;3) &#123;          &#x2F;&#x2F;动态定义间隔序列</span><br><span class="line">        gap &#x3D;gap*3+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (gap; gap &gt; 0; gap &#x3D; Math.floor(gap&#x2F;3)) &#123;</span><br><span class="line">        for (var i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            for (var j &#x3D; i-gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j-&#x3D;gap) &#123;</span><br><span class="line">                arr[j+gap] &#x3D; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><h2 id="6-1-算法原理"><a href="#6-1-算法原理" class="headerlink" title="6. 1 算法原理"></a>6. 1 算法原理</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；<blockquote>
<p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：<br>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.<br>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p>
</blockquote>
</li>
</ul>
<p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h2 id="6-2-算法描述"><a href="#6-2-算法描述" class="headerlink" title="6. 2 算法描述"></a>6. 2 算法描述</h2><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h2 id="6-3-动图演示"><a href="#6-3-动图演示" class="headerlink" title="6. 3 动图演示"></a>6. 3 动图演示</h2><p><img src="https://i.loli.net/2020/01/04/WMFo8Au4CGah6Kv.gif" alt="归并排序.gif"></p>
<h2 id="6-4-js代码实现"><a href="#6-4-js代码实现" class="headerlink" title="6. 4 js代码实现"></a>6. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function mergeSort(arr) &#123;  &#x2F;&#x2F; 采用自上而下的递归方法</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    if(len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle &#x3D; Math.floor(len &#x2F; 2),</span><br><span class="line">        left &#x3D; arr.slice(0, middle),</span><br><span class="line">        right &#x3D; arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        if (left[0] &lt;&#x3D; right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h1><h2 id="7-1-算法原理"><a href="#7-1-算法原理" class="headerlink" title="7. 1 算法原理"></a>7. 1 算法原理</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</li>
</ul>
<h1 id="7-2-算法描述"><a href="#7-2-算法描述" class="headerlink" title="7. 2 算法描述"></a>7. 2 算法描述</h1><ol>
<li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ol>
<h2 id="7-3-动图演示"><a href="#7-3-动图演示" class="headerlink" title="7. 3 动图演示"></a>7. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/05/lBK9QH.gif" alt="堆排序.gif"></p>
<h2 id="7-4-js代码实现"><a href="#7-4-js代码实现" class="headerlink" title="7. 4 js代码实现"></a>7. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var len;    &#x2F;&#x2F; 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"></span><br><span class="line">function buildMaxHeap(arr) &#123;   &#x2F;&#x2F; 建立大顶堆</span><br><span class="line">    len &#x3D; arr.length;</span><br><span class="line">    for (var i &#x3D; Math.floor(len&#x2F;2); i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapify(arr, i) &#123;     &#x2F;&#x2F; 堆调整</span><br><span class="line">    var left &#x3D; 2 * i + 1,</span><br><span class="line">        right &#x3D; 2 * i + 2,</span><br><span class="line">        largest &#x3D; i;</span><br><span class="line"></span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (largest !&#x3D; i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; arr.length-1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><h2 id="8-1-算法原理"><a href="#8-1-算法原理" class="headerlink" title="8. 1 算法原理"></a>8. 1 算法原理</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="8-2-算法描述"><a href="#8-2-算法描述" class="headerlink" title="8. 2 算法描述"></a>8. 2 算法描述</h2><h2 id="8-3-动图演示"><a href="#8-3-动图演示" class="headerlink" title="8. 3 动图演示"></a>8. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/05/lBKq1g.gif" alt="计数排序.gif"></p>
<h2 id="8-4-js代码实现"><a href="#8-4-js代码实现" class="headerlink" title="8. 4 js代码实现"></a>8. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket &#x3D; new Array(maxValue+1),</span><br><span class="line">        sortedIndex &#x3D; 0;</span><br><span class="line">        arrLen &#x3D; arr.length,</span><br><span class="line">        bucketLen &#x3D; maxValue + 1;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var j &#x3D; 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] &#x3D; j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h1><h2 id="9-1-算法原理"><a href="#9-1-算法原理" class="headerlink" title="9. 1 算法原理"></a>9. 1 算法原理</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<h2 id="9-2-算法描述"><a href="#9-2-算法描述" class="headerlink" title="9. 2 算法描述"></a>9. 2 算法描述</h2><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h3>当输入的数据可以均匀的分配到每一个桶中。<h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h3>当输入的数据被分配到了同一个桶中。<h2 id="9-3-动图演示"><a href="#9-3-动图演示" class="headerlink" title="9. 3 动图演示"></a>9. 3 动图演示</h2></li>
</ul>
<h2 id="9-4-js代码实现"><a href="#9-4-js代码实现" class="headerlink" title="9. 4 js代码实现"></a>9. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var i;</span><br><span class="line">    var minValue &#x3D; arr[0];</span><br><span class="line">    var maxValue &#x3D; arr[0];</span><br><span class="line">    for (i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE &#x3D; 5;            &#x2F;&#x2F; 设置桶的默认数量为5</span><br><span class="line">    bucketSize &#x3D; bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount &#x3D; Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;   </span><br><span class="line">    var buckets &#x3D; new Array(bucketCount);</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) &#x2F; bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.length &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      &#x2F;&#x2F; 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j &#x3D; 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h1><h2 id="10-1-算法原理"><a href="#10-1-算法原理" class="headerlink" title="10. 1 算法原理"></a>10. 1 算法原理</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h2 id="10-2-算法描述"><a href="#10-2-算法描述" class="headerlink" title="10. 2 算法描述"></a>10. 2 算法描述</h2><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有三种方法：<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；<h2 id="10-3-动图演示"><a href="#10-3-动图演示" class="headerlink" title="10. 3 动图演示"></a>10. 3 动图演示</h2></li>
</ul>
<ol start="2">
<li>LSD 基数排序动图演示<br><img src="https://s2.ax1x.com/2020/01/05/lBQkPf.gif" alt="基数排序.gif"><h2 id="10-4-js代码实现"><a href="#10-4-js代码实现" class="headerlink" title="10. 4 js代码实现"></a>10. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LSD Radix Sort</span><br><span class="line">var counter &#x3D; [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod &#x3D; 10;</span><br><span class="line">    var dev &#x3D; 1;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; maxDigit; i++, dev *&#x3D; 10, mod *&#x3D; 10) &#123;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket &#x3D; parseInt((arr[j] % mod) &#x2F; dev);</span><br><span class="line">            if(counter[bucket]&#x3D;&#x3D;null) &#123;</span><br><span class="line">                counter[bucket] &#x3D; [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos &#x3D; 0;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value &#x3D; null;</span><br><span class="line">            if(counter[j]!&#x3D;null) &#123;</span><br><span class="line">                while ((value &#x3D; counter[j].shift()) !&#x3D; null) &#123;</span><br><span class="line">                      arr[pos++] &#x3D; value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.ax1x.com/2020/01/05/lBQTSS.png" alt="排序算法.png"><br>以上就是十大经典算法，算法对于前端来说并不是一个十分熟悉的领域，但是排序算法算是算法里比较入门的，还是需要掌握的，毕竟即使是为了面试也是要准备的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a><br>一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。</p>
<p><a href="http://www.sohu.com/a/136157205_671058">http://www.sohu.com/a/136157205_671058</a><br>技术面试宝典： 很全面的算法和数据结构知识（含代码实现）下篇</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode中既想使用path-intellisense插件，又想使用Webpack别名（@）的方法</title>
    <url>/2021/05/08/%E5%85%B3%E4%BA%8EVSCode%E4%B8%AD%E5%88%AB%E5%90%8D%EF%BC%88-%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>
<h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>前端开发我们通常使用VSCode，使用时常见有一个常见的场景：</p>
<blockquote>
<p>引入一个文件、图片等</p>
</blockquote>
<p>如果不利用VSCode的插件，我们通常会写相对路径或者绝对路径，但为了方便写代码，我们通常会利用工具来帮助我们减轻负担，这种情况就引入了今天的主角，VSCode下的插件<strong>path-intellisense</strong>，是的，有了它编辑器就会聪明的自动帮我们提示出文件在什么地方，这的确方便了我们。</p>
<p>但是，在Vue开发过程中，或者说是利用Webpack作为构建工具时我们通常会定义一个变量如：<code>@</code> 来简化路径的书写，使代码变得简洁美观，这里的<code>@</code>，我们称之为 <strong>路径别名</strong> ，这也是Vue官方十分推荐使用的，但因为路径别名的使用，原来的智能提示路径的插件就会无法正常工作，因为工作中确实遇到了这样的坑，所以简单的写个文记录一下。</p>
<h3 id="问题一：因为使用了路径别名（-）导致path-intellisense不能自动提示"><a href="#问题一：因为使用了路径别名（-）导致path-intellisense不能自动提示" class="headerlink" title="问题一：因为使用了路径别名（@）导致path-intellisense不能自动提示"></a>问题一：因为使用了路径别名（@）导致path-intellisense不能自动提示</h3><p>这个问题其实比较容易理解，因为路径别名是Webpack构建时使用的，并不是VSCode原生支持的功能，所以它并不认识<code>@</code>，这是个什么，所以解决思路就是告诉VSCode <code>@</code> 是个什么就好了，专业一点说的话就是加上映射关系</p>
<h4 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h4><ol>
<li>打开path-intellisense插件的setting</li>
<li>找到Mapping配置项</li>
<li>加以下代码<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;path-intellisense.mappings&quot;: &#123;</span><br><span class="line">      &quot;@&quot;: &quot;$&#123;workspaceRoot&#125;/src&quot;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>重启插件搞定！</li>
</ol>
<h3 id="问题二：我们希望-Ctrl-鼠标左键点击一个外部方法时，能够快速跳转到对应的外部文件。"><a href="#问题二：我们希望-Ctrl-鼠标左键点击一个外部方法时，能够快速跳转到对应的外部文件。" class="headerlink" title="问题二：我们希望 Ctrl + 鼠标左键点击一个外部方法时，能够快速跳转到对应的外部文件。"></a>问题二：我们希望 Ctrl + 鼠标左键点击一个外部方法时，能够快速跳转到对应的外部文件。</h3><p>第二个问题提出时，可能会有人有疑问，上面不是配置完映射关系了嘛，为什么还有下面的问题呢，其实你要是不问，我也有这个问题，上一步操作实际上是告诉了path-intellisense插件该怎么解析<code>@</code>这个东西，但是VSCode并不知道啊，但是Ctrl + 鼠标左键的动作又是VSCode负责的事，所以我们也要告诉一下编辑器该如何应对上面的情况，说到这里大家应该就理解了</p>
<h4 id="解决步骤-1"><a href="#解决步骤-1" class="headerlink" title="解决步骤"></a>解决步骤</h4><ol>
<li>在项目package.json所在同级目录下创建文件jsconfig.json（这是VSCode的一个可选配置）</li>
<li>在jsconfig.json增加如下配置<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES6&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>] <span class="comment">// 这里是关键代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;node_modules&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>重启VSCode搞定！</li>
</ol>
<p>通过上面的解决方案，我们就可以愉快的使用VSCode进行前端开发了，你学废了吗？</p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>VSCode插件</tag>
        <tag>path-intellisense</tag>
        <tag>路径别名</tag>
      </tags>
  </entry>
  <entry>
    <title>关于版本管理</title>
    <url>/2021/05/13/%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还记得你的前端工程里有这样一个文件‘package.json’，里面管理者运行代码所需要的各种依赖，每种依赖都会有一个版本号，那么你知道版本号是怎么定义的么？不知道的话就看看下面的内容吧。</p>
<span id="more"></span>
<h2 id="关于版本号的那些事"><a href="#关于版本号的那些事" class="headerlink" title="关于版本号的那些事"></a>关于版本号的那些事</h2><p>你会发现这些版本号通常是三部分构成的，像是‘X.Y.Z’的一种感觉，其实这是一种叫做<code>SemVer</code>的版本管理规范，下面我们就来讲讲<code>SemVer</code>。</p>
<h3 id="SemVer-的生平"><a href="#SemVer-的生平" class="headerlink" title="SemVer 的生平"></a>SemVer 的生平</h3><p>语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。</p>
<p>它的许可证是 知识共享 署名 3.0 (CC BY 3.0)  所以你可以不用付费直接使用它。</p>
<p>关于它的更多描述你可以到下面的地址找到<br><a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></p>
<p>主要你要记住的是如下几句话：</p>
<blockquote>
<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>
<p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>
</blockquote>
<p>更多的内容的话，请到官网查看吧。</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>SemVer</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
</search>
